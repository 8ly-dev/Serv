{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Serv: Your Next-Generation ASGI Web Framework \ud83d\ude80","text":"<p>Pre-Release Software</p> <p>Serv is currently in a pre-release state and is NOT recommended for production use at this time. APIs are subject to change.</p> <p>Tired of boilerplate? Craving flexibility? Say hello to Serv!</p> <p>Serv is a powerful and intuitive ASGI web framework for Python, designed for ultimate extensibility while being opinionated only when necessary. It aims to make building web applications and APIs a breeze, even allowing you to construct entire sites with out-of-the-box extensions, minimizing the need to write custom code.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ud83d\ude80 ASGI Native: Built from the ground up for asynchronous Python</li> <li>\ud83d\udd27 Extensible &amp; Minimally Opinionated: Designed for flexibility, providing guidance where it counts</li> <li>\u26a1 Codeless Site Building: Includes out-of-the-box extensions to get sites up and running quickly</li> <li>\ud83d\udc89 Dependency Injection: Leverages <code>bevy</code> for clean, testable code</li> <li>\ud83d\udd0c Extension Architecture: Easily extend and customize framework behavior beyond the defaults</li> <li>\ud83d\udee1\ufe0f Middleware Support: Integrate custom processing steps into the request/response lifecycle</li> <li>\ud83d\uddfa\ufe0f Flexible Routing: Define routes with ease using functions or classes</li> <li>\ud83d\udea8 Comprehensive Error Handling: Robust mechanisms for managing exceptions</li> <li>\ud83d\udce1 Event System: Emit and listen to events throughout the application lifecycle</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Creating a Serv app is incredibly simple with the CLI! Here's how to build a \"Hello World\" app in under a minute:</p> <pre><code># Create a new Serv application\nserv create app\n\n# Create a hello extension\nserv create extension --name hello\n\n# Add a route\nserv create route --name hello --path /hello --extension hello\n\n# Enable the extension\nserv extension enable hello\n\n# Launch your app\nserv launch\n</code></pre> <p>That's it! Your app will be running at <code>http://localhost:8000/hello</code></p> <p>Want to add more routes? Just use the CLI:</p> <pre><code># Add a route with path parameters\nserv create route --name greet --path \"/greet/{name}\"\n</code></pre>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>Serv is built around several core concepts:</p>"},{"location":"#extension-system","title":"\ud83c\udfd7\ufe0f Extension System","text":"<p>Everything in Serv is a extension. Routes, middleware, and even core functionality are implemented as extensions, making the framework incredibly modular and extensible.</p>"},{"location":"#dependency-injection","title":"\ud83d\udc89 Dependency Injection","text":"<p>Using the <code>bevy</code> library, Serv provides powerful dependency injection capabilities that make your code clean, testable, and maintainable.</p>"},{"location":"#event-driven","title":"\ud83d\udd04 Event-Driven","text":"<p>Serv uses an event system that allows extensions to respond to application lifecycle events, enabling loose coupling between components.</p>"},{"location":"#flexible-routing","title":"\ud83d\udee3\ufe0f Flexible Routing","text":"<p>Support for both functional and class-based routing, with automatic parameter injection and multiple response types.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to dive in? Check out our comprehensive guides:</p> <ul> <li>Installation - Get Serv installed and ready to go</li> <li>Quick Start - Build your first app in minutes</li> <li>Your First App - A detailed walkthrough of creating a complete application</li> <li>Configuration - Learn how to configure Serv for your needs</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>\ud83c\udf10 Website: getserv.ing</li> <li>\ud83d\udce6 PyPI Package: <code>getserving</code></li> <li>\ud83d\udc1b Issues: Report bugs and request features on GitHub</li> <li>\ud83d\udcac Discussions: Join the community discussions on GitHub</li> </ul>"},{"location":"#license","title":"License","text":"<p>Serv is licensed under the MIT License. </p>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>The Serv CLI provides a comprehensive set of commands for managing your web applications, extensions, and development workflow. This reference covers all available commands with detailed examples and usage patterns.</p>"},{"location":"cli-reference/#installation-and-setup","title":"Installation and Setup","text":"<p>The Serv CLI is available when you install the Serv framework:</p> <pre><code>pip install getserving\n</code></pre> <p>Verify the installation:</p> <pre><code>serv --version\n</code></pre>"},{"location":"cli-reference/#global-options","title":"Global Options","text":"<p>All Serv commands support these global options:</p> Option Description Example <code>--version</code> Show version information <code>serv --version</code> <code>--debug</code> Enable debug logging <code>serv --debug launch</code> <code>--dev</code> Enable development mode <code>serv --dev launch</code> <code>--app</code>, <code>-a</code> Custom application class <code>serv -a myapp.core:CustomApp launch</code> <code>--config</code>, <code>-c</code> Path to config file <code>serv -c config/prod.yaml launch</code> <code>--extension-dirs</code> Extension directory path <code>serv --extension-dirs ./custom-extensions launch</code>"},{"location":"cli-reference/#application-management","title":"Application Management","text":""},{"location":"cli-reference/#development-server","title":"Development Server","text":""},{"location":"cli-reference/#serv-launch","title":"<code>serv launch</code>","text":"<p>Launch the Serv application server.</p> <p>Usage: <pre><code>serv launch [--host HOST] [--port PORT] [--reload] [--no-reload] [--workers N] [--factory] [--dry-run]\n</code></pre></p> <p>Options: - <code>--host</code>: Bind socket to this host (default: 127.0.0.1) - <code>--port</code>, <code>-p</code>: Bind socket to this port (default: 8000) - <code>--reload</code>: Enable auto-reload - <code>--no-reload</code>: Disable auto-reload (overrides --dev mode default) - <code>--workers</code>, <code>-w</code>: Number of worker processes (default: 1) - <code>--factory</code>: Treat app as factory function - <code>--dry-run</code>: Load app but don't start server</p> <p>Examples:</p> <pre><code># Basic launch\nserv launch\n\n# Custom host and port\nserv launch --host 0.0.0.0 --port 3000\n\n# Production with multiple workers\nserv launch --workers 4 --host 0.0.0.0 --port 8000\n\n# Development mode with enhanced features\nserv --dev launch\n\n# Development mode with auto-reload disabled\nserv --dev launch --no-reload\n\n# Dry run to test configuration\nserv launch --dry-run\n</code></pre> <p>Development Mode (--dev flag):</p> <p>The global <code>--dev</code> flag enables enhanced development features:</p> <ul> <li>\ud83d\udd04 Auto-reload enabled by default (unless <code>--no-reload</code> is specified)</li> <li>\ud83d\udcdd Enhanced error reporting with full tracebacks</li> <li>\ud83d\udc1b Debug logging automatically enabled</li> <li>\u26a1 Development-optimized uvicorn settings</li> </ul> <pre><code># Start development server\nserv --dev launch\n\n# Development mode on custom port\nserv --dev launch --port 3000\n\n# Development mode without auto-reload\nserv --dev launch --no-reload\n\n# Development mode on all interfaces\nserv --dev launch --host 0.0.0.0\n</code></pre>"},{"location":"cli-reference/#testing","title":"Testing","text":""},{"location":"cli-reference/#serv-test","title":"<code>serv test</code>","text":"<p>Run tests for your application and extensions.</p> <p>Usage: <pre><code>serv test [--extensions] [--e2e] [--coverage] [--verbose] [test_path]\n</code></pre></p> <p>Options: - <code>--extensions</code>: Run extension tests only - <code>--e2e</code>: Run end-to-end tests only - <code>--coverage</code>: Generate coverage report - <code>--verbose</code>, <code>-v</code>: Verbose test output - <code>test_path</code>: Specific test file or directory</p> <p>Examples:</p> <pre><code># Run all tests\nserv test\n\n# Run only extension tests\nserv test --extensions\n\n# Run only e2e tests\nserv test --e2e\n\n# Run with coverage report\nserv test --coverage\n\n# Run specific test file\nserv test tests/test_auth.py\n\n# Verbose output with coverage\nserv test --verbose --coverage\n</code></pre> <p>Example output: <pre><code>\ud83e\uddea Running tests...\n\ud83d\udd0d Running all tests\nRunning: pytest tests/\n\ud83d\udcca Coverage reporting enabled\n\u2705 All tests passed!\n\nCoverage Report:\nName                 Stmts   Miss  Cover\n----------------------------------------\nserv/app.py            45      2    96%\nextensions/auth.py        23      0   100%\n----------------------------------------\nTOTAL                  68      2    97%\n</code></pre></p>"},{"location":"cli-reference/#serv-shell","title":"<code>serv shell</code>","text":"<p>Start an interactive Python shell with your application context loaded.</p> <p>Usage: <pre><code>serv shell [--ipython] [--no-startup]\n</code></pre></p> <p>Options: - <code>--ipython</code>: Use IPython if available - <code>--no-startup</code>: Skip loading app context</p> <p>Examples:</p> <pre><code># Start shell with app context\nserv shell\n\n# Use IPython interface\nserv shell --ipython\n\n# Basic shell without app context\nserv shell --no-startup\n</code></pre> <p>Available objects in shell: - <code>app</code>: Your Serv application instance - <code>serv</code>: The Serv module - <code>extensions</code>: List of loaded extensions - <code>Path</code>: pathlib.Path class - <code>yaml</code>: PyYAML module</p> <p>Example session: <pre><code>\ud83d\udc0d Starting interactive Python shell...\n\ud83d\udce6 Loading Serv app context...\n\ud83d\udd0c Loaded 3 extensions into context\n\u2705 App context loaded successfully\nAvailable objects: app, serv, extensions, Path, yaml\n\n&gt;&gt;&gt; app.site_info\n{'name': 'My Awesome Website', 'description': 'A modern web application'}\n&gt;&gt;&gt; len(extensions)\n3\n&gt;&gt;&gt; extensions[0].name\n'User Management'\n</code></pre></p>"},{"location":"cli-reference/#configuration-management","title":"Configuration Management","text":""},{"location":"cli-reference/#serv-config-show","title":"<code>serv config show</code>","text":"<p>Display your current configuration.</p> <p>Usage: <pre><code>serv config show [--format FORMAT]\n</code></pre></p> <p>Options: - <code>--format</code>: Output format (yaml, json)</p> <p>Examples:</p> <pre><code># Show config in YAML format (default)\nserv config show\n\n# Show config in JSON format\nserv config show --format json\n</code></pre> <p>Example output: <pre><code>\ud83d\udcc4 Configuration from 'serv.config.yaml':\n==================================================\nsite_info:\n  name: My Awesome Website\n  description: A modern web application\nextensions:\n- extension: user_management\n- extension: api_router\nmiddleware:\n- entry: cors_middleware\n</code></pre></p>"},{"location":"cli-reference/#serv-config-validate","title":"<code>serv config validate</code>","text":"<p>Validate your configuration file syntax and structure.</p> <p>Usage: <pre><code>serv config validate\n</code></pre></p> <p>Example output: <pre><code>\u2705 Configuration file is valid YAML\n\u2705 Has required field: site_info\n\u2705 Has required field: extensions\n\ud83c\udf89 Configuration validation passed!\n</code></pre></p>"},{"location":"cli-reference/#serv-config-get","title":"<code>serv config get</code>","text":"<p>Get specific configuration values using dot notation.</p> <p>Usage: <pre><code>serv config get &lt;key&gt;\n</code></pre></p> <p>Examples:</p> <pre><code># Get site name\nserv config get site_info.name\n\n# Get first extension\nserv config get extensions.0.extension\n\n# Get nested values\nserv config get database.connection.host\n</code></pre> <p>Example output: <pre><code>\ud83d\udd11 site_info.name: My Awesome Website\n</code></pre></p>"},{"location":"cli-reference/#serv-config-set","title":"<code>serv config set</code>","text":"<p>Set configuration values with automatic type conversion.</p> <p>Usage: <pre><code>serv config set &lt;key&gt; &lt;value&gt; [--type TYPE]\n</code></pre></p> <p>Options: - <code>--type</code>: Value type (string, int, float, bool, list)</p> <p>Examples:</p> <pre><code># Set string value (default)\nserv config set site_info.name \"New Site Name\"\n\n# Set integer value\nserv config set server.port 3000 --type int\n\n# Set boolean value\nserv config set debug.enabled true --type bool\n\n# Set list value\nserv config set allowed_hosts \"localhost,127.0.0.1,example.com\" --type list\n\n# Set nested configuration\nserv config set database.connection.timeout 30 --type int\n</code></pre>"},{"location":"cli-reference/#extension-management","title":"Extension Management","text":""},{"location":"cli-reference/#serv-extension-list","title":"<code>serv extension list</code>","text":"<p>List available and enabled extensions.</p> <p>Usage: <pre><code>serv extension list [--available]\n</code></pre></p> <p>Options: - <code>--available</code>: Show all available extensions (default shows enabled)</p> <p>Examples:</p> <pre><code># List enabled extensions\nserv extension list\n\n# List all available extensions\nserv extension list --available\n</code></pre> <p>Example output: <pre><code>Enabled extensions (2):\n  \u2022 User Management (v1.0.0) [user_management]\n  \u2022 API Router (v2.1.0) [api_router] (with config)\n\nAvailable extensions (4):\n  \u2022 User Management (v1.0.0) [user_management]\n    User authentication and management system\n  \u2022 API Router (v2.1.0) [api_router]\n    RESTful API routing and middleware\n  \u2022 Blog Engine (v1.5.0) [blog_engine]\n    Simple blog functionality\n  \u2022 Admin Panel (v0.9.0) [admin_panel]\n    Administrative interface\n</code></pre></p>"},{"location":"cli-reference/#serv-extension-enable","title":"<code>serv extension enable</code>","text":"<p>Enable a extension in your application.</p> <p>Usage: <pre><code>serv extension enable &lt;extension_identifier&gt;\n</code></pre></p> <p>Examples:</p> <pre><code># Enable by directory name\nserv extension enable user_management\n\n# Enable extension with different name\nserv extension enable blog_engine\n</code></pre> <p>Example output: <pre><code>Extension 'user_management' enabled successfully.\nHuman name: User Management\n</code></pre></p>"},{"location":"cli-reference/#serv-extension-disable","title":"<code>serv extension disable</code>","text":"<p>Disable a extension in your application.</p> <p>Usage: <pre><code>serv extension disable &lt;extension_identifier&gt;\n</code></pre></p> <p>Examples:</p> <pre><code># Disable by directory name\nserv extension disable user_management\n\n# Disable extension with different name\nserv extension disable blog_engine\n</code></pre>"},{"location":"cli-reference/#serv-extension-validate","title":"<code>serv extension validate</code>","text":"<p>Validate extension structure and configuration.</p> <p>Usage: <pre><code>serv extension validate [extension_identifier] [--all]\n</code></pre></p> <p>Options: - <code>--all</code>: Validate all extensions</p> <p>Examples:</p> <pre><code># Validate all extensions\nserv extension validate\n\n# Validate specific extension\nserv extension validate user_management\n\n# Explicitly validate all\nserv extension validate --all\n</code></pre> <p>Example output: <pre><code>=== Validating 2 Extension(s) ===\n\n\ud83d\udd0d Validating extension: user_management\n\u2705 extension.yaml is valid YAML\n\u2705 Has required field: name\n\u2705 Has required field: version\n\u2705 Has recommended field: description\n\u2705 Has recommended field: author\n\u2705 Has __init__.py\n\u2705 Found 3 Python file(s)\n\u2705 Has main extension file: user_management.py\n\u2705 user_management.py has valid Python syntax\n\ud83c\udf89 Extension 'user_management' validation passed!\n\n=== Validation Summary ===\n\ud83c\udf89 All extensions passed validation!\n</code></pre></p>"},{"location":"cli-reference/#project-and-extension-development","title":"Project and Extension Development","text":""},{"location":"cli-reference/#serv-create-app","title":"<code>serv create app</code>","text":"<p>Initialize a new Serv project with configuration files.</p> <p>Usage: <pre><code>serv create app [--force] [--non-interactive]\n</code></pre></p> <p>Options: - <code>--force</code>: Overwrite existing configuration files - <code>--non-interactive</code>: Use default values without prompts</p> <p>Examples:</p> <pre><code># Interactive initialization\nserv create app\n\n# Force overwrite existing config\nserv create app --force\n\n# Non-interactive with defaults (useful for scripts)\nserv create app --non-interactive --force\n</code></pre> <p>Interactive prompts: <pre><code>Enter site name [My Serv Site]: My Awesome Website\nEnter site description [A new website powered by Serv]: A modern web application\n</code></pre></p> <p>Generated files: - <code>serv.config.yaml</code> - Main configuration file</p>"},{"location":"cli-reference/#serv-create-extension","title":"<code>serv create extension</code>","text":"<p>Create a new extension with proper structure.</p> <p>Usage: <pre><code>serv create extension --name NAME [--force] [--non-interactive]\n</code></pre></p> <p>Options: - <code>--name</code>: Name of the extension (required) - <code>--force</code>: Overwrite existing extension - <code>--non-interactive</code>: Use default values</p> <p>Examples:</p> <pre><code># Interactive extension creation\nserv create extension --name \"User Authentication\"\n\n# Non-interactive with defaults\nserv create extension --name \"Blog Engine\" --non-interactive\n\n# Force overwrite existing\nserv create extension --name \"API Router\" --force\n</code></pre> <p>Interactive prompts: <pre><code>Author [Your Name]: John Doe\nDescription [A cool Serv extension.]: User authentication and management\nVersion [0.1.0]: 1.0.0\n</code></pre></p> <p>Generated structure: <pre><code>extensions/\n\u2514\u2500\u2500 user_authentication/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 extension.yaml\n    \u2514\u2500\u2500 user_authentication.py\n</code></pre></p>"},{"location":"cli-reference/#serv-create-route","title":"<code>serv create route</code>","text":"<p>Create a new route handler in a extension.</p> <p>Usage: <pre><code>serv create route --name NAME [--path PATH] [--router ROUTER] [--extension PLUGIN] [--force]\n</code></pre></p> <p>Options: - <code>--name</code>: Name of the route (required) - <code>--path</code>: URL path for the route - <code>--router</code>: Router name to add the route to - <code>--extension</code>: Extension to add the route to (auto-detected if not provided) - <code>--force</code>: Overwrite existing files</p> <p>Examples:</p> <pre><code># Basic route creation (interactive)\nserv create route --name user_profile\n\n# Specify everything explicitly\nserv create route --name user_profile \\\n  --path \"/users/{id}/profile\" \\\n  --router api_router \\\n  --extension user_management\n\n# Create API endpoint\nserv create route --name create_post \\\n  --path \"/api/v1/posts\" \\\n  --router api_router\n\n# Admin route\nserv create route --name admin_dashboard \\\n  --path \"/admin/dashboard\" \\\n  --router admin_router\n</code></pre> <p>Interactive prompts: <pre><code>Route path [/user_profile]: /users/{id}/profile\nExisting routers:\n  1. api_router\n  2. admin_router\n  3. Create new router\nSelect router (name or number) [1]: 1\n</code></pre></p> <p>Generated extension.yaml update: <pre><code>routers:\n- name: api_router\n  routes:\n  - path: /users/{id}/profile\n    handler: route_user_profile:UserProfile\n</code></pre></p>"},{"location":"cli-reference/#serv-create-listener","title":"<code>serv create listener</code>","text":"<p>Create a new extension listener class.</p> <p>Usage: <pre><code>serv create listener --name NAME [--extension PLUGIN] [--force]\n</code></pre></p> <p>Examples:</p> <pre><code># Create listener\nserv create listener --name admin_auth --extension user_management\n\n# Auto-detect extension\nserv create listener --name email_sender\n\n# Force overwrite existing\nserv create listener --name event_handler --force\n</code></pre>"},{"location":"cli-reference/#serv-create-middleware","title":"<code>serv create middleware</code>","text":"<p>Create a new middleware component.</p> <p>Usage: <pre><code>serv create middleware --name NAME [--extension PLUGIN] [--force]\n</code></pre></p> <p>Examples:</p> <pre><code># Create middleware\nserv create middleware --name auth_check --extension user_management\n\n# Rate limiting middleware\nserv create middleware --name rate_limiter --extension security\n</code></pre>"},{"location":"cli-reference/#advanced-usage-patterns","title":"Advanced Usage Patterns","text":""},{"location":"cli-reference/#multi-environment-configuration","title":"Multi-Environment Configuration","text":"<pre><code># Development\nserv -c config/dev.yaml dev\n\n# Staging\nserv -c config/staging.yaml launch --host 0.0.0.0\n\n# Production\nserv -c config/prod.yaml launch --workers 4 --host 0.0.0.0\n</code></pre>"},{"location":"cli-reference/#custom-application-classes","title":"Custom Application Classes","text":"<pre><code># Use custom app class\nserv -a myproject.app:CustomApp launch\n\n# With custom config\nserv -a myproject.app:CustomApp -c custom.yaml dev\n</code></pre>"},{"location":"cli-reference/#extension-development-workflow","title":"Extension Development Workflow","text":"<pre><code># 1. Create new project (if needed)\nserv create app\n\n# 2. Create extension\nserv create extension --name \"My Feature\"\n\n# 3. Add listeners\nserv create listener --name feature_handler\n\n# 4. Add routes\nserv create route --name feature_api --path \"/api/feature\" --router api_router\n\n# 5. Add middleware\nserv create middleware --name feature_auth\n\n# 6. Validate extension\nserv extension validate my_feature\n\n# 7. Enable extension\nserv extension enable my_feature\n\n# 8. Test\nserv test --extensions\n\n# 9. Start development server\nserv --dev launch\n</code></pre>"},{"location":"cli-reference/#testing-workflow","title":"Testing Workflow","text":"<pre><code># Run tests during development\nserv test --verbose\n\n# Check coverage\nserv test --coverage\n\n# Test specific components\nserv test tests/test_auth.py --verbose\n\n# Run e2e tests before deployment\nserv test --e2e\n</code></pre>"},{"location":"cli-reference/#configuration-management_1","title":"Configuration Management","text":"<pre><code># Check current config\nserv config show\n\n# Validate before deployment\nserv config validate\n\n# Update settings\nserv config set debug.enabled false --type bool\nserv config set server.workers 4 --type int\n\n# Verify changes\nserv config get debug.enabled\nserv config get server.workers\n</code></pre>"},{"location":"cli-reference/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli-reference/#common-issues","title":"Common Issues","text":"<p>Configuration not found: <pre><code># Check if config exists\nserv config validate\n\n# Create new config\nserv create app\n</code></pre></p> <p>Extension not loading: <pre><code># Validate extension structure\nserv extension validate my_extension\n\n# Check if extension is enabled\nserv extension list\n\n# Enable extension\nserv extension enable my_extension\n</code></pre></p> <p>Application health check: <pre><code># Check configuration\nserv config validate\n\n# Check extensions\nserv extension validate\n\n# Check if app can be loaded\nserv launch --dry-run\n</code></pre></p>"},{"location":"cli-reference/#debug-mode","title":"Debug Mode","text":"<p>Enable debug logging for detailed information:</p> <pre><code>serv --debug launch\nserv --debug config validate\nserv --debug extension validate\n</code></pre>"},{"location":"cli-reference/#getting-help","title":"Getting Help","text":"<pre><code># General help\nserv --help\n\n# Command-specific help\nserv --dev launch --help\nserv create route --help\nserv config set --help\n</code></pre>"},{"location":"cli-reference/#environment-variables","title":"Environment Variables","text":"<p>Serv CLI respects these environment variables:</p> Variable Description Default <code>SERV_CONFIG</code> Default config file path <code>serv.config.yaml</code> <code>SERV_PLUGIN_DIRS</code> Default extension directories <code>./extensions</code> <code>SERV_DEBUG</code> Enable debug mode <code>false</code> <p>Example: <pre><code>export SERV_CONFIG=config/production.yaml\nexport SERV_DEBUG=true\nserv launch\n</code></pre></p>"},{"location":"cli-reference/#integration-with-cicd","title":"Integration with CI/CD","text":""},{"location":"cli-reference/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Serv Application CI\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.9\n\n    - name: Install dependencies\n      run: |\n        pip install serv\n        pip install -r requirements.txt\n\n    - name: Validate configuration\n      run: serv config validate\n\n    - name: Check application health\n      run: serv app check\n\n    - name: Validate extensions\n      run: serv extension validate\n\n    - name: Run tests with coverage\n      run: serv test --coverage\n\n    - name: Test application startup\n      run: serv launch --dry-run\n</code></pre>"},{"location":"cli-reference/#docker-integration","title":"Docker Integration","text":"<pre><code>FROM python:3.9-slim\n\nWORKDIR /app\nCOPY . .\n\nRUN pip install serv\nRUN pip install -r requirements.txt\n\n# Validate configuration during build\nRUN serv config validate\nRUN serv app check\n\nEXPOSE 8000\nCMD [\"serv\", \"launch\", \"--host\", \"0.0.0.0\", \"--workers\", \"4\"]\n</code></pre> <p>This comprehensive CLI reference provides everything you need to effectively use Serv's command-line interface for development, testing, and deployment of your web applications. </p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Serv uses a flexible configuration system based on YAML files. This guide covers how to configure your Serv applications effectively.</p>"},{"location":"getting-started/configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"getting-started/configuration/#main-configuration-file","title":"Main Configuration File","text":"<p>The main configuration file is typically named <code>serv.config.yaml</code> and placed in your project root:</p> <pre><code># serv.config.yaml\nextensions:\n  - extension: auth\n    settings:\n      secret_key: \"your-secret-key-here\"\n      token_expiry: 3600\n  - extension: blog\n    settings:\n      posts_per_page: 10\n      allow_comments: true\n  - entry: external_package.extension:ExternalExtension\n    config:\n      api_url: \"https://api.example.com\"\n\nmiddleware:\n  - entry: my_middleware:LoggingMiddleware\n    config:\n      log_level: \"INFO\"\n\nsettings:\n  debug: false\n  host: \"0.0.0.0\"\n  port: 8000\n</code></pre>"},{"location":"getting-started/configuration/#loading-configuration","title":"Loading Configuration","text":"<p>Load configuration when creating your app:</p> <pre><code>from serv import App\n\n# Load from default location (./serv.config.yaml)\napp = App()\n\n# Load from custom location\napp = App(config=\"./config/production.yaml\")\n\n# Load from multiple files (later files override earlier ones)\napp = App(config=[\"./base.yaml\", \"./environment.yaml\"])\n</code></pre>"},{"location":"getting-started/configuration/#extension-configuration","title":"Extension Configuration","text":""},{"location":"getting-started/configuration/#extension-settings","title":"Extension Settings","text":"<p>Configure extensions in the <code>extensions</code> section:</p> <pre><code>extensions:\n  - extension: auth  # Extension directory name\n    settings:\n      secret_key: \"super-secret-key\"\n      algorithm: \"HS256\"\n      token_expiry: 86400  # 24 hours\n\n  - extension: database\n    settings:\n      url: \"postgresql://user:pass@localhost/db\"\n      pool_size: 10\n      echo: false\n</code></pre>"},{"location":"getting-started/configuration/#external-extension-configuration","title":"External Extension Configuration","text":"<p>Load extensions from external packages:</p> <pre><code>extensions:\n  - entry: \"my_package.auth:AuthExtension\"\n    config:\n      provider: \"oauth2\"\n      client_id: \"your-client-id\"\n\n  - entry: \"third_party_extension:MainExtension\"\n    config:\n      api_key: \"your-api-key\"\n</code></pre>"},{"location":"getting-started/configuration/#extension-specific-configuration-files","title":"Extension-Specific Configuration Files","text":"<p>Extensions can have their own <code>extension.yaml</code> files with default settings:</p> <pre><code># extensions/auth/extension.yaml\nname: Authentication Extension\ndescription: Provides user authentication\nversion: 1.0.0\nauthor: Your Name\nentry: auth.main:AuthExtension\n\nsettings:\n  secret_key: \"default-secret\"\n  algorithm: \"HS256\"\n  token_expiry: 3600\n  require_email_verification: true\n</code></pre> <p>Application configuration can override these defaults:</p> <pre><code># serv.config.yaml\nextensions:\n  - extension: auth\n    settings:\n      secret_key: \"production-secret\"  # Overrides default\n      token_expiry: 7200               # Overrides default\n      # require_email_verification uses default (true)\n</code></pre>"},{"location":"getting-started/configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>Use environment variables for sensitive or environment-specific settings:</p> <pre><code># serv.config.yaml\nextensions:\n  - extension: database\n    settings:\n      url: ${DATABASE_URL}\n\n  - extension: auth\n    settings:\n      secret_key: ${JWT_SECRET_KEY}\n\nsettings:\n  debug: ${DEBUG:false}  # Default to false if not set\n  port: ${PORT:8000}     # Default to 8000 if not set\n</code></pre>"},{"location":"getting-started/configuration/#multiple-configuration-files","title":"Multiple Configuration Files","text":"<p>Organize configuration by environment:</p> <pre><code># base.yaml - Common settings\nextensions:\n  - extension: auth\n    settings:\n      algorithm: \"HS256\"\n      token_expiry: 3600\n\nsettings:\n  host: \"0.0.0.0\"\n</code></pre> <pre><code># development.yaml - Development overrides\nextensions:\n  - extension: auth\n    settings:\n      secret_key: \"dev-secret\"\n\nsettings:\n  debug: true\n  port: 8000\n</code></pre> <pre><code># production.yaml - Production overrides\nextensions:\n  - extension: auth\n    settings:\n      secret_key: ${JWT_SECRET_KEY}\n\nsettings:\n  debug: false\n  port: ${PORT:80}\n</code></pre> <p>Load configuration based on environment:</p> <pre><code>import os\nfrom serv import App\n\nenv = os.getenv(\"ENVIRONMENT\", \"development\")\nconfig_files = [\"base.yaml\", f\"{env}.yaml\"]\n\napp = App(config=config_files)\n</code></pre>"},{"location":"getting-started/configuration/#application-settings","title":"Application Settings","text":""},{"location":"getting-started/configuration/#core-settings","title":"Core Settings","text":"<p>Configure core application behavior:</p> <pre><code>settings:\n  # Server settings\n  host: \"0.0.0.0\"\n  port: 8000\n\n  # Development settings\n  debug: true\n  reload: true\n\n  # Security settings\n  allowed_hosts: [\"localhost\", \"127.0.0.1\", \"myapp.com\"]\n  cors_origins: [\"http://localhost:3000\"]\n\n  # Logging settings\n  log_level: \"INFO\"\n  log_format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n</code></pre>"},{"location":"getting-started/configuration/#custom-settings","title":"Custom Settings","text":"<p>Add your own application-wide settings:</p> <pre><code>settings:\n  # Custom application settings\n  app_name: \"My Awesome App\"\n  version: \"1.0.0\"\n  max_upload_size: 10485760  # 10MB\n  cache_timeout: 300\n\n  # Feature flags\n  features:\n    user_registration: true\n    email_notifications: false\n    analytics: true\n</code></pre> <p>Access custom settings in your code:</p> <pre><code>from serv.config import get_config\n\nconfig = get_config()\napp_name = config.get('app_name', 'Default App')\nmax_upload = config.get('max_upload_size', 1048576)\n</code></pre>"},{"location":"getting-started/configuration/#middleware-configuration","title":"Middleware Configuration","text":""},{"location":"getting-started/configuration/#global-middleware","title":"Global Middleware","text":"<p>Configure middleware that applies to all requests:</p> <pre><code>middleware:\n  - entry: \"serv.middleware.cors:CORSMiddleware\"\n    config:\n      allow_origins: [\"*\"]\n      allow_methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n      allow_headers: [\"*\"]\n\n  - entry: \"my_middleware:LoggingMiddleware\"\n    config:\n      log_requests: true\n      log_responses: false\n\n  - entry: \"my_middleware:RateLimitMiddleware\"\n    config:\n      requests_per_minute: 60\n      burst_size: 10\n</code></pre>"},{"location":"getting-started/configuration/#extension-provided-middleware","title":"Extension-Provided Middleware","text":"<p>Extensions can register their own middleware:</p> <pre><code># In extension.yaml\nmiddleware:\n  - entry: \"auth.middleware:AuthMiddleware\"\n    config:\n      exempt_paths: [\"/health\", \"/metrics\"]\n\n  - entry: \"auth.middleware:SessionMiddleware\"\n    config:\n      session_timeout: 1800\n</code></pre>"},{"location":"getting-started/configuration/#configuration-validation","title":"Configuration Validation","text":""},{"location":"getting-started/configuration/#schema-validation","title":"Schema Validation","text":"<p>Define schemas to validate your configuration:</p> <pre><code>from serv.config import ConfigSchema\nfrom typing import Optional\n\nclass AuthExtensionConfig(ConfigSchema):\n    secret_key: str\n    algorithm: str = \"HS256\"\n    token_expiry: int = 3600\n    require_email_verification: bool = True\n\nclass AuthExtension(Extension):\n    def __init__(self):\n        # Validate configuration against schema\n        self.config = AuthExtensionConfig.from_config(self.get_config())\n\n    async def on_app_startup(self):\n        print(f\"Auth extension starting with algorithm: {self.config.algorithm}\")\n</code></pre>"},{"location":"getting-started/configuration/#required-settings","title":"Required Settings","text":"<p>Mark settings as required:</p> <pre><code># extension.yaml\nsettings:\n  secret_key: !required  # Must be provided\n  algorithm: \"HS256\"     # Has default\n  token_expiry: 3600     # Has default\n</code></pre>"},{"location":"getting-started/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"getting-started/configuration/#1-use-environment-variables-for-secrets","title":"1. Use Environment Variables for Secrets","text":"<p>Never commit secrets to version control:</p> <pre><code># Good\nextensions:\n  - extension: auth\n    settings:\n      secret_key: ${JWT_SECRET_KEY}\n\n# Bad - secret in config file\nextensions:\n  - extension: auth\n    settings:\n      secret_key: \"super-secret-key-123\"\n</code></pre>"},{"location":"getting-started/configuration/#2-provide-sensible-defaults","title":"2. Provide Sensible Defaults","text":"<p>Make your extensions work out of the box:</p> <pre><code># extension.yaml\nsettings:\n  debug: false\n  timeout: 30\n  retries: 3\n  cache_enabled: true\n</code></pre>"},{"location":"getting-started/configuration/#3-document-configuration-options","title":"3. Document Configuration Options","text":"<p>Document all configuration options:</p> <pre><code># extension.yaml\nname: My Extension\ndescription: Does awesome things\n\nsettings:\n  # Required: API key for external service\n  api_key: !required\n\n  # Optional: Request timeout in seconds (default: 30)\n  timeout: 30\n\n  # Optional: Number of retries on failure (default: 3)\n  retries: 3\n\n  # Optional: Enable caching (default: true)\n  cache_enabled: true\n</code></pre>"},{"location":"getting-started/configuration/#4-validate-configuration-early","title":"4. Validate Configuration Early","text":"<p>Validate configuration at startup:</p> <pre><code>class MyExtension(Extension):\n    def __init__(self):\n        config = self.get_config()\n\n        # Validate required settings\n        if not config.get('api_key'):\n            raise ValueError(\"api_key is required\")\n\n        # Validate setting types and ranges\n        timeout = config.get('timeout', 30)\n        if not isinstance(timeout, int) or timeout &lt;= 0:\n            raise ValueError(\"timeout must be a positive integer\")\n\n        self.api_key = config['api_key']\n        self.timeout = timeout\n</code></pre>"},{"location":"getting-started/configuration/#5-use-configuration-layers","title":"5. Use Configuration Layers","text":"<p>Organize configuration in layers:</p> <ol> <li>Extension defaults (in <code>extension.yaml</code>)</li> <li>Application config (in <code>serv.config.yaml</code>)</li> <li>Environment variables (for deployment-specific values)</li> <li>Command-line arguments (for runtime overrides)</li> </ol> <pre><code># Example of configuration precedence\nimport os\nfrom serv import App\n\n# 1. Start with extension defaults\n# 2. Override with application config\napp = App(config=\"serv.config.yaml\")\n\n# 3. Override with environment variables (handled automatically)\n# 4. Override with command-line arguments\nif os.getenv(\"DEBUG\"):\n    app.config['debug'] = True\n</code></pre>"},{"location":"getting-started/configuration/#dynamic-configuration","title":"Dynamic Configuration","text":""},{"location":"getting-started/configuration/#runtime-configuration-changes","title":"Runtime Configuration Changes","text":"<p>Some settings can be changed at runtime:</p> <pre><code>class ConfigurableExtension(Extension):\n    def __init__(self):\n        self.config = self.get_config()\n        self.debug = self.config.get('debug', False)\n\n    async def on_app_request_begin(self, router: Router = dependency()):\n        # Add debug routes only if debug is enabled\n        if self.debug:\n            router.add_route(\"/debug/config\", self.show_config)\n\n    async def show_config(self, response: ResponseBuilder = dependency()):\n        response.content_type(\"application/json\")\n        response.body(json.dumps(self.config, indent=2))\n\n    def update_config(self, new_config: dict):\n        \"\"\"Update configuration at runtime\"\"\"\n        self.config.update(new_config)\n        self.debug = self.config.get('debug', False)\n</code></pre>"},{"location":"getting-started/configuration/#configuration-reloading","title":"Configuration Reloading","text":"<p>Implement configuration reloading for development:</p> <pre><code>import asyncio\nfrom watchdog.observers import Observer\nfrom watchdog.events import FileSystemEventHandler\n\nclass ConfigReloader(FileSystemEventHandler):\n    def __init__(self, app: App):\n        self.app = app\n\n    def on_modified(self, event):\n        if event.src_path.endswith('.yaml'):\n            print(\"Configuration changed, reloading...\")\n            self.app.reload_config()\n\n# In development mode\nif app.config.get('debug'):\n    observer = Observer()\n    observer.schedule(ConfigReloader(app), path='.', recursive=False)\n    observer.start()\n</code></pre>"},{"location":"getting-started/configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"getting-started/configuration/#complete-application-configuration","title":"Complete Application Configuration","text":"<pre><code># serv.config.yaml\nsettings:\n  app_name: \"My Blog App\"\n  debug: ${DEBUG:false}\n  host: ${HOST:0.0.0.0}\n  port: ${PORT:8000}\n\n  # Database settings\n  database_url: ${DATABASE_URL:sqlite:///app.db}\n\n  # Security settings\n  secret_key: ${SECRET_KEY}\n  allowed_hosts: \n    - \"localhost\"\n    - \"127.0.0.1\"\n    - ${DOMAIN:myapp.com}\n\n  # Feature flags\n  features:\n    user_registration: true\n    email_verification: ${EMAIL_VERIFICATION:false}\n    analytics: ${ANALYTICS:false}\n\nextensions:\n  - extension: auth\n    settings:\n      secret_key: ${JWT_SECRET_KEY}\n      token_expiry: ${TOKEN_EXPIRY:3600}\n\n  - extension: blog\n    settings:\n      posts_per_page: ${POSTS_PER_PAGE:10}\n      allow_comments: ${ALLOW_COMMENTS:true}\n\n  - extension: email\n    settings:\n      smtp_host: ${SMTP_HOST:localhost}\n      smtp_port: ${SMTP_PORT:587}\n      smtp_user: ${SMTP_USER}\n      smtp_password: ${SMTP_PASSWORD}\n\nmiddleware:\n  - entry: \"serv.middleware.cors:CORSMiddleware\"\n    config:\n      allow_origins: ${CORS_ORIGINS:[\"http://localhost:3000\"]}\n\n  - entry: \"my_middleware:RateLimitMiddleware\"\n    config:\n      requests_per_minute: ${RATE_LIMIT:60}\n</code></pre>"},{"location":"getting-started/configuration/#extension-configuration-template","title":"Extension Configuration Template","text":"<pre><code># extensions/my_extension/extension.yaml\nname: My Extension\ndescription: A sample extension demonstrating configuration\nversion: 1.0.0\nauthor: Your Name\nentry: my_extension.main:MyExtension\n\n# Default settings (can be overridden in serv.config.yaml)\nsettings:\n  # Required settings (must be provided by user)\n  api_key: !required\n\n  # Optional settings with defaults\n  timeout: 30\n  retries: 3\n  debug: false\n\n  # Complex settings\n  cache:\n    enabled: true\n    ttl: 300\n    max_size: 1000\n\n  # List settings\n  allowed_ips:\n    - \"127.0.0.1\"\n    - \"::1\"\n\n# Additional entry points\nentry_points:\n  - entry: my_extension.admin:AdminExtension\n    config:\n      admin_path: \"/admin\"\n\n# Middleware provided by this extension\nmiddleware:\n  - entry: my_extension.middleware:SecurityMiddleware\n    config:\n      check_csrf: true\n      check_origin: true\n</code></pre>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Extensions - Learn how to create and configure extensions</li> <li>Middleware - Understand middleware configuration</li> <li>Deployment - Configure for production deployment</li> <li>Testing - Test your configuration </li> </ul>"},{"location":"getting-started/first-app/","title":"Your First App","text":"<p>In this tutorial, we'll build a complete blog application using Serv. You'll learn about routing, templates, forms, extensions, and more!</p>"},{"location":"getting-started/first-app/#what-well-build","title":"What We'll Build","text":"<p>We're going to create a simple blog with the following features:</p> <ul> <li>Homepage listing all blog posts</li> <li>Individual post pages</li> <li>Admin interface to create new posts</li> <li>Form handling and validation</li> <li>Template rendering with Jinja2</li> <li>Extension-based architecture</li> </ul>"},{"location":"getting-started/first-app/#project-setup","title":"Project Setup","text":""},{"location":"getting-started/first-app/#1-create-the-project-structure","title":"1. Create the Project Structure","text":"<p>First, let's create our project directory:</p> <pre><code>mkdir serv-blog\ncd serv-blog\n</code></pre> <p>Create the following directory structure:</p> <pre><code>serv-blog/\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 serv.config.yaml\n\u251c\u2500\u2500 templates/\n\u2502   \u251c\u2500\u2500 base.html\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u251c\u2500\u2500 post.html\n\u2502   \u2514\u2500\u2500 admin/\n\u2502       \u2514\u2500\u2500 create_post.html\n\u2514\u2500\u2500 extensions/\n    \u2514\u2500\u2500 blog/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 main.py\n        \u251c\u2500\u2500 models.py\n        \u2514\u2500\u2500 extension.yaml\n</code></pre>"},{"location":"getting-started/first-app/#2-install-dependencies","title":"2. Install Dependencies","text":"<pre><code>pip install getserving uvicorn\n</code></pre>"},{"location":"getting-started/first-app/#building-the-application","title":"Building the Application","text":""},{"location":"getting-started/first-app/#1-create-the-data-models","title":"1. Create the Data Models","text":"<p>First, let's create simple data models for our blog posts. Create <code>extensions/blog/models.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import List\n\n@dataclass\nclass BlogPost:\n    id: int\n    title: str\n    content: str\n    author: str\n    created_at: datetime\n\n    def __post_init__(self):\n        if isinstance(self.created_at, str):\n            self.created_at = datetime.fromisoformat(self.created_at)\n\nclass BlogStorage:\n    \"\"\"Simple in-memory storage for blog posts\"\"\"\n\n    def __init__(self):\n        self.posts: List[BlogPost] = []\n        self.next_id = 1\n\n        # Add some sample data\n        self.add_post(\"Welcome to Serv Blog\", \n                     \"This is your first blog post using Serv!\", \n                     \"Admin\")\n        self.add_post(\"Getting Started\", \n                     \"Learn how to build amazing web apps with Serv.\", \n                     \"Admin\")\n\n    def add_post(self, title: str, content: str, author: str) -&gt; BlogPost:\n        post = BlogPost(\n            id=self.next_id,\n            title=title,\n            content=content,\n            author=author,\n            created_at=datetime.now()\n        )\n        self.posts.append(post)\n        self.next_id += 1\n        return post\n\n    def get_all_posts(self) -&gt; List[BlogPost]:\n        return sorted(self.posts, key=lambda p: p.created_at, reverse=True)\n\n    def get_post_by_id(self, post_id: int) -&gt; BlogPost | None:\n        for post in self.posts:\n            if post.id == post_id:\n                return post\n        return None\n</code></pre>"},{"location":"getting-started/first-app/#2-create-the-blog-extension","title":"2. Create the Blog Extension","text":"<p>Now let's create the main blog extension. Create <code>extensions/blog/main.py</code>:</p> <pre><code>from typing import Annotated\nfrom serv.extensions import Extension\nfrom serv.extensions.routing import Router\nfrom serv.requests import GetRequest, PostRequest\nfrom serv.responses import HtmlResponse, JsonResponse\nfrom serv.routes import Route, Form, handles\nfrom bevy import dependency\nimport json\n\nfrom .models import BlogStorage, BlogPost\n\nclass BlogExtension(Extension):\n    def __init__(self):\n        self.storage = BlogStorage()\n\n    async def on_app_startup(self):\n        \"\"\"Initialize the blog extension\"\"\"\n        print(\"Blog extension started!\")\n\n    async def on_app_request_begin(self, router: Router = dependency()):\n        \"\"\"Register routes for each request\"\"\"\n        # Register our route handlers\n        router.add_route(\"/\", BlogHomeRoute(self.storage))\n        router.add_route(\"/post/{post_id}\", BlogPostRoute(self.storage))\n        router.add_route(\"/admin\", AdminRoute(self.storage))\n        router.add_route(\"/api/posts\", BlogApiRoute(self.storage))\n\n\nclass BlogHomeRoute(Route):\n    \"\"\"Route for the blog homepage\"\"\"\n    def __init__(self, storage: BlogStorage):\n        self.storage = storage\n\n    @handles.GET\n    async def homepage(self, request: GetRequest) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Homepage showing all blog posts\"\"\"\n        posts = self.storage.get_all_posts()\n\n        html = self._render_template(\"index.html\", {\n            \"title\": \"Serv Blog\",\n            \"posts\": posts\n        })\n        return html\n\n    def _render_template(self, template_name: str, context: dict) -&gt; str:\n        \"\"\"Simple template rendering for homepage\"\"\"\n        if template_name == \"index.html\":\n            posts_html = \"\"\n            for post in context[\"posts\"]:\n                posts_html += f\"\"\"\n                &lt;article class=\"post-preview\"&gt;\n                    &lt;h2&gt;&lt;a href=\"/post/{post.id}\"&gt;{post.title}&lt;/a&gt;&lt;/h2&gt;\n                    &lt;p class=\"meta\"&gt;By {post.author} on {post.created_at.strftime('%B %d, %Y')}&lt;/p&gt;\n                    &lt;p&gt;{post.content[:200]}...&lt;/p&gt;\n                &lt;/article&gt;\n                \"\"\"\n\n            return f\"\"\"\n            &lt;!DOCTYPE html&gt;\n            &lt;html&gt;\n            &lt;head&gt;\n                &lt;title&gt;{context['title']}&lt;/title&gt;\n                &lt;style&gt;\n                    body {{ font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }}\n                    .post-preview {{ border-bottom: 1px solid #eee; padding: 20px 0; }}\n                    .meta {{ color: #666; font-size: 0.9em; }}\n                    a {{ color: #007bff; text-decoration: none; }}\n                    a:hover {{ text-decoration: underline; }}\n                    .nav {{ margin-bottom: 30px; }}\n                &lt;/style&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;nav class=\"nav\"&gt;\n                    &lt;a href=\"/\"&gt;Home&lt;/a&gt; | \n                    &lt;a href=\"/admin\"&gt;Admin&lt;/a&gt; | \n                    &lt;a href=\"/api/posts\"&gt;API&lt;/a&gt;\n                &lt;/nav&gt;\n                &lt;h1&gt;{context['title']}&lt;/h1&gt;\n                {posts_html}\n            &lt;/body&gt;\n            &lt;/html&gt;\n            \"\"\"\n        return \"&lt;h1&gt;Template not found&lt;/h1&gt;\"\n\nclass BlogPostRoute(Route):\n    \"\"\"Route for individual blog posts\"\"\"\n    def __init__(self, storage: BlogStorage):\n        self.storage = storage\n\n    @handles.GET\n    async def view_post(self, post_id: str, request: GetRequest) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"View a single blog post\"\"\"\n        try:\n            post_id_int = int(post_id)\n            post = self.storage.get_post_by_id(post_id_int)\n\n            if not post:\n                return \"&lt;h1&gt;Post Not Found&lt;/h1&gt;\"\n\n            return f\"\"\"\n            &lt;!DOCTYPE html&gt;\n            &lt;html&gt;\n            &lt;head&gt;\n                &lt;title&gt;{post.title}&lt;/title&gt;\n                &lt;style&gt;\n                    body {{ font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }}\n                    .meta {{ color: #666; font-size: 0.9em; margin-bottom: 20px; }}\n                    .content {{ line-height: 1.6; }}\n                    a {{ color: #007bff; text-decoration: none; }}\n                    a:hover {{ text-decoration: underline; }}\n                    .nav {{ margin-bottom: 30px; }}\n                &lt;/style&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;nav class=\"nav\"&gt;\n                    &lt;a href=\"/\"&gt;\u2190 Back to Home&lt;/a&gt;\n                &lt;/nav&gt;\n                &lt;article&gt;\n                    &lt;h1&gt;{post.title}&lt;/h1&gt;\n                    &lt;p class=\"meta\"&gt;By {post.author} on {post.created_at.strftime('%B %d, %Y')}&lt;/p&gt;\n                    &lt;div class=\"content\"&gt;\n                        {post.content.replace(chr(10), '&lt;br&gt;')}\n                    &lt;/div&gt;\n                &lt;/article&gt;\n            &lt;/body&gt;\n            &lt;/html&gt;\n            \"\"\"\n\n        except ValueError:\n            return \"&lt;h1&gt;Invalid Post ID&lt;/h1&gt;\"\n\nclass BlogApiRoute(Route):\n    \"\"\"API route for blog posts\"\"\"\n    def __init__(self, storage: BlogStorage):\n        self.storage = storage\n\n    @handles.GET\n    async def api_posts(self, request: GetRequest) -&gt; Annotated[list[dict], JsonResponse]:\n        \"\"\"API endpoint returning posts as JSON\"\"\"\n        posts = self.storage.get_all_posts()\n        return [\n            {\n                \"id\": post.id,\n                \"title\": post.title,\n                \"content\": post.content,\n                \"author\": post.author,\n                \"created_at\": post.created_at.isoformat()\n            }\n            for post in posts\n        ]\n\nclass CreatePostForm(Form):\n    title: str\n    content: str\n    author: str\n\nclass AdminRoute(Route):\n    def __init__(self, storage: BlogStorage):\n        self.storage = storage\n\n    @handles.GET\n    async def show_admin_page(self, request: GetRequest) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Show the admin page with create post form\"\"\"\n        html = \"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;Admin - Create Post&lt;/title&gt;\n            &lt;style&gt;\n                body { font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }\n                .form-group { margin-bottom: 15px; }\n                label { display: block; margin-bottom: 5px; font-weight: bold; }\n                input, textarea { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }\n                textarea { height: 200px; resize: vertical; }\n                button { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; }\n                button:hover { background: #0056b3; }\n                .nav { margin-bottom: 30px; }\n                a { color: #007bff; text-decoration: none; }\n                a:hover { text-decoration: underline; }\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;nav class=\"nav\"&gt;\n                &lt;a href=\"/\"&gt;\u2190 Back to Home&lt;/a&gt;\n            &lt;/nav&gt;\n            &lt;h1&gt;Create New Post&lt;/h1&gt;\n            &lt;form method=\"POST\" action=\"/admin\"&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"title\"&gt;Title:&lt;/label&gt;\n                    &lt;input type=\"text\" id=\"title\" name=\"title\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"author\"&gt;Author:&lt;/label&gt;\n                    &lt;input type=\"text\" id=\"author\" name=\"author\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"content\"&gt;Content:&lt;/label&gt;\n                    &lt;textarea id=\"content\" name=\"content\" required&gt;&lt;/textarea&gt;\n                &lt;/div&gt;\n                &lt;button type=\"submit\"&gt;Create Post&lt;/button&gt;\n            &lt;/form&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n        return html\n\n    @handles.POST\n    async def create_post(self, form: CreatePostForm) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Handle post creation\"\"\"\n        # Create the new post\n        post = self.storage.add_post(form.title, form.content, form.author)\n\n        # Return redirect HTML (or could use redirect response)\n        return f'&lt;meta http-equiv=\"refresh\" content=\"0;url=/post/{post.id}\"&gt;'\n</code></pre>"},{"location":"getting-started/first-app/#3-create-the-extension-configuration","title":"3. Create the Extension Configuration","text":"<p>Create <code>extensions/blog/extension.yaml</code>:</p> <pre><code>name: Blog Extension\ndescription: A simple blog extension for Serv\nversion: 1.0.0\nauthor: Your Name\nentry: blog.main:BlogExtension\n\nsettings:\n  posts_per_page: 10\n  allow_comments: false\n</code></pre>"},{"location":"getting-started/first-app/#4-create-the-main-application","title":"4. Create the Main Application","text":"<p>Create <code>app.py</code>:</p> <pre><code>from serv import App\n\n# Create the app with extension directory\napp = App(\n    config=\"./serv.config.yaml\",\n    extension_dir=\"./extensions\"\n)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000, reload=True)\n</code></pre>"},{"location":"getting-started/first-app/#5-create-the-configuration-file","title":"5. Create the Configuration File","text":"<p>Create <code>serv.config.yaml</code>:</p> <pre><code>extensions:\n  - extension: blog\n    settings:\n      posts_per_page: 5\n      allow_comments: true\n</code></pre>"},{"location":"getting-started/first-app/#6-initialize-the-extension-package","title":"6. Initialize the Extension Package","text":"<p>Create <code>extensions/blog/__init__.py</code>:</p> <pre><code># Blog extension package\n</code></pre>"},{"location":"getting-started/first-app/#running-the-application","title":"Running the Application","text":"<p>Now let's run our blog application:</p> <pre><code>python app.py\n</code></pre> <p>Visit the following URLs to test your application:</p> <ul> <li><code>http://localhost:8000/</code> - Homepage with blog posts</li> <li><code>http://localhost:8000/post/1</code> - View individual post</li> <li><code>http://localhost:8000/admin</code> - Admin interface to create posts</li> <li><code>http://localhost:8000/api/posts</code> - JSON API endpoint</li> </ul>"},{"location":"getting-started/first-app/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"getting-started/first-app/#extension-architecture","title":"Extension Architecture","text":"<p>Our blog is implemented as a extension, which makes it:</p> <ul> <li>Modular: Easy to enable/disable</li> <li>Reusable: Can be used in multiple applications</li> <li>Configurable: Settings can be overridden via configuration</li> </ul>"},{"location":"getting-started/first-app/#route-handling","title":"Route Handling","text":"<p>We used class-based routes with the modern <code>@handles</code> decorator pattern:</p> <ol> <li>BlogHomeRoute: Handles the homepage display using <code>@handles.GET</code></li> <li>BlogPostRoute: Handles individual post views with path parameters</li> <li>BlogApiRoute: Provides JSON API endpoints using <code>@handles.GET</code></li> <li>AdminRoute: Handles both form display and form submission using <code>@handles.GET</code> and <code>@handles.POST</code></li> </ol> <p>All routes use proper type annotations and return type hints for automatic response handling.</p>"},{"location":"getting-started/first-app/#form-handling","title":"Form Handling","text":"<p>The <code>CreatePostForm</code> class automatically handles form data parsing and validation:</p> <pre><code>class CreatePostForm(Form):\n    title: str\n    content: str\n    author: str\n</code></pre>"},{"location":"getting-started/first-app/#dependency-injection","title":"Dependency Injection","text":"<p>Notice how we inject dependencies throughout the application:</p> <pre><code>@handles.GET\nasync def homepage(self, request: GetRequest) -&gt; Annotated[str, HtmlResponse]:\n    # GetRequest is automatically injected based on HTTP method\n    # Return type annotation tells Serv to wrap as HTML response\n</code></pre>"},{"location":"getting-started/first-app/#extending-the-application","title":"Extending the Application","text":"<p>Here are some ideas for extending this blog:</p>"},{"location":"getting-started/first-app/#add-database-support","title":"Add Database Support","text":"<p>Replace the in-memory storage with a real database:</p> <pre><code>import sqlite3\nfrom contextlib import asynccontextmanager\n\nclass DatabaseStorage:\n    def __init__(self, db_path: str = \"blog.db\"):\n        self.db_path = db_path\n        self._init_db()\n\n    def _init_db(self):\n        with sqlite3.connect(self.db_path) as conn:\n            conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS posts (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    title TEXT NOT NULL,\n                    content TEXT NOT NULL,\n                    author TEXT NOT NULL,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n</code></pre>"},{"location":"getting-started/first-app/#add-authentication","title":"Add Authentication","text":"<p>Create an authentication extension:</p> <pre><code>class AuthExtension(Extension):\n    async def on_app_request_begin(self, router: Router = dependency()):\n        router.add_route(\"/login\", self.login_page)\n        router.add_route(\"/logout\", self.logout)\n\n    async def login_page(self, response: ResponseBuilder = dependency()):\n        # Implement login logic\n        pass\n</code></pre>"},{"location":"getting-started/first-app/#add-comments","title":"Add Comments","text":"<p>Extend the models to support comments:</p> <pre><code>@dataclass\nclass Comment:\n    id: int\n    post_id: int\n    author: str\n    content: str\n    created_at: datetime\n</code></pre>"},{"location":"getting-started/first-app/#add-rich-templates","title":"Add Rich Templates","text":"<p>Use Jinja2 for proper template rendering:</p> <pre><code>from jinja2 import Environment, FileSystemLoader\n\nclass BlogExtension(Extension):\n    def __init__(self):\n        self.storage = BlogStorage()\n        self.jinja_env = Environment(\n            loader=FileSystemLoader('templates')\n        )\n\n    def _render_template(self, template_name: str, context: dict) -&gt; str:\n        template = self.jinja_env.get_template(template_name)\n        return template.render(**context)\n</code></pre>"},{"location":"getting-started/first-app/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've built a complete blog application with Serv. You've learned about:</p> <ul> <li>\u2705 Extension architecture</li> <li>\u2705 Routing (both function and class-based)</li> <li>\u2705 Form handling</li> <li>\u2705 Template rendering</li> <li>\u2705 Configuration management</li> <li>\u2705 API endpoints</li> </ul>"},{"location":"getting-started/first-app/#continue-learning","title":"Continue Learning","text":"<ul> <li>Configuration - Learn about advanced configuration options</li> <li>Routing Guide - Master advanced routing techniques</li> <li>Extension Development - Build more sophisticated extensions</li> <li>Middleware - Add cross-cutting concerns to your app</li> </ul>"},{"location":"getting-started/first-app/#explore-more-examples","title":"Explore More Examples","text":"<ul> <li>Authentication Example - Add user authentication</li> <li>Database Integration - Connect to real databases</li> <li>API Development - Build REST APIs with Serv </li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install Serv and get your development environment set up.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>Serv requires Python 3.13 or higher. Make sure you have a compatible Python version installed:</p> <pre><code>python --version\n</code></pre>"},{"location":"getting-started/installation/#installing-serv","title":"Installing Serv","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<p>The easiest way to install Serv is using pip:</p> <pre><code>pip install getserving\n</code></pre> <p>Package Name</p> <p>The PyPI package is named <code>getserving</code> because <code>serv</code> was already taken. However, you'll still import it as <code>serv</code> in your Python code.</p>"},{"location":"getting-started/installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p>If you're using uv (which we highly recommend for Python project management):</p> <pre><code>uv add getserving\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to Serv or install the latest development version:</p> <pre><code>git clone https://github.com/8ly-dev/Serv.git\ncd Serv\nuv sync --group dev\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>To verify that Serv is installed correctly, you can run:</p> <pre><code>python -c \"import serv; print(serv.__version__)\"\n</code></pre> <p>Or use the CLI:</p> <pre><code>serv --version\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>Serv has several optional dependencies that you might want to install depending on your use case:</p>"},{"location":"getting-started/installation/#template-rendering","title":"Template Rendering","text":"<p>For Jinja2 template support (already included by default):</p> <pre><code>pip install getserving[jinja]\n</code></pre>"},{"location":"getting-started/installation/#file-upload-support","title":"File Upload Support","text":"<p>For multipart form data and file upload support (already included by default):</p> <pre><code>pip install getserving[multipart]\n</code></pre>"},{"location":"getting-started/installation/#development-tools","title":"Development Tools","text":"<p>For development and testing:</p> <pre><code>pip install getserving[dev]\n</code></pre> <p>This includes: - <code>pytest</code> and <code>pytest-asyncio</code> for testing - <code>uvicorn</code> for running the development server - <code>httpx</code> for making HTTP requests in tests - <code>ruff</code> for linting and formatting</p>"},{"location":"getting-started/installation/#asgi-server","title":"ASGI Server","text":"<p>Serv is an ASGI framework, so you'll need an ASGI server to run your applications. We recommend Uvicorn:</p> <pre><code>pip install uvicorn\n</code></pre> <p>Or with uv:</p> <pre><code>uv add uvicorn\n</code></pre>"},{"location":"getting-started/installation/#ide-setup","title":"IDE Setup","text":""},{"location":"getting-started/installation/#vs-code","title":"VS Code","text":"<p>For the best development experience with VS Code, install the Python extension and configure it to use your virtual environment.</p>"},{"location":"getting-started/installation/#pycharm","title":"PyCharm","text":"<p>PyCharm has excellent support for Python and ASGI applications. Make sure to configure your interpreter to use the virtual environment where Serv is installed.</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have Serv installed, you're ready to:</p> <ol> <li>Quick Start - Create your first Serv application</li> <li>Your First App - Build a complete application step by step</li> <li>Configuration - Learn about configuring Serv</li> </ol>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#python-version-issues","title":"Python Version Issues","text":"<p>If you're getting errors about Python version compatibility, make sure you're using Python 3.13 or higher:</p> <pre><code>python --version\n</code></pre>"},{"location":"getting-started/installation/#import-errors","title":"Import Errors","text":"<p>If you're getting import errors, make sure you're importing from <code>serv</code>, not <code>getserving</code>:</p> <pre><code># \u2705 Correct\nfrom serv import App\n\n# \u274c Incorrect\nfrom getserving import App\n</code></pre>"},{"location":"getting-started/installation/#virtual-environment-issues","title":"Virtual Environment Issues","text":"<p>If you're having dependency conflicts, try creating a fresh virtual environment:</p> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install getserving\n</code></pre>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with Serv in just a few minutes! This guide will walk you through creating your first Serv application using the CLI-first approach.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have Serv installed. If not, check out the Installation guide.</p>"},{"location":"getting-started/quick-start/#your-first-serv-app","title":"Your First Serv App","text":"<p>Let's create a simple \"Hello World\" application using Serv's CLI tools:</p>"},{"location":"getting-started/quick-start/#1-initialize-a-new-project","title":"1. Initialize a New Project","text":"<p>Create a new Serv project:</p> <pre><code>serv app init my-first-app\ncd my-first-app\n</code></pre> <p>This creates a basic project structure:</p> <pre><code>my-first-app/\n\u251c\u2500\u2500 serv.config.yaml    # Application configuration\n\u251c\u2500\u2500 extensions/            # Extension directory\n\u2514\u2500\u2500 templates/          # Template directory (optional)\n</code></pre>"},{"location":"getting-started/quick-start/#2-create-your-first-extension","title":"2. Create Your First Extension","text":"<p>Create a extension to handle your routes:</p> <pre><code>serv create extension --name \"Hello World\"\n</code></pre> <p>This creates:</p> <pre><code>extensions/\n\u2514\u2500\u2500 hello_world/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 extension.yaml\n    \u2514\u2500\u2500 hello_world.py\n</code></pre>"},{"location":"getting-started/quick-start/#3-add-routes-to-your-extension","title":"3. Add Routes to Your Extension","text":"<p>Add some routes using the CLI:</p> <pre><code># Create a home page route\nserv create route --name \"home\" --path \"/\" --extension \"hello_world\"\n\n# Create a greeting route with a parameter\nserv create route --name \"greet\" --path \"/greet/{name}\" --extension \"hello_world\"\n\n# Create an API route\nserv create route --name \"api_hello\" --path \"/api/hello\" --extension \"hello_world\"\n</code></pre>"},{"location":"getting-started/quick-start/#4-implement-your-route-handlers","title":"4. Implement Your Route Handlers","text":"<p>Edit the generated route files to add your logic:</p> <p>extensions/hello_world/route_home.py: <pre><code>from serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def Home(response: ResponseBuilder = dependency(), **path_params):\n    \"\"\"Handle requests to /\"\"\"\n    response.content_type(\"text/html\")\n    response.body(\"\"\"\n    &lt;h1&gt;Hello, World from Serv!&lt;/h1&gt;\n    &lt;p&gt;Welcome to your first Serv application!&lt;/p&gt;\n    &lt;ul&gt;\n        &lt;li&gt;&lt;a href=\"/greet/YourName\"&gt;Personalized Greeting&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=\"/api/hello\"&gt;JSON API&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n    \"\"\")\n</code></pre></p> <p>extensions/hello_world/route_greet.py: <pre><code>from serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def Greet(name: str, response: ResponseBuilder = dependency()):\n    \"\"\"Handle requests to /greet/{name}\"\"\"\n    response.content_type(\"text/html\")\n    response.body(f\"\"\"\n    &lt;h1&gt;Hello, {name}!&lt;/h1&gt;\n    &lt;p&gt;Welcome to Serv!&lt;/p&gt;\n    &lt;p&gt;&lt;a href=\"/\"&gt;\u2190 Back to Home&lt;/a&gt;&lt;/p&gt;\n    \"\"\")\n</code></pre></p> <p>extensions/hello_world/route_api_hello.py: <pre><code>from typing import Annotated\nfrom serv.routes import JsonResponse\n\nasync def ApiHello() -&gt; Annotated[dict, JsonResponse]:\n    \"\"\"Handle requests to /api/hello\"\"\"\n    return {\n        \"message\": \"Hello from Serv API!\",\n        \"framework\": \"Serv\",\n        \"version\": \"0.1.0\",\n        \"status\": \"success\"\n    }\n</code></pre></p>"},{"location":"getting-started/quick-start/#5-enable-your-extension","title":"5. Enable Your Extension","text":"<p>Enable the extension in your application:</p> <pre><code>serv extension enable hello_world\n</code></pre>"},{"location":"getting-started/quick-start/#6-run-your-application","title":"6. Run Your Application","text":"<p>Start the development server:</p> <pre><code>serv --dev launch\n</code></pre> <p>Your Serv application is now running at <code>http://127.0.0.1:8000</code>. The development server includes:</p> <ul> <li>\ud83d\udd04 Auto-reload: Automatically restarts when you change files</li> <li>\ud83d\udcdd Enhanced error reporting: Detailed tracebacks and debugging information  </li> <li>\ud83d\udc1b Debug logging: Verbose logging for development</li> <li>\u26a1 Fast startup: Optimized for development workflow</li> </ul>"},{"location":"getting-started/quick-start/#7-test-your-application","title":"7. Test Your Application","text":"<p>Open your browser and visit:</p> <ul> <li><code>http://localhost:8000/</code> - See the hello world page</li> <li><code>http://localhost:8000/greet/YourName</code> - See a personalized greeting</li> <li><code>http://localhost:8000/api/hello</code> - See the JSON API response</li> </ul>"},{"location":"getting-started/quick-start/#understanding-the-generated-structure","title":"Understanding the Generated Structure","text":"<p>Let's explore what the CLI created for you:</p>"},{"location":"getting-started/quick-start/#extension-configuration","title":"Extension Configuration","text":"<p>extensions/hello_world/extension.yaml: <pre><code>name: Hello World\ndescription: A cool Serv extension.\nversion: 0.1.0\nauthor: Your Name\n\nrouters:\n  - name: main_router\n    routes:\n      - path: /\n        handler: route_home:Home\n      - path: /greet/{name}\n        handler: route_greet:Greet\n      - path: /api/hello\n        handler: route_api_hello:ApiHello\n</code></pre></p> <p>This declarative configuration: - Defines your extension metadata - Maps URL paths to handler functions - Automatically wires everything together</p>"},{"location":"getting-started/quick-start/#extension-class-event-handling-only","title":"Extension Class (Event Handling Only)","text":"<p>extensions/hello_world/hello_world.py: <pre><code>from serv.extensions import Extension\nfrom bevy import dependency\n\nclass HelloWorld(Extension):\n    async def on_app_startup(self):\n        \"\"\"Called when the application starts up\"\"\"\n        print(\"Hello World extension starting up\")\n\n    async def on_app_shutdown(self):\n        \"\"\"Called when the application shuts down\"\"\"\n        print(\"Hello World extension shutting down\")\n</code></pre></p> <p>The extension class only handles events - routes are defined declaratively in <code>extension.yaml</code>.</p>"},{"location":"getting-started/quick-start/#application-configuration","title":"Application Configuration","text":"<p>serv.config.yaml: <pre><code>site_info:\n  name: \"My First App\"\n  description: \"A Serv application\"\n\nextensions:\n  - extension: hello_world\n</code></pre></p>"},{"location":"getting-started/quick-start/#adding-more-features","title":"Adding More Features","text":""},{"location":"getting-started/quick-start/#create-an-api-extension","title":"Create an API Extension","text":"<p>Let's add a dedicated API extension:</p> <pre><code># Create an API extension\nserv create extension --name \"API\"\n\n# Add API routes\nserv create route --name \"users\" --path \"/users\" --router \"api_router\" --extension \"api\"\nserv create route --name \"user_detail\" --path \"/users/{id}\" --router \"api_router\" --extension \"api\"\n</code></pre> <p>Update the API extension configuration to mount at <code>/api/v1</code>:</p> <p>extensions/api/extension.yaml: <pre><code>name: API\ndescription: REST API endpoints\nversion: 1.0.0\nauthor: Your Name\n\nrouters:\n  - name: api_router\n    mount: /api/v1\n    routes:\n      - path: /users\n        handler: route_users:Users\n        methods: [\"GET\", \"POST\"]\n      - path: /users/{id}\n        handler: route_user_detail:UserDetail\n        methods: [\"GET\", \"PUT\", \"DELETE\"]\n</code></pre></p>"},{"location":"getting-started/quick-start/#implement-api-handlers","title":"Implement API Handlers","text":"<p>extensions/api/route_users.py: <pre><code>from typing import Annotated\nfrom serv.routes import GetRequest, PostRequest, JsonResponse\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def Users(request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n    \"\"\"Handle GET /api/v1/users\"\"\"\n    return {\n        \"users\": [\n            {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n            {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\"}\n        ]\n    }\n\n# For POST requests, create a separate handler or use method detection\nasync def CreateUser(request: PostRequest, response: ResponseBuilder = dependency()):\n    \"\"\"Handle POST /api/v1/users\"\"\"\n    form_data = await request.form()\n\n    # In a real app, you'd save to a database\n    new_user = {\n        \"id\": 3,\n        \"name\": form_data.get(\"name\"),\n        \"email\": form_data.get(\"email\")\n    }\n\n    response.content_type(\"application/json\")\n    response.set_status(201)\n    response.body(f'{{\"user\": {new_user}, \"message\": \"User created\"}}')\n</code></pre></p>"},{"location":"getting-started/quick-start/#add-middleware","title":"Add Middleware","text":"<p>Add authentication middleware to your API:</p> <pre><code>serv create middleware --name \"auth_check\" --extension \"api\"\n</code></pre> <p>extensions/api/middleware_auth_check.py: <pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def auth_check_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Simple API key authentication\"\"\"\n\n    # Only check auth for API routes\n    if not request.path.startswith(\"/api/\"):\n        yield\n        return\n\n    api_key = request.headers.get(\"X-API-Key\")\n    if not api_key or api_key != \"demo-api-key\":\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"Invalid or missing API key\"}')\n        return\n\n    yield  # Continue processing\n</code></pre></p> <p>Update the API extension configuration:</p> <p>extensions/api/extension.yaml: <pre><code>name: API\ndescription: REST API endpoints\nversion: 1.0.0\nauthor: Your Name\n\nmiddleware:\n  - entry: middleware_auth_check:auth_check_middleware\n\nrouters:\n  - name: api_router\n    mount: /api/v1\n    routes:\n      - path: /users\n        handler: route_users:Users\n        methods: [\"GET\"]\n      - path: /users/{id}\n        handler: route_user_detail:UserDetail\n        methods: [\"GET\"]\n</code></pre></p>"},{"location":"getting-started/quick-start/#enable-the-api-extension","title":"Enable the API Extension","text":"<pre><code>serv extension enable api\n</code></pre> <p>Now test the API with authentication:</p> <pre><code># This will fail (401 Unauthorized)\ncurl http://localhost:8000/api/v1/users\n\n# This will succeed\ncurl -H \"X-API-Key: demo-api-key\" http://localhost:8000/api/v1/users\n</code></pre>"},{"location":"getting-started/quick-start/#cli-commands-reference","title":"CLI Commands Reference","text":"<p>Here are the essential CLI commands you'll use:</p>"},{"location":"getting-started/quick-start/#project-management","title":"Project Management","text":"<pre><code>serv app init &lt;name&gt;           # Initialize new project\nserv app details               # Show project information\nserv app check                 # Validate project health\n</code></pre>"},{"location":"getting-started/quick-start/#extension-management","title":"Extension Management","text":"<pre><code>serv create extension --name \"Name\"              # Create new extension\nserv extension enable &lt;extension&gt;                   # Enable extension\nserv extension disable &lt;extension&gt;                  # Disable extension\nserv extension list                               # List enabled extensions\nserv extension list --available                  # List all available extensions\nserv extension validate &lt;extension&gt;                 # Validate extension\n</code></pre>"},{"location":"getting-started/quick-start/#component-creation","title":"Component Creation","text":"<pre><code>serv create route --name \"name\" --path \"/path\" --extension \"extension\"\nserv create middleware --name \"name\" --extension \"extension\"\nserv create listener --name \"name\" --extension \"extension\"\n</code></pre>"},{"location":"getting-started/quick-start/#development","title":"Development","text":"<pre><code>serv --dev launch              # Start development server\nserv launch                    # Start production server\nserv test                      # Run tests\nserv shell                     # Interactive shell\n</code></pre>"},{"location":"getting-started/quick-start/#configuration","title":"Configuration","text":"<pre><code>serv config show               # Show current configuration\nserv config validate           # Validate configuration\nserv config get &lt;key&gt;          # Get configuration value\nserv config set &lt;key&gt; &lt;value&gt;  # Set configuration value\n</code></pre>"},{"location":"getting-started/quick-start/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/quick-start/#1-use-the-cli-for-everything","title":"1. Use the CLI for Everything","text":"<p>Always use CLI commands to create components:</p> <pre><code># Good\nserv create extension --name \"Blog\"\nserv create route --name \"blog_home\" --path \"/blog\" --extension \"blog\"\n\n# Avoid manual file creation\n</code></pre>"},{"location":"getting-started/quick-start/#2-organize-by-feature","title":"2. Organize by Feature","text":"<p>Create extensions for each major feature:</p> <pre><code>serv create extension --name \"User Management\"\nserv create extension --name \"Blog\"\nserv create extension --name \"API\"\nserv create extension --name \"Admin\"\n</code></pre>"},{"location":"getting-started/quick-start/#3-use-declarative-configuration","title":"3. Use Declarative Configuration","text":"<p>Define routes in <code>extension.yaml</code>, not in code:</p> <pre><code># Good: Declarative routing\nrouters:\n  - name: blog_router\n    routes:\n      - path: /blog\n        handler: route_blog_home:BlogHome\n\n# Avoid: Programmatic routing in extension classes\n</code></pre>"},{"location":"getting-started/quick-start/#4-keep-extension-classes-event-only","title":"4. Keep Extension Classes Event-Only","text":"<p>Use extension classes only for event handling:</p> <pre><code># Good: Events only\nclass MyExtension(Extension):\n    async def on_app_startup(self):\n        # Initialize resources\n        pass\n\n    async def on_user_created(self, user_id: int):\n        # Handle custom events\n        pass\n\n# Avoid: Route registration in extension classes\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've created your first Serv application using the CLI-first approach. Here's what to explore next:</p>"},{"location":"getting-started/quick-start/#learn-core-concepts","title":"Learn Core Concepts","text":"<ul> <li>Routing - Master declarative routing patterns</li> <li>Extensions - Build powerful, reusable extensions</li> <li>Middleware - Add cross-cutting concerns</li> <li>Dependency Injection - Master the DI system</li> </ul>"},{"location":"getting-started/quick-start/#build-a-complete-application","title":"Build a Complete Application","text":"<ul> <li>Configuration - Advanced configuration techniques</li> <li>Testing - Test your applications effectively</li> </ul>"},{"location":"getting-started/quick-start/#explore-advanced-features","title":"Explore Advanced Features","text":"<ul> <li>Forms and Validation - Handle complex form processing</li> <li>Database Integration - Connect to databases</li> <li>Authentication - Implement user authentication</li> </ul>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quick-start/#common-issues","title":"Common Issues","text":"<p>Extension not found: <pre><code># Make sure the extension is enabled\nserv extension enable my_extension\n\n# Check extension status\nserv extension list\n</code></pre></p> <p>Route not working: <pre><code># Validate your extension configuration\nserv extension validate my_extension\n\n# Check application health\nserv app check\n</code></pre></p> <p>Configuration errors: <pre><code># Validate configuration\nserv config validate\n\n# Check current configuration\nserv config show\n</code></pre></p>"},{"location":"getting-started/quick-start/#getting-help","title":"Getting Help","text":"<pre><code># Get help for any command\nserv --help\nserv create --help\nserv extension --help\n\n# Check application status\nserv app details\nserv app check\n</code></pre> <p>You're now ready to build amazing applications with Serv! \ud83d\ude80</p>"},{"location":"guides/authentication/","title":"Authentication","text":"<p>Authentication is a critical aspect of web applications. Serv provides flexible authentication patterns through middleware, extensions, and dependency injection. This guide covers how to implement various authentication strategies in Serv applications.</p>"},{"location":"guides/authentication/#overview","title":"Overview","text":"<p>Serv's authentication approach:</p> <ol> <li>Middleware-Based: Authentication logic implemented as middleware</li> <li>Extension-Organized: Authentication components organized within extensions</li> <li>Flexible: Support for multiple authentication strategies</li> <li>Session Management: Built-in support for cookies and sessions</li> <li>Dependency Injection: Easy access to user information in route handlers</li> </ol>"},{"location":"guides/authentication/#authentication-strategies","title":"Authentication Strategies","text":""},{"location":"guides/authentication/#basic-authentication","title":"Basic Authentication","text":"<p>Basic authentication using username and password credentials.</p>"},{"location":"guides/authentication/#session-based-authentication","title":"Session-Based Authentication","text":"<p>Traditional session-based authentication with cookies.</p>"},{"location":"guides/authentication/#token-based-authentication","title":"Token-Based Authentication","text":"<p>JWT tokens and API key authentication.</p>"},{"location":"guides/authentication/#oauth-integration","title":"OAuth Integration","text":"<p>Integration with third-party OAuth providers.</p>"},{"location":"guides/authentication/#setting-up-authentication","title":"Setting Up Authentication","text":""},{"location":"guides/authentication/#creating-an-authentication-extension","title":"Creating an Authentication Extension","text":"<p>Use the CLI to create an authentication extension:</p> <pre><code># Create an authentication extension\nserv create extension --name \"Auth\"\n\n# Create authentication middleware\nserv create middleware --name \"auth_check\" --extension \"auth\"\n\n# Create authentication routes\nserv create route --name \"login\" --path \"/login\" --extension \"auth\"\nserv create route --name \"logout\" --path \"/logout\" --extension \"auth\"\nserv create route --name \"register\" --path \"/register\" --extension \"auth\"\n</code></pre>"},{"location":"guides/authentication/#basic-extension-structure","title":"Basic Extension Structure","text":"<p>extensions/auth/extension.yaml: <pre><code>name: Auth\ndescription: Authentication and authorization\nversion: 1.0.0\nauthor: Your Name\n\nsettings:\n  secret_key: \"your-secret-key-change-in-production\"\n  session_timeout: 3600\n  password_min_length: 8\n  enable_registration: true\n\nrouters:\n  - name: main_router\n    routes:\n      - path: /login\n        handler: route_login:LoginPage\n        methods: [\"GET\", \"POST\"]\n      - path: /logout\n        handler: route_logout:LogoutPage\n        methods: [\"POST\"]\n      - path: /register\n        handler: route_register:RegisterPage\n        methods: [\"GET\", \"POST\"]\n\nmiddleware:\n  - entry: middleware_auth_check:auth_check_middleware\n    config:\n      exempt_paths: [\"/\", \"/login\", \"/register\", \"/public\"]\n</code></pre></p>"},{"location":"guides/authentication/#session-based-authentication_1","title":"Session-Based Authentication","text":""},{"location":"guides/authentication/#user-model-and-storage","title":"User Model and Storage","text":"<p>extensions/auth/models.py: <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\nimport hashlib\nimport secrets\n\n@dataclass\nclass User:\n    id: Optional[int]\n    username: str\n    email: str\n    password_hash: str\n    created_at: Optional[datetime] = None\n    is_active: bool = True\n    last_login: Optional[datetime] = None\n\nclass UserStorage:\n    \"\"\"Simple in-memory user storage (use database in production)\"\"\"\n\n    def __init__(self):\n        self.users: dict[int, User] = {}\n        self.users_by_username: dict[str, User] = {}\n        self.next_id = 1\n\n        # Create default admin user\n        self.create_user(\"admin\", \"admin@example.com\", \"admin123\")\n\n    def create_user(self, username: str, email: str, password: str) -&gt; User:\n        \"\"\"Create a new user\"\"\"\n        if username in self.users_by_username:\n            raise ValueError(\"Username already exists\")\n\n        password_hash = self._hash_password(password)\n        user = User(\n            id=self.next_id,\n            username=username,\n            email=email,\n            password_hash=password_hash,\n            created_at=datetime.now()\n        )\n\n        self.users[self.next_id] = user\n        self.users_by_username[username] = user\n        self.next_id += 1\n\n        return user\n\n    def get_user_by_username(self, username: str) -&gt; Optional[User]:\n        \"\"\"Get user by username\"\"\"\n        return self.users_by_username.get(username)\n\n    def get_user_by_id(self, user_id: int) -&gt; Optional[User]:\n        \"\"\"Get user by ID\"\"\"\n        return self.users.get(user_id)\n\n    def verify_password(self, user: User, password: str) -&gt; bool:\n        \"\"\"Verify user password\"\"\"\n        return self._hash_password(password) == user.password_hash\n\n    def _hash_password(self, password: str) -&gt; str:\n        \"\"\"Hash password using SHA-256 (use bcrypt in production)\"\"\"\n        return hashlib.sha256(password.encode()).hexdigest()\n\n# Global user storage instance\nuser_storage = UserStorage()\n</code></pre></p>"},{"location":"guides/authentication/#session-management","title":"Session Management","text":"<p>extensions/auth/sessions.py: <pre><code>import secrets\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict\nfrom dataclasses import dataclass\n\n@dataclass\nclass Session:\n    session_id: str\n    user_id: int\n    created_at: datetime\n    expires_at: datetime\n    data: Dict = None\n\nclass SessionManager:\n    \"\"\"Simple in-memory session manager (use Redis in production)\"\"\"\n\n    def __init__(self, timeout_seconds: int = 3600):\n        self.sessions: Dict[str, Session] = {}\n        self.timeout_seconds = timeout_seconds\n\n    def create_session(self, user_id: int) -&gt; str:\n        \"\"\"Create a new session for user\"\"\"\n        session_id = secrets.token_urlsafe(32)\n        expires_at = datetime.now() + timedelta(seconds=self.timeout_seconds)\n\n        session = Session(\n            session_id=session_id,\n            user_id=user_id,\n            created_at=datetime.now(),\n            expires_at=expires_at,\n            data={}\n        )\n\n        self.sessions[session_id] = session\n        return session_id\n\n    def get_session(self, session_id: str) -&gt; Optional[Session]:\n        \"\"\"Get session by ID\"\"\"\n        session = self.sessions.get(session_id)\n\n        if session and session.expires_at &gt; datetime.now():\n            return session\n        elif session:\n            # Session expired, remove it\n            del self.sessions[session_id]\n\n        return None\n\n    def delete_session(self, session_id: str) -&gt; bool:\n        \"\"\"Delete session\"\"\"\n        if session_id in self.sessions:\n            del self.sessions[session_id]\n            return True\n        return False\n\n    def cleanup_expired_sessions(self):\n        \"\"\"Remove expired sessions\"\"\"\n        now = datetime.now()\n        expired_sessions = [\n            session_id for session_id, session in self.sessions.items()\n            if session.expires_at &lt;= now\n        ]\n\n        for session_id in expired_sessions:\n            del self.sessions[session_id]\n\n# Global session manager\nsession_manager = SessionManager()\n</code></pre></p>"},{"location":"guides/authentication/#login-route","title":"Login Route","text":"<p>extensions/auth/route_login.py: <pre><code>from dataclasses import dataclass\nfrom serv.routes import GetRequest, PostRequest\nfrom serv.responses import ResponseBuilder\nfrom serv.exceptions import HTTPBadRequestException\nfrom bevy import dependency\nfrom .models import user_storage\nfrom .sessions import session_manager\n\n@dataclass\nclass LoginForm:\n    username: str\n    password: str\n\nasync def LoginPage(\n    request: GetRequest | PostRequest,\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Handle login page and form submission\"\"\"\n\n    if request.method == \"GET\":\n        # Display login form\n        response.content_type(\"text/html\")\n        response.body(\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;Login&lt;/title&gt;\n            &lt;style&gt;\n                body { font-family: Arial, sans-serif; max-width: 400px; margin: 50px auto; padding: 20px; }\n                .form-group { margin-bottom: 15px; }\n                label { display: block; margin-bottom: 5px; }\n                input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }\n                button { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; }\n                .error { color: red; margin-top: 10px; }\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;h2&gt;Login&lt;/h2&gt;\n            &lt;form method=\"post\" action=\"/login\"&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"username\"&gt;Username:&lt;/label&gt;\n                    &lt;input type=\"text\" id=\"username\" name=\"username\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"password\"&gt;Password:&lt;/label&gt;\n                    &lt;input type=\"password\" id=\"password\" name=\"password\" required&gt;\n                &lt;/div&gt;\n                &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n            &lt;/form&gt;\n            &lt;p&gt;&lt;a href=\"/register\"&gt;Don't have an account? Register here&lt;/a&gt;&lt;/p&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\")\n\n    elif request.method == \"POST\":\n        # Process login form\n        try:\n            form_data = await request.form(LoginForm)\n\n            # Validate credentials\n            user = user_storage.get_user_by_username(form_data.username)\n            if not user or not user_storage.verify_password(user, form_data.password):\n                raise HTTPBadRequestException(\"Invalid username or password\")\n\n            if not user.is_active:\n                raise HTTPBadRequestException(\"Account is disabled\")\n\n            # Create session\n            session_id = session_manager.create_session(user.id)\n\n            # Set session cookie\n            response.set_cookie(\n                \"session_id\",\n                session_id,\n                max_age=3600,\n                httponly=True,\n                samesite=\"lax\",\n                secure=False  # Set to True in production with HTTPS\n            )\n\n            # Update last login\n            user.last_login = datetime.now()\n\n            # Redirect to dashboard or home\n            response.redirect(\"/dashboard\", status_code=302)\n\n        except (ValueError, TypeError) as e:\n            raise HTTPBadRequestException(f\"Invalid form data: {str(e)}\")\n</code></pre></p>"},{"location":"guides/authentication/#logout-route","title":"Logout Route","text":"<p>extensions/auth/route_logout.py: <pre><code>from serv.routes import PostRequest\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\nfrom .sessions import session_manager\n\nasync def LogoutPage(\n    request: PostRequest,\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Handle user logout\"\"\"\n\n    # Get session ID from cookie\n    session_id = request.cookies.get(\"session_id\")\n\n    if session_id:\n        # Delete session\n        session_manager.delete_session(session_id)\n\n    # Clear session cookie\n    response.set_cookie(\n        \"session_id\",\n        \"\",\n        max_age=0,\n        httponly=True,\n        samesite=\"lax\"\n    )\n\n    # Redirect to home page\n    response.redirect(\"/\", status_code=302)\n</code></pre></p>"},{"location":"guides/authentication/#registration-route","title":"Registration Route","text":"<p>extensions/auth/route_register.py: <pre><code>from dataclasses import dataclass\nfrom serv.routes import GetRequest, PostRequest\nfrom serv.responses import ResponseBuilder\nfrom serv.exceptions import HTTPBadRequestException\nfrom bevy import dependency\nfrom .models import user_storage\nfrom .sessions import session_manager\n\n@dataclass\nclass RegisterForm:\n    username: str\n    email: str\n    password: str\n    confirm_password: str\n\nasync def RegisterPage(\n    request: GetRequest | PostRequest,\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Handle registration page and form submission\"\"\"\n\n    if request.method == \"GET\":\n        # Display registration form\n        response.content_type(\"text/html\")\n        response.body(\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;Register&lt;/title&gt;\n            &lt;style&gt;\n                body { font-family: Arial, sans-serif; max-width: 400px; margin: 50px auto; padding: 20px; }\n                .form-group { margin-bottom: 15px; }\n                label { display: block; margin-bottom: 5px; }\n                input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }\n                button { background: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; }\n                .error { color: red; margin-top: 10px; }\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;h2&gt;Register&lt;/h2&gt;\n            &lt;form method=\"post\" action=\"/register\"&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"username\"&gt;Username:&lt;/label&gt;\n                    &lt;input type=\"text\" id=\"username\" name=\"username\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"email\"&gt;Email:&lt;/label&gt;\n                    &lt;input type=\"email\" id=\"email\" name=\"email\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"password\"&gt;Password:&lt;/label&gt;\n                    &lt;input type=\"password\" id=\"password\" name=\"password\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"confirm_password\"&gt;Confirm Password:&lt;/label&gt;\n                    &lt;input type=\"password\" id=\"confirm_password\" name=\"confirm_password\" required&gt;\n                &lt;/div&gt;\n                &lt;button type=\"submit\"&gt;Register&lt;/button&gt;\n            &lt;/form&gt;\n            &lt;p&gt;&lt;a href=\"/login\"&gt;Already have an account? Login here&lt;/a&gt;&lt;/p&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\")\n\n    elif request.method == \"POST\":\n        # Process registration form\n        try:\n            form_data = await request.form(RegisterForm)\n\n            # Validate form data\n            if form_data.password != form_data.confirm_password:\n                raise HTTPBadRequestException(\"Passwords do not match\")\n\n            if len(form_data.password) &lt; 8:\n                raise HTTPBadRequestException(\"Password must be at least 8 characters\")\n\n            if not form_data.username or len(form_data.username) &lt; 3:\n                raise HTTPBadRequestException(\"Username must be at least 3 characters\")\n\n            # Create user\n            try:\n                user = user_storage.create_user(\n                    form_data.username,\n                    form_data.email,\n                    form_data.password\n                )\n            except ValueError as e:\n                raise HTTPBadRequestException(str(e))\n\n            # Create session and log in user\n            session_id = session_manager.create_session(user.id)\n\n            response.set_cookie(\n                \"session_id\",\n                session_id,\n                max_age=3600,\n                httponly=True,\n                samesite=\"lax\",\n                secure=False\n            )\n\n            # Redirect to dashboard\n            response.redirect(\"/dashboard\", status_code=302)\n\n        except (ValueError, TypeError) as e:\n            raise HTTPBadRequestException(f\"Invalid form data: {str(e)}\")\n</code></pre></p>"},{"location":"guides/authentication/#authentication-middleware","title":"Authentication Middleware","text":"<p>extensions/auth/middleware_auth_check.py: <pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\nfrom .models import user_storage\nfrom .sessions import session_manager\n\nasync def auth_check_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Authentication middleware\"\"\"\n\n    # Get middleware configuration\n    config = getattr(auth_check_middleware, '_config', {})\n    exempt_paths = config.get('exempt_paths', [\"/\", \"/login\", \"/register\", \"/public\"])\n\n    # Skip authentication for exempt paths\n    if request.path in exempt_paths or request.path.startswith(\"/public/\"):\n        yield\n        return\n\n    # Get session from cookie\n    session_id = request.cookies.get(\"session_id\")\n\n    if not session_id:\n        # No session, redirect to login\n        if request.headers.get(\"accept\", \"\").startswith(\"application/json\"):\n            response.set_status(401)\n            response.content_type(\"application/json\")\n            response.body('{\"error\": \"Authentication required\"}')\n        else:\n            response.redirect(\"/login\", status_code=302)\n        return\n\n    # Validate session\n    session = session_manager.get_session(session_id)\n    if not session:\n        # Invalid session, redirect to login\n        response.set_cookie(\"session_id\", \"\", max_age=0)\n        if request.headers.get(\"accept\", \"\").startswith(\"application/json\"):\n            response.set_status(401)\n            response.content_type(\"application/json\")\n            response.body('{\"error\": \"Session expired\"}')\n        else:\n            response.redirect(\"/login\", status_code=302)\n        return\n\n    # Get user\n    user = user_storage.get_user_by_id(session.user_id)\n    if not user or not user.is_active:\n        # User not found or inactive\n        session_manager.delete_session(session_id)\n        response.set_cookie(\"session_id\", \"\", max_age=0)\n        response.redirect(\"/login\", status_code=302)\n        return\n\n    # Add user to request context\n    request.context['user'] = user\n    request.context['session'] = session\n\n    yield  # Continue processing\n</code></pre></p>"},{"location":"guides/authentication/#token-based-authentication_1","title":"Token-Based Authentication","text":""},{"location":"guides/authentication/#jwt-token-authentication","title":"JWT Token Authentication","text":"<p>extensions/auth/jwt_auth.py: <pre><code>import jwt\nimport secrets\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass TokenPayload:\n    user_id: int\n    username: str\n    exp: datetime\n    iat: datetime\n\nclass JWTManager:\n    def __init__(self, secret_key: str, algorithm: str = \"HS256\", expiry_hours: int = 24):\n        self.secret_key = secret_key\n        self.algorithm = algorithm\n        self.expiry_hours = expiry_hours\n\n    def create_token(self, user_id: int, username: str) -&gt; str:\n        \"\"\"Create a JWT token for user\"\"\"\n        now = datetime.utcnow()\n        payload = {\n            \"user_id\": user_id,\n            \"username\": username,\n            \"iat\": now,\n            \"exp\": now + timedelta(hours=self.expiry_hours)\n        }\n\n        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)\n\n    def verify_token(self, token: str) -&gt; Optional[TokenPayload]:\n        \"\"\"Verify and decode JWT token\"\"\"\n        try:\n            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])\n            return TokenPayload(\n                user_id=payload[\"user_id\"],\n                username=payload[\"username\"],\n                exp=datetime.fromtimestamp(payload[\"exp\"]),\n                iat=datetime.fromtimestamp(payload[\"iat\"])\n            )\n        except jwt.ExpiredSignatureError:\n            return None\n        except jwt.InvalidTokenError:\n            return None\n\n    def refresh_token(self, token: str) -&gt; Optional[str]:\n        \"\"\"Refresh an existing token\"\"\"\n        payload = self.verify_token(token)\n        if payload:\n            return self.create_token(payload.user_id, payload.username)\n        return None\n\n# Initialize JWT manager\njwt_manager = JWTManager(secret_key=\"your-secret-key-change-in-production\")\n</code></pre></p>"},{"location":"guides/authentication/#api-token-authentication","title":"API Token Authentication","text":"<p>extensions/auth/api_auth.py: <pre><code>import secrets\nfrom datetime import datetime\nfrom typing import Optional, Dict\nfrom dataclasses import dataclass\n\n@dataclass\nclass APIKey:\n    key: str\n    user_id: int\n    name: str\n    created_at: datetime\n    last_used: Optional[datetime] = None\n    is_active: bool = True\n\nclass APIKeyManager:\n    \"\"\"Manage API keys for authentication\"\"\"\n\n    def __init__(self):\n        self.api_keys: Dict[str, APIKey] = {}\n\n        # Create a demo API key\n        demo_key = self.create_api_key(1, \"Demo Key\")\n        print(f\"Demo API Key: {demo_key}\")\n\n    def create_api_key(self, user_id: int, name: str) -&gt; str:\n        \"\"\"Create a new API key for user\"\"\"\n        key = f\"sk_{secrets.token_urlsafe(32)}\"\n\n        api_key = APIKey(\n            key=key,\n            user_id=user_id,\n            name=name,\n            created_at=datetime.now()\n        )\n\n        self.api_keys[key] = api_key\n        return key\n\n    def verify_api_key(self, key: str) -&gt; Optional[APIKey]:\n        \"\"\"Verify API key and return associated data\"\"\"\n        api_key = self.api_keys.get(key)\n\n        if api_key and api_key.is_active:\n            api_key.last_used = datetime.now()\n            return api_key\n\n        return None\n\n    def revoke_api_key(self, key: str) -&gt; bool:\n        \"\"\"Revoke an API key\"\"\"\n        if key in self.api_keys:\n            self.api_keys[key].is_active = False\n            return True\n        return False\n\n# Global API key manager\napi_key_manager = APIKeyManager()\n</code></pre></p>"},{"location":"guides/authentication/#jwt-authentication-middleware","title":"JWT Authentication Middleware","text":"<p>extensions/auth/middleware_jwt_auth.py: <pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\nfrom .jwt_auth import jwt_manager\nfrom .models import user_storage\n\nasync def jwt_auth_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"JWT token authentication middleware\"\"\"\n\n    # Skip auth for public routes\n    if request.path.startswith(\"/public\") or request.path in [\"/\", \"/login\", \"/register\"]:\n        yield\n        return\n\n    # Get token from Authorization header\n    auth_header = request.headers.get(\"authorization\", \"\")\n\n    if not auth_header.startswith(\"Bearer \"):\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"Missing or invalid authorization header\"}')\n        return\n\n    token = auth_header[7:]  # Remove \"Bearer \" prefix\n\n    # Verify token\n    payload = jwt_manager.verify_token(token)\n    if not payload:\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"Invalid or expired token\"}')\n        return\n\n    # Get user\n    user = user_storage.get_user_by_id(payload.user_id)\n    if not user or not user.is_active:\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"User not found or inactive\"}')\n        return\n\n    # Add user to request context\n    request.context['user'] = user\n    request.context['token_payload'] = payload\n\n    yield\n</code></pre></p>"},{"location":"guides/authentication/#api-key-authentication-middleware","title":"API Key Authentication Middleware","text":"<p>extensions/auth/middleware_api_key.py: <pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\nfrom .api_auth import api_key_manager\nfrom .models import user_storage\n\nasync def api_key_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"API key authentication middleware\"\"\"\n\n    # Only apply to API routes\n    if not request.path.startswith(\"/api/\"):\n        yield\n        return\n\n    # Get API key from header\n    api_key = request.headers.get(\"x-api-key\") or request.headers.get(\"authorization\")\n\n    if not api_key:\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"API key required\"}')\n        return\n\n    # Remove \"Bearer \" prefix if present\n    if api_key.startswith(\"Bearer \"):\n        api_key = api_key[7:]\n\n    # Verify API key\n    key_data = api_key_manager.verify_api_key(api_key)\n    if not key_data:\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"Invalid API key\"}')\n        return\n\n    # Get user\n    user = user_storage.get_user_by_id(key_data.user_id)\n    if not user or not user.is_active:\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"User not found or inactive\"}')\n        return\n\n    # Add user and API key info to request context\n    request.context['user'] = user\n    request.context['api_key'] = key_data\n\n    yield\n</code></pre></p>"},{"location":"guides/authentication/#using-authentication-in-routes","title":"Using Authentication in Routes","text":""},{"location":"guides/authentication/#accessing-current-user","title":"Accessing Current User","text":"<p>extensions/dashboard/route_dashboard.py: <pre><code>from serv.routes import GetRequest\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def Dashboard(\n    request: GetRequest,\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"User dashboard - requires authentication\"\"\"\n\n    # Get current user from request context (set by auth middleware)\n    user = request.context.get('user')\n\n    if not user:\n        # This shouldn't happen if auth middleware is working\n        response.redirect(\"/login\", status_code=302)\n        return\n\n    response.content_type(\"text/html\")\n    response.body(f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Dashboard&lt;/title&gt;\n        &lt;style&gt;\n            body {{ font-family: Arial, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; }}\n            .header {{ display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; }}\n            .user-info {{ background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; }}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=\"header\"&gt;\n            &lt;h1&gt;Dashboard&lt;/h1&gt;\n            &lt;form method=\"post\" action=\"/logout\" style=\"margin: 0;\"&gt;\n                &lt;button type=\"submit\"&gt;Logout&lt;/button&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"user-info\"&gt;\n            &lt;h3&gt;Welcome, {user.username}!&lt;/h3&gt;\n            &lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; {user.email}&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Member since:&lt;/strong&gt; {user.created_at.strftime('%B %d, %Y') if user.created_at else 'Unknown'}&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Last login:&lt;/strong&gt; {user.last_login.strftime('%B %d, %Y at %I:%M %p') if user.last_login else 'Never'}&lt;/p&gt;\n        &lt;/div&gt;\n\n        &lt;h2&gt;Your Account&lt;/h2&gt;\n        &lt;p&gt;This is your personal dashboard. You can manage your account settings and view your activity here.&lt;/p&gt;\n\n        &lt;h3&gt;Quick Actions&lt;/h3&gt;\n        &lt;ul&gt;\n            &lt;li&gt;&lt;a href=\"/profile\"&gt;Edit Profile&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"/settings\"&gt;Account Settings&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"/api/user/profile\"&gt;View API Profile&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\")\n</code></pre></p>"},{"location":"guides/authentication/#api-endpoints-with-authentication","title":"API Endpoints with Authentication","text":"<p>extensions/api/route_user_profile.py: <pre><code>from serv.routes import GetRequest\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def UserProfile(\n    request: GetRequest,\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Get current user profile via API\"\"\"\n\n    user = request.context.get('user')\n\n    if not user:\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"Authentication required\"}')\n        return\n\n    # Return user profile data\n    profile_data = {\n        \"id\": user.id,\n        \"username\": user.username,\n        \"email\": user.email,\n        \"created_at\": user.created_at.isoformat() if user.created_at else None,\n        \"last_login\": user.last_login.isoformat() if user.last_login else None,\n        \"is_active\": user.is_active\n    }\n\n    response.content_type(\"application/json\")\n    response.body(profile_data)\n</code></pre></p>"},{"location":"guides/authentication/#role-based-authorization","title":"Role-Based Authorization","text":""},{"location":"guides/authentication/#role-system","title":"Role System","text":"<p>extensions/auth/roles.py: <pre><code>from enum import Enum\nfrom typing import Set, Dict\nfrom dataclasses import dataclass\n\nclass Role(Enum):\n    ADMIN = \"admin\"\n    MODERATOR = \"moderator\"\n    USER = \"user\"\n    GUEST = \"guest\"\n\nclass Permission(Enum):\n    READ_USERS = \"read_users\"\n    WRITE_USERS = \"write_users\"\n    DELETE_USERS = \"delete_users\"\n    READ_POSTS = \"read_posts\"\n    WRITE_POSTS = \"write_posts\"\n    DELETE_POSTS = \"delete_posts\"\n    MODERATE_CONTENT = \"moderate_content\"\n    ADMIN_ACCESS = \"admin_access\"\n\n# Role permissions mapping\nROLE_PERMISSIONS: Dict[Role, Set[Permission]] = {\n    Role.ADMIN: {\n        Permission.READ_USERS, Permission.WRITE_USERS, Permission.DELETE_USERS,\n        Permission.READ_POSTS, Permission.WRITE_POSTS, Permission.DELETE_POSTS,\n        Permission.MODERATE_CONTENT, Permission.ADMIN_ACCESS\n    },\n    Role.MODERATOR: {\n        Permission.READ_USERS, Permission.READ_POSTS, Permission.WRITE_POSTS,\n        Permission.MODERATE_CONTENT\n    },\n    Role.USER: {\n        Permission.READ_POSTS, Permission.WRITE_POSTS\n    },\n    Role.GUEST: {\n        Permission.READ_POSTS\n    }\n}\n\n@dataclass\nclass UserRole:\n    user_id: int\n    role: Role\n\nclass RoleManager:\n    def __init__(self):\n        self.user_roles: Dict[int, Role] = {}\n\n        # Assign admin role to user ID 1\n        self.user_roles[1] = Role.ADMIN\n\n    def assign_role(self, user_id: int, role: Role):\n        \"\"\"Assign role to user\"\"\"\n        self.user_roles[user_id] = role\n\n    def get_user_role(self, user_id: int) -&gt; Role:\n        \"\"\"Get user's role\"\"\"\n        return self.user_roles.get(user_id, Role.GUEST)\n\n    def has_permission(self, user_id: int, permission: Permission) -&gt; bool:\n        \"\"\"Check if user has specific permission\"\"\"\n        role = self.get_user_role(user_id)\n        return permission in ROLE_PERMISSIONS.get(role, set())\n\n    def require_permission(self, user_id: int, permission: Permission) -&gt; bool:\n        \"\"\"Require user to have specific permission (raises exception if not)\"\"\"\n        if not self.has_permission(user_id, permission):\n            raise PermissionError(f\"Permission {permission.value} required\")\n        return True\n\n# Global role manager\nrole_manager = RoleManager()\n</code></pre></p>"},{"location":"guides/authentication/#authorization-middleware","title":"Authorization Middleware","text":"<p>extensions/auth/middleware_authorization.py: <pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\nfrom .roles import role_manager, Permission\n\nasync def authorization_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Authorization middleware for role-based access control\"\"\"\n\n    user = request.context.get('user')\n\n    # Skip authorization for unauthenticated users (handled by auth middleware)\n    if not user:\n        yield\n        return\n\n    # Define route permissions\n    route_permissions = {\n        \"/admin\": Permission.ADMIN_ACCESS,\n        \"/api/users\": Permission.READ_USERS,\n        \"/api/admin\": Permission.ADMIN_ACCESS,\n        \"/moderate\": Permission.MODERATE_CONTENT\n    }\n\n    # Check if route requires specific permission\n    required_permission = None\n    for route_path, permission in route_permissions.items():\n        if request.path.startswith(route_path):\n            required_permission = permission\n            break\n\n    if required_permission:\n        if not role_manager.has_permission(user.id, required_permission):\n            response.set_status(403)\n            if request.headers.get(\"accept\", \"\").startswith(\"application/json\"):\n                response.content_type(\"application/json\")\n                response.body('{\"error\": \"Insufficient permissions\"}')\n            else:\n                response.content_type(\"text/html\")\n                response.body(\"\"\"\n                &lt;h1&gt;Access Denied&lt;/h1&gt;\n                &lt;p&gt;You don't have permission to access this resource.&lt;/p&gt;\n                &lt;a href=\"/dashboard\"&gt;Return to Dashboard&lt;/a&gt;\n                \"\"\")\n            return\n\n    # Add role info to request context\n    request.context['role'] = role_manager.get_user_role(user.id)\n\n    yield\n</code></pre></p>"},{"location":"guides/authentication/#oauth-integration_1","title":"OAuth Integration","text":""},{"location":"guides/authentication/#oauth-provider-setup","title":"OAuth Provider Setup","text":"<p>extensions/auth/oauth.py: <pre><code>import secrets\nimport urllib.parse\nfrom typing import Dict, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass OAuthConfig:\n    client_id: str\n    client_secret: str\n    authorize_url: str\n    token_url: str\n    user_info_url: str\n    redirect_uri: str\n    scope: str\n\nclass OAuthProvider:\n    def __init__(self, config: OAuthConfig):\n        self.config = config\n        self.state_storage: Dict[str, str] = {}  # Use Redis in production\n\n    def get_authorization_url(self) -&gt; tuple[str, str]:\n        \"\"\"Generate OAuth authorization URL and state\"\"\"\n        state = secrets.token_urlsafe(32)\n\n        params = {\n            \"client_id\": self.config.client_id,\n            \"redirect_uri\": self.config.redirect_uri,\n            \"scope\": self.config.scope,\n            \"response_type\": \"code\",\n            \"state\": state\n        }\n\n        url = f\"{self.config.authorize_url}?{urllib.parse.urlencode(params)}\"\n        self.state_storage[state] = \"pending\"\n\n        return url, state\n\n    def verify_state(self, state: str) -&gt; bool:\n        \"\"\"Verify OAuth state parameter\"\"\"\n        return state in self.state_storage\n\n    async def exchange_code_for_token(self, code: str, state: str) -&gt; Optional[Dict]:\n        \"\"\"Exchange authorization code for access token\"\"\"\n        if not self.verify_state(state):\n            return None\n\n        # In a real implementation, make HTTP request to token endpoint\n        # This is a simplified example\n        return {\n            \"access_token\": \"example_token\",\n            \"token_type\": \"Bearer\",\n            \"expires_in\": 3600\n        }\n\n    async def get_user_info(self, access_token: str) -&gt; Optional[Dict]:\n        \"\"\"Get user information from OAuth provider\"\"\"\n        # In a real implementation, make HTTP request to user info endpoint\n        # This is a simplified example\n        return {\n            \"id\": \"oauth_user_123\",\n            \"email\": \"user@example.com\",\n            \"name\": \"OAuth User\"\n        }\n\n# Example GitHub OAuth configuration\ngithub_oauth = OAuthProvider(OAuthConfig(\n    client_id=\"your_github_client_id\",\n    client_secret=\"your_github_client_secret\",\n    authorize_url=\"https://github.com/login/oauth/authorize\",\n    token_url=\"https://github.com/login/oauth/access_token\",\n    user_info_url=\"https://api.github.com/user\",\n    redirect_uri=\"http://localhost:8000/auth/github/callback\",\n    scope=\"user:email\"\n))\n</code></pre></p>"},{"location":"guides/authentication/#oauth-routes","title":"OAuth Routes","text":"<p>extensions/auth/route_oauth.py: <pre><code>from serv.routes import GetRequest\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\nfrom .oauth import github_oauth\nfrom .models import user_storage\nfrom .sessions import session_manager\n\nasync def GitHubLogin(\n    request: GetRequest,\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Initiate GitHub OAuth login\"\"\"\n\n    auth_url, state = github_oauth.get_authorization_url()\n\n    # Store state in session for verification\n    response.set_cookie(\"oauth_state\", state, max_age=600, httponly=True)\n\n    # Redirect to GitHub\n    response.redirect(auth_url, status_code=302)\n\nasync def GitHubCallback(\n    request: GetRequest,\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Handle GitHub OAuth callback\"\"\"\n\n    code = request.query_params.get(\"code\")\n    state = request.query_params.get(\"state\")\n    stored_state = request.cookies.get(\"oauth_state\")\n\n    if not code or not state or state != stored_state:\n        response.set_status(400)\n        response.body(\"Invalid OAuth callback\")\n        return\n\n    # Exchange code for token\n    token_data = await github_oauth.exchange_code_for_token(code, state)\n    if not token_data:\n        response.set_status(400)\n        response.body(\"Failed to exchange code for token\")\n        return\n\n    # Get user info\n    user_info = await github_oauth.get_user_info(token_data[\"access_token\"])\n    if not user_info:\n        response.set_status(400)\n        response.body(\"Failed to get user information\")\n        return\n\n    # Find or create user\n    username = f\"github_{user_info['id']}\"\n    user = user_storage.get_user_by_username(username)\n\n    if not user:\n        # Create new user\n        user = user_storage.create_user(\n            username=username,\n            email=user_info.get(\"email\", \"\"),\n            password=secrets.token_urlsafe(32)  # Random password for OAuth users\n        )\n\n    # Create session\n    session_id = session_manager.create_session(user.id)\n\n    # Clear OAuth state cookie and set session cookie\n    response.set_cookie(\"oauth_state\", \"\", max_age=0)\n    response.set_cookie(\n        \"session_id\",\n        session_id,\n        max_age=3600,\n        httponly=True,\n        samesite=\"lax\"\n    )\n\n    # Redirect to dashboard\n    response.redirect(\"/dashboard\", status_code=302)\n</code></pre></p>"},{"location":"guides/authentication/#testing-authentication","title":"Testing Authentication","text":""},{"location":"guides/authentication/#unit-tests","title":"Unit Tests","text":"<p>tests/test_auth.py: <pre><code>import pytest\nfrom unittest.mock import Mock\nfrom extensions.auth.models import UserStorage\nfrom extensions.auth.sessions import SessionManager\nfrom extensions.auth.jwt_auth import JWTManager\n\ndef test_user_creation():\n    \"\"\"Test user creation and password hashing\"\"\"\n    storage = UserStorage()\n\n    user = storage.create_user(\"testuser\", \"test@example.com\", \"password123\")\n\n    assert user.username == \"testuser\"\n    assert user.email == \"test@example.com\"\n    assert user.password_hash != \"password123\"  # Should be hashed\n    assert storage.verify_password(user, \"password123\")\n    assert not storage.verify_password(user, \"wrongpassword\")\n\ndef test_session_management():\n    \"\"\"Test session creation and validation\"\"\"\n    manager = SessionManager(timeout_seconds=3600)\n\n    session_id = manager.create_session(user_id=1)\n    assert session_id is not None\n\n    session = manager.get_session(session_id)\n    assert session is not None\n    assert session.user_id == 1\n\n    # Test invalid session\n    invalid_session = manager.get_session(\"invalid_id\")\n    assert invalid_session is None\n\ndef test_jwt_tokens():\n    \"\"\"Test JWT token creation and verification\"\"\"\n    jwt_manager = JWTManager(\"test-secret\")\n\n    token = jwt_manager.create_token(user_id=1, username=\"testuser\")\n    assert token is not None\n\n    payload = jwt_manager.verify_token(token)\n    assert payload is not None\n    assert payload.user_id == 1\n    assert payload.username == \"testuser\"\n\n    # Test invalid token\n    invalid_payload = jwt_manager.verify_token(\"invalid.token.here\")\n    assert invalid_payload is None\n\n@pytest.mark.asyncio\nasync def test_auth_middleware():\n    \"\"\"Test authentication middleware\"\"\"\n    from extensions.auth.middleware_auth_check import auth_check_middleware\n\n    # Mock request without session\n    request = Mock()\n    request.path = \"/protected\"\n    request.cookies = {}\n    request.headers = {}\n\n    response = Mock()\n\n    middleware_gen = auth_check_middleware(request=request, response=response)\n\n    # Should not yield (stops processing)\n    with pytest.raises(StopAsyncIteration):\n        await middleware_gen.__anext__()\n\n    # Should redirect to login\n    response.redirect.assert_called_with(\"/login\", status_code=302)\n</code></pre></p>"},{"location":"guides/authentication/#integration-tests","title":"Integration Tests","text":"<p>tests/test_auth_integration.py: <pre><code>import pytest\nfrom httpx import AsyncClient\nfrom serv.app import App\n\n@pytest.mark.asyncio\nasync def test_login_flow():\n    \"\"\"Test complete login flow\"\"\"\n    app = App(dev_mode=True)\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test login page\n        response = await client.get(\"/login\")\n        assert response.status_code == 200\n        assert \"login\" in response.text.lower()\n\n        # Test login with valid credentials\n        response = await client.post(\"/login\", data={\n            \"username\": \"admin\",\n            \"password\": \"admin123\"\n        })\n        assert response.status_code == 302  # Redirect after login\n\n        # Check that session cookie was set\n        assert \"session_id\" in response.cookies\n\n@pytest.mark.asyncio\nasync def test_protected_route():\n    \"\"\"Test access to protected routes\"\"\"\n    app = App(dev_mode=True)\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test access without authentication\n        response = await client.get(\"/dashboard\")\n        assert response.status_code == 302  # Redirect to login\n\n        # Login first\n        login_response = await client.post(\"/login\", data={\n            \"username\": \"admin\",\n            \"password\": \"admin123\"\n        })\n\n        # Test access with authentication\n        response = await client.get(\"/dashboard\")\n        assert response.status_code == 200\n        assert \"dashboard\" in response.text.lower()\n\n@pytest.mark.asyncio\nasync def test_api_authentication():\n    \"\"\"Test API authentication with tokens\"\"\"\n    app = App(dev_mode=True)\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test API without token\n        response = await client.get(\"/api/user/profile\")\n        assert response.status_code == 401\n\n        # Test API with invalid token\n        response = await client.get(\n            \"/api/user/profile\",\n            headers={\"Authorization\": \"Bearer invalid_token\"}\n        )\n        assert response.status_code == 401\n\n        # Test API with valid token (would need to generate real token)\n        # This is a simplified test\n</code></pre></p>"},{"location":"guides/authentication/#best-practices","title":"Best Practices","text":""},{"location":"guides/authentication/#1-use-secure-session-management","title":"1. Use Secure Session Management","text":"<pre><code># Good: Secure session configuration\nresponse.set_cookie(\n    \"session_id\",\n    session_id,\n    max_age=3600,\n    httponly=True,      # Prevent XSS\n    secure=True,        # HTTPS only in production\n    samesite=\"lax\"      # CSRF protection\n)\n\n# Avoid: Insecure session cookies\nresponse.set_cookie(\"session_id\", session_id)\n</code></pre>"},{"location":"guides/authentication/#2-hash-passwords-properly","title":"2. Hash Passwords Properly","text":"<pre><code># Good: Use bcrypt for password hashing\nimport bcrypt\n\ndef hash_password(password: str) -&gt; str:\n    salt = bcrypt.gensalt()\n    return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')\n\ndef verify_password(password: str, hashed: str) -&gt; bool:\n    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))\n\n# Avoid: Simple hashing\nimport hashlib\ndef bad_hash(password: str) -&gt; str:\n    return hashlib.sha256(password.encode()).hexdigest()\n</code></pre>"},{"location":"guides/authentication/#3-implement-rate-limiting","title":"3. Implement Rate Limiting","text":"<pre><code># Good: Rate limit login attempts\nfrom collections import defaultdict\nimport time\n\nlogin_attempts = defaultdict(list)\n\nasync def rate_limited_login(username: str) -&gt; bool:\n    now = time.time()\n    attempts = login_attempts[username]\n\n    # Remove old attempts (older than 15 minutes)\n    attempts[:] = [t for t in attempts if now - t &lt; 900]\n\n    # Check if too many attempts\n    if len(attempts) &gt;= 5:\n        return False\n\n    attempts.append(now)\n    return True\n</code></pre>"},{"location":"guides/authentication/#4-validate-input-thoroughly","title":"4. Validate Input Thoroughly","text":"<pre><code># Good: Comprehensive input validation\ndef validate_registration_data(form_data):\n    errors = []\n\n    if not form_data.username or len(form_data.username) &lt; 3:\n        errors.append(\"Username must be at least 3 characters\")\n\n    if not re.match(r'^[a-zA-Z0-9_]+$', form_data.username):\n        errors.append(\"Username can only contain letters, numbers, and underscores\")\n\n    if not form_data.email or '@' not in form_data.email:\n        errors.append(\"Valid email address required\")\n\n    if len(form_data.password) &lt; 8:\n        errors.append(\"Password must be at least 8 characters\")\n\n    return errors\n</code></pre>"},{"location":"guides/authentication/#5-use-environment-variables-for-secrets","title":"5. Use Environment Variables for Secrets","text":"<pre><code># Good: Use environment variables\nimport os\n\nJWT_SECRET = os.getenv(\"JWT_SECRET\", \"fallback-secret-for-dev\")\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite:///app.db\")\n\n# Avoid: Hardcoded secrets\nJWT_SECRET = \"my-secret-key\"  # Never do this in production\n</code></pre>"},{"location":"guides/authentication/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/authentication/#1-plan-your-authentication-strategy","title":"1. Plan Your Authentication Strategy","text":"<p>Choose the appropriate authentication method: - Session-based for traditional web apps - JWT tokens for APIs and SPAs - OAuth for third-party integration - API keys for service-to-service communication</p>"},{"location":"guides/authentication/#2-create-authentication-extension","title":"2. Create Authentication Extension","text":"<pre><code>serv create extension --name \"Auth\"\nserv create middleware --name \"auth_check\" --extension \"auth\"\n</code></pre>"},{"location":"guides/authentication/#3-implement-user-management","title":"3. Implement User Management","text":"<p>Create user models, storage, and management functions.</p>"},{"location":"guides/authentication/#4-add-authentication-routes","title":"4. Add Authentication Routes","text":"<p>Implement login, logout, and registration routes.</p>"},{"location":"guides/authentication/#5-secure-your-application","title":"5. Secure Your Application","text":"<p>Add authentication middleware and configure security settings.</p>"},{"location":"guides/authentication/#6-test-thoroughly","title":"6. Test Thoroughly","text":"<p>Test all authentication flows, edge cases, and security scenarios.</p>"},{"location":"guides/authentication/#next-steps","title":"Next Steps","text":"<ul> <li>Forms and Validation - Secure form handling with authentication</li> <li>Database Integration - Store user data securely</li> <li>Testing - Test authentication flows</li> <li>Deployment - Deploy secure applications </li> </ul>"},{"location":"guides/database/","title":"Database Integration","text":"<p>Serv provides flexible database integration patterns that work with any database library. This guide covers how to connect to databases, manage connections, implement data models, and follow best practices for database operations in Serv applications.</p>"},{"location":"guides/database/#overview","title":"Overview","text":"<p>Serv's database integration approach:</p> <ol> <li>Extension-Based: Database connections are managed within extensions</li> <li>Dependency Injection: Database connections are injected into route handlers</li> <li>Flexible: Works with any Python database library (asyncpg, SQLAlchemy, etc.)</li> <li>Connection Pooling: Efficient connection management for production</li> <li>Transaction Support: Middleware for automatic transaction handling</li> </ol>"},{"location":"guides/database/#database-setup","title":"Database Setup","text":""},{"location":"guides/database/#creating-a-database-extension","title":"Creating a Database Extension","text":"<p>Use the CLI to create a database extension:</p> <pre><code># Create a database extension\nserv create extension --name \"Database\"\n</code></pre>"},{"location":"guides/database/#basic-database-extension-structure","title":"Basic Database Extension Structure","text":"<p>extensions/database/extension.yaml: <pre><code>name: Database\ndescription: Database connection and management\nversion: 1.0.0\nauthor: Your Name\n\nsettings:\n  database_url: \"sqlite:///app.db\"\n  pool_size: 10\n  max_overflow: 20\n</code></pre></p> <p>extensions/database/database.py: <pre><code>import asyncpg\nfrom serv.extensions import Extension\nfrom bevy import dependency\n\nclass Database(Extension):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        config = self.__extension_spec__.config\n        self.database_url = config.get(\"database_url\", \"sqlite:///app.db\")\n        self.pool_size = config.get(\"pool_size\", 10)\n        self.max_overflow = config.get(\"max_overflow\", 20)\n        self.pool = None\n\n    async def on_app_startup(self):\n        \"\"\"Initialize database connection pool\"\"\"\n        if self.database_url.startswith(\"postgresql://\"):\n            # PostgreSQL with asyncpg\n            self.pool = await asyncpg.create_pool(\n                self.database_url,\n                min_size=1,\n                max_size=self.pool_size\n            )\n            print(f\"PostgreSQL pool created: {self.database_url}\")\n        else:\n            # For SQLite or other databases, implement accordingly\n            print(f\"Database initialized: {self.database_url}\")\n\n        # Make pool available to route handlers via dependency injection\n        from serv.app import get_current_app\n        app = get_current_app()\n        app._container.instances[asyncpg.Pool] = self.pool\n\n    async def on_app_shutdown(self):\n        \"\"\"Close database connections\"\"\"\n        if self.pool:\n            await self.pool.close()\n            print(\"Database pool closed\")\n</code></pre></p>"},{"location":"guides/database/#postgresql-with-asyncpg","title":"PostgreSQL with asyncpg","text":""},{"location":"guides/database/#setup-and-configuration","title":"Setup and Configuration","text":"<p>Install asyncpg:</p> <pre><code>pip install asyncpg\n</code></pre> <p>extensions/database/database.py: <pre><code>import asyncpg\nfrom serv.extensions import Extension\nfrom bevy import dependency\nfrom typing import Optional\n\nclass PostgreSQLExtension(Extension):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        config = self.__extension_spec__.config\n        self.database_url = config.get(\"database_url\")\n        self.min_size = config.get(\"min_size\", 1)\n        self.max_size = config.get(\"max_size\", 10)\n        self.pool: Optional[asyncpg.Pool] = None\n\n    async def on_app_startup(self):\n        \"\"\"Initialize PostgreSQL connection pool\"\"\"\n        self.pool = await asyncpg.create_pool(\n            self.database_url,\n            min_size=self.min_size,\n            max_size=self.max_size,\n            command_timeout=60\n        )\n        print(f\"PostgreSQL pool created with {self.max_size} max connections\")\n\n        # Register pool for dependency injection\n        from serv.app import get_current_app\n        app = get_current_app()\n        app._container.instances[asyncpg.Pool] = self.pool\n\n        # Run database migrations\n        await self._run_migrations()\n\n    async def on_app_shutdown(self):\n        \"\"\"Close PostgreSQL connection pool\"\"\"\n        if self.pool:\n            await self.pool.close()\n            print(\"PostgreSQL pool closed\")\n\n    async def _run_migrations(self):\n        \"\"\"Run database migrations on startup\"\"\"\n        async with self.pool.acquire() as connection:\n            # Create tables if they don't exist\n            await connection.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    id SERIAL PRIMARY KEY,\n                    username VARCHAR(50) UNIQUE NOT NULL,\n                    email VARCHAR(100) UNIQUE NOT NULL,\n                    password_hash VARCHAR(255) NOT NULL,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n\n            await connection.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS posts (\n                    id SERIAL PRIMARY KEY,\n                    title VARCHAR(200) NOT NULL,\n                    content TEXT NOT NULL,\n                    author_id INTEGER REFERENCES users(id),\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n\n            print(\"Database migrations completed\")\n</code></pre></p>"},{"location":"guides/database/#using-postgresql-in-routes","title":"Using PostgreSQL in Routes","text":"<p>extensions/blog/route_posts.py: <pre><code>import asyncpg\nfrom typing import List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom serv.responses import ResponseBuilder\nfrom serv.exceptions import HTTPNotFoundException, HTTPBadRequestException\nfrom bevy import dependency\n\n@dataclass\nclass Post:\n    id: int\n    title: str\n    content: str\n    author_id: int\n    created_at: datetime\n    updated_at: datetime\n\nasync def PostList(\n    db_pool: asyncpg.Pool = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Get all posts\"\"\"\n    async with db_pool.acquire() as connection:\n        rows = await connection.fetch(\"\"\"\n            SELECT p.id, p.title, p.content, p.author_id, \n                   p.created_at, p.updated_at, u.username\n            FROM posts p\n            JOIN users u ON p.author_id = u.id\n            ORDER BY p.created_at DESC\n        \"\"\")\n\n        posts = []\n        for row in rows:\n            posts.append({\n                \"id\": row[\"id\"],\n                \"title\": row[\"title\"],\n                \"content\": row[\"content\"][:200] + \"...\" if len(row[\"content\"]) &gt; 200 else row[\"content\"],\n                \"author\": row[\"username\"],\n                \"created_at\": row[\"created_at\"].isoformat()\n            })\n\n        response.content_type(\"application/json\")\n        response.body({\"posts\": posts})\n\nasync def PostDetail(\n    post_id: str,\n    db_pool: asyncpg.Pool = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Get a specific post\"\"\"\n    try:\n        post_id_int = int(post_id)\n    except ValueError:\n        raise HTTPBadRequestException(\"Invalid post ID\")\n\n    async with db_pool.acquire() as connection:\n        row = await connection.fetchrow(\"\"\"\n            SELECT p.id, p.title, p.content, p.author_id,\n                   p.created_at, p.updated_at, u.username\n            FROM posts p\n            JOIN users u ON p.author_id = u.id\n            WHERE p.id = $1\n        \"\"\", post_id_int)\n\n        if not row:\n            raise HTTPNotFoundException(f\"Post {post_id} not found\")\n\n        post = {\n            \"id\": row[\"id\"],\n            \"title\": row[\"title\"],\n            \"content\": row[\"content\"],\n            \"author\": row[\"username\"],\n            \"created_at\": row[\"created_at\"].isoformat(),\n            \"updated_at\": row[\"updated_at\"].isoformat()\n        }\n\n        response.content_type(\"application/json\")\n        response.body(post)\n\nasync def CreatePost(\n    request: PostRequest,\n    db_pool: asyncpg.Pool = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Create a new post\"\"\"\n    form_data = await request.form()\n\n    title = form_data.get(\"title\", [\"\"])[0]\n    content = form_data.get(\"content\", [\"\"])[0]\n    author_id = int(form_data.get(\"author_id\", [\"1\"])[0])  # In real app, get from session\n\n    if not title or not content:\n        raise HTTPBadRequestException(\"Title and content are required\")\n\n    async with db_pool.acquire() as connection:\n        row = await connection.fetchrow(\"\"\"\n            INSERT INTO posts (title, content, author_id)\n            VALUES ($1, $2, $3)\n            RETURNING id, created_at\n        \"\"\", title, content, author_id)\n\n        response.content_type(\"application/json\")\n        response.body({\n            \"id\": row[\"id\"],\n            \"title\": title,\n            \"content\": content,\n            \"author_id\": author_id,\n            \"created_at\": row[\"created_at\"].isoformat()\n        })\n</code></pre></p>"},{"location":"guides/database/#sqlite-integration","title":"SQLite Integration","text":""},{"location":"guides/database/#sqlite-extension","title":"SQLite Extension","text":"<p>extensions/database/sqlite_extension.py: <pre><code>import sqlite3\nimport aiosqlite\nfrom serv.extensions import Extension\nfrom bevy import dependency\nfrom pathlib import Path\n\nclass SQLiteExtension(Extension):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        config = self.__extension_spec__.config\n        self.database_path = config.get(\"database_path\", \"app.db\")\n        self.connection = None\n\n    async def on_app_startup(self):\n        \"\"\"Initialize SQLite database\"\"\"\n        # Ensure database directory exists\n        db_path = Path(self.database_path)\n        db_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Create connection\n        self.connection = await aiosqlite.connect(self.database_path)\n\n        # Enable foreign keys\n        await self.connection.execute(\"PRAGMA foreign_keys = ON\")\n\n        # Register connection for dependency injection\n        from serv.app import get_current_app\n        app = get_current_app()\n        app._container.instances[aiosqlite.Connection] = self.connection\n\n        # Run migrations\n        await self._run_migrations()\n\n        print(f\"SQLite database initialized: {self.database_path}\")\n\n    async def on_app_shutdown(self):\n        \"\"\"Close SQLite connection\"\"\"\n        if self.connection:\n            await self.connection.close()\n            print(\"SQLite connection closed\")\n\n    async def _run_migrations(self):\n        \"\"\"Run database migrations\"\"\"\n        await self.connection.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS users (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                username TEXT UNIQUE NOT NULL,\n                email TEXT UNIQUE NOT NULL,\n                password_hash TEXT NOT NULL,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n\n        await self.connection.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS posts (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                content TEXT NOT NULL,\n                author_id INTEGER REFERENCES users(id),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n\n        await self.connection.commit()\n        print(\"SQLite migrations completed\")\n</code></pre></p>"},{"location":"guides/database/#using-sqlite-in-routes","title":"Using SQLite in Routes","text":"<p>extensions/blog/route_sqlite_posts.py: <pre><code>import aiosqlite\nfrom serv.responses import ResponseBuilder\nfrom serv.exceptions import HTTPNotFoundException, HTTPBadRequestException\nfrom bevy import dependency\n\nasync def SQLitePostList(\n    db: aiosqlite.Connection = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Get all posts from SQLite\"\"\"\n    cursor = await db.execute(\"\"\"\n        SELECT p.id, p.title, p.content, p.author_id,\n               p.created_at, u.username\n        FROM posts p\n        JOIN users u ON p.author_id = u.id\n        ORDER BY p.created_at DESC\n    \"\"\")\n\n    rows = await cursor.fetchall()\n\n    posts = []\n    for row in rows:\n        posts.append({\n            \"id\": row[0],\n            \"title\": row[1],\n            \"content\": row[2][:200] + \"...\" if len(row[2]) &gt; 200 else row[2],\n            \"author\": row[5],\n            \"created_at\": row[4]\n        })\n\n    response.content_type(\"application/json\")\n    response.body({\"posts\": posts})\n\nasync def SQLiteCreatePost(\n    request: PostRequest,\n    db: aiosqlite.Connection = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Create a new post in SQLite\"\"\"\n    form_data = await request.form()\n\n    title = form_data.get(\"title\", [\"\"])[0]\n    content = form_data.get(\"content\", [\"\"])[0]\n    author_id = int(form_data.get(\"author_id\", [\"1\"])[0])\n\n    if not title or not content:\n        raise HTTPBadRequestException(\"Title and content are required\")\n\n    cursor = await db.execute(\"\"\"\n        INSERT INTO posts (title, content, author_id)\n        VALUES (?, ?, ?)\n    \"\"\", (title, content, author_id))\n\n    await db.commit()\n\n    response.content_type(\"application/json\")\n    response.body({\n        \"id\": cursor.lastrowid,\n        \"title\": title,\n        \"content\": content,\n        \"author_id\": author_id\n    })\n</code></pre></p>"},{"location":"guides/database/#sqlalchemy-integration","title":"SQLAlchemy Integration","text":""},{"location":"guides/database/#sqlalchemy-extension","title":"SQLAlchemy Extension","text":"<p>Install SQLAlchemy:</p> <pre><code>pip install sqlalchemy[asyncio] aiopg  # For PostgreSQL\n# or\npip install sqlalchemy[asyncio] aiosqlite  # For SQLite\n</code></pre> <p>extensions/database/sqlalchemy_extension.py: <pre><code>from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\nfrom sqlalchemy import String, Text, Integer, DateTime, ForeignKey\nfrom datetime import datetime\nfrom serv.extensions import Extension\nfrom bevy import dependency\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    username: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)\n    email: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)\n    password_hash: Mapped[str] = mapped_column(String(255), nullable=False)\n    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)\n    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    posts: Mapped[list[\"Post\"]] = relationship(\"Post\", back_populates=\"author\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    title: Mapped[str] = mapped_column(String(200), nullable=False)\n    content: Mapped[str] = mapped_column(Text, nullable=False)\n    author_id: Mapped[int] = mapped_column(Integer, ForeignKey(\"users.id\"))\n    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)\n    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    author: Mapped[User] = relationship(\"User\", back_populates=\"posts\")\n\nclass SQLAlchemyExtension(Extension):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        config = self.__extension_spec__.config\n        self.database_url = config.get(\"database_url\")\n        self.engine = None\n        self.session_factory = None\n\n    async def on_app_startup(self):\n        \"\"\"Initialize SQLAlchemy engine and session factory\"\"\"\n        self.engine = create_async_engine(\n            self.database_url,\n            echo=True,  # Set to False in production\n            pool_size=10,\n            max_overflow=20\n        )\n\n        self.session_factory = async_sessionmaker(\n            self.engine,\n            class_=AsyncSession,\n            expire_on_commit=False\n        )\n\n        # Register session factory for dependency injection\n        from serv.app import get_current_app\n        app = get_current_app()\n        app._container.instances[async_sessionmaker] = self.session_factory\n\n        # Create tables\n        async with self.engine.begin() as conn:\n            await conn.run_sync(Base.metadata.create_all)\n\n        print(\"SQLAlchemy initialized\")\n\n    async def on_app_shutdown(self):\n        \"\"\"Close SQLAlchemy engine\"\"\"\n        if self.engine:\n            await self.engine.dispose()\n            print(\"SQLAlchemy engine disposed\")\n</code></pre></p>"},{"location":"guides/database/#using-sqlalchemy-in-routes","title":"Using SQLAlchemy in Routes","text":"<p>extensions/blog/route_sqlalchemy_posts.py: <pre><code>from sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession\nfrom sqlalchemy import select\nfrom serv.responses import ResponseBuilder\nfrom serv.exceptions import HTTPNotFoundException, HTTPBadRequestException\nfrom bevy import dependency\nfrom .models import User, Post\n\nasync def SQLAlchemyPostList(\n    session_factory: async_sessionmaker = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Get all posts using SQLAlchemy\"\"\"\n    async with session_factory() as session:\n        stmt = select(Post, User).join(User).order_by(Post.created_at.desc())\n        result = await session.execute(stmt)\n\n        posts = []\n        for post, user in result:\n            posts.append({\n                \"id\": post.id,\n                \"title\": post.title,\n                \"content\": post.content[:200] + \"...\" if len(post.content) &gt; 200 else post.content,\n                \"author\": user.username,\n                \"created_at\": post.created_at.isoformat()\n            })\n\n        response.content_type(\"application/json\")\n        response.body({\"posts\": posts})\n\nasync def SQLAlchemyPostDetail(\n    post_id: str,\n    session_factory: async_sessionmaker = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Get a specific post using SQLAlchemy\"\"\"\n    try:\n        post_id_int = int(post_id)\n    except ValueError:\n        raise HTTPBadRequestException(\"Invalid post ID\")\n\n    async with session_factory() as session:\n        stmt = select(Post, User).join(User).where(Post.id == post_id_int)\n        result = await session.execute(stmt)\n        row = result.first()\n\n        if not row:\n            raise HTTPNotFoundException(f\"Post {post_id} not found\")\n\n        post, user = row\n\n        response.content_type(\"application/json\")\n        response.body({\n            \"id\": post.id,\n            \"title\": post.title,\n            \"content\": post.content,\n            \"author\": user.username,\n            \"created_at\": post.created_at.isoformat(),\n            \"updated_at\": post.updated_at.isoformat()\n        })\n\nasync def SQLAlchemyCreatePost(\n    request: PostRequest,\n    session_factory: async_sessionmaker = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Create a new post using SQLAlchemy\"\"\"\n    form_data = await request.form()\n\n    title = form_data.get(\"title\", [\"\"])[0]\n    content = form_data.get(\"content\", [\"\"])[0]\n    author_id = int(form_data.get(\"author_id\", [\"1\"])[0])\n\n    if not title or not content:\n        raise HTTPBadRequestException(\"Title and content are required\")\n\n    async with session_factory() as session:\n        # Verify author exists\n        author = await session.get(User, author_id)\n        if not author:\n            raise HTTPBadRequestException(\"Invalid author ID\")\n\n        # Create new post\n        post = Post(title=title, content=content, author_id=author_id)\n        session.add(post)\n        await session.commit()\n        await session.refresh(post)\n\n        response.content_type(\"application/json\")\n        response.body({\n            \"id\": post.id,\n            \"title\": post.title,\n            \"content\": post.content,\n            \"author_id\": post.author_id,\n            \"created_at\": post.created_at.isoformat()\n        })\n</code></pre></p>"},{"location":"guides/database/#database-middleware","title":"Database Middleware","text":""},{"location":"guides/database/#transaction-middleware","title":"Transaction Middleware","text":"<p>Create middleware to automatically handle database transactions:</p> <pre><code>serv create middleware --name \"database_transaction\" --extension \"database\"\n</code></pre> <p>extensions/database/middleware_database_transaction.py: <pre><code>from typing import AsyncIterator\nimport asyncpg\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def database_transaction_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency(),\n    db_pool: asyncpg.Pool = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Wrap requests in database transactions\"\"\"\n\n    # Only use transactions for write operations\n    if request.method in [\"POST\", \"PUT\", \"DELETE\", \"PATCH\"]:\n        async with db_pool.acquire() as connection:\n            async with connection.transaction():\n                # Make connection available to route handlers\n                request.context['db_connection'] = connection\n\n                try:\n                    yield  # Process the request\n                    # Transaction commits automatically if no exception\n                except Exception:\n                    # Transaction rolls back automatically on exception\n                    raise\n    else:\n        # For read operations, just use a connection from the pool\n        async with db_pool.acquire() as connection:\n            request.context['db_connection'] = connection\n            yield\n</code></pre></p>"},{"location":"guides/database/#session-middleware-for-sqlalchemy","title":"Session Middleware for SQLAlchemy","text":"<p>extensions/database/middleware_sqlalchemy_session.py: <pre><code>from typing import AsyncIterator\nfrom sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def sqlalchemy_session_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency(),\n    session_factory: async_sessionmaker = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Provide SQLAlchemy session for each request\"\"\"\n\n    async with session_factory() as session:\n        # Make session available to route handlers\n        request.context['db_session'] = session\n\n        try:\n            yield  # Process the request\n\n            # Commit for write operations\n            if request.method in [\"POST\", \"PUT\", \"DELETE\", \"PATCH\"]:\n                await session.commit()\n\n        except Exception:\n            # Rollback on error\n            await session.rollback()\n            raise\n</code></pre></p>"},{"location":"guides/database/#data-models-and-repositories","title":"Data Models and Repositories","text":""},{"location":"guides/database/#repository-pattern","title":"Repository Pattern","text":"<p>Create repository classes for clean data access:</p> <p>extensions/blog/repositories.py: <pre><code>from typing import List, Optional\nimport asyncpg\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass Post:\n    id: Optional[int]\n    title: str\n    content: str\n    author_id: int\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n\n@dataclass\nclass User:\n    id: Optional[int]\n    username: str\n    email: str\n    password_hash: str\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n\nclass PostRepository:\n    def __init__(self, db_pool: asyncpg.Pool):\n        self.db_pool = db_pool\n\n    async def get_all(self) -&gt; List[Post]:\n        \"\"\"Get all posts\"\"\"\n        async with self.db_pool.acquire() as connection:\n            rows = await connection.fetch(\"\"\"\n                SELECT id, title, content, author_id, created_at, updated_at\n                FROM posts\n                ORDER BY created_at DESC\n            \"\"\")\n\n            return [Post(**dict(row)) for row in rows]\n\n    async def get_by_id(self, post_id: int) -&gt; Optional[Post]:\n        \"\"\"Get post by ID\"\"\"\n        async with self.db_pool.acquire() as connection:\n            row = await connection.fetchrow(\"\"\"\n                SELECT id, title, content, author_id, created_at, updated_at\n                FROM posts\n                WHERE id = $1\n            \"\"\", post_id)\n\n            return Post(**dict(row)) if row else None\n\n    async def create(self, post: Post) -&gt; Post:\n        \"\"\"Create a new post\"\"\"\n        async with self.db_pool.acquire() as connection:\n            row = await connection.fetchrow(\"\"\"\n                INSERT INTO posts (title, content, author_id)\n                VALUES ($1, $2, $3)\n                RETURNING id, created_at, updated_at\n            \"\"\", post.title, post.content, post.author_id)\n\n            post.id = row[\"id\"]\n            post.created_at = row[\"created_at\"]\n            post.updated_at = row[\"updated_at\"]\n\n            return post\n\n    async def update(self, post: Post) -&gt; Post:\n        \"\"\"Update an existing post\"\"\"\n        async with self.db_pool.acquire() as connection:\n            row = await connection.fetchrow(\"\"\"\n                UPDATE posts\n                SET title = $1, content = $2, updated_at = CURRENT_TIMESTAMP\n                WHERE id = $3\n                RETURNING updated_at\n            \"\"\", post.title, post.content, post.id)\n\n            post.updated_at = row[\"updated_at\"]\n            return post\n\n    async def delete(self, post_id: int) -&gt; bool:\n        \"\"\"Delete a post\"\"\"\n        async with self.db_pool.acquire() as connection:\n            result = await connection.execute(\"\"\"\n                DELETE FROM posts WHERE id = $1\n            \"\"\", post_id)\n\n            return result == \"DELETE 1\"\n\nclass UserRepository:\n    def __init__(self, db_pool: asyncpg.Pool):\n        self.db_pool = db_pool\n\n    async def get_by_username(self, username: str) -&gt; Optional[User]:\n        \"\"\"Get user by username\"\"\"\n        async with self.db_pool.acquire() as connection:\n            row = await connection.fetchrow(\"\"\"\n                SELECT id, username, email, password_hash, created_at, updated_at\n                FROM users\n                WHERE username = $1\n            \"\"\", username)\n\n            return User(**dict(row)) if row else None\n\n    async def create(self, user: User) -&gt; User:\n        \"\"\"Create a new user\"\"\"\n        async with self.db_pool.acquire() as connection:\n            row = await connection.fetchrow(\"\"\"\n                INSERT INTO users (username, email, password_hash)\n                VALUES ($1, $2, $3)\n                RETURNING id, created_at, updated_at\n            \"\"\", user.username, user.email, user.password_hash)\n\n            user.id = row[\"id\"]\n            user.created_at = row[\"created_at\"]\n            user.updated_at = row[\"updated_at\"]\n\n            return user\n</code></pre></p>"},{"location":"guides/database/#using-repositories-in-routes","title":"Using Repositories in Routes","text":"<p>extensions/blog/route_repository_posts.py: <pre><code>import asyncpg\nfrom serv.responses import ResponseBuilder\nfrom serv.exceptions import HTTPNotFoundException, HTTPBadRequestException\nfrom bevy import dependency\nfrom .repositories import PostRepository, Post\n\nasync def RepositoryPostList(\n    db_pool: asyncpg.Pool = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Get all posts using repository pattern\"\"\"\n    repo = PostRepository(db_pool)\n    posts = await repo.get_all()\n\n    posts_data = [\n        {\n            \"id\": post.id,\n            \"title\": post.title,\n            \"content\": post.content[:200] + \"...\" if len(post.content) &gt; 200 else post.content,\n            \"author_id\": post.author_id,\n            \"created_at\": post.created_at.isoformat() if post.created_at else None\n        }\n        for post in posts\n    ]\n\n    response.content_type(\"application/json\")\n    response.body({\"posts\": posts_data})\n\nasync def RepositoryCreatePost(\n    request: PostRequest,\n    db_pool: asyncpg.Pool = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    \"\"\"Create a new post using repository pattern\"\"\"\n    form_data = await request.form()\n\n    title = form_data.get(\"title\", [\"\"])[0]\n    content = form_data.get(\"content\", [\"\"])[0]\n    author_id = int(form_data.get(\"author_id\", [\"1\"])[0])\n\n    if not title or not content:\n        raise HTTPBadRequestException(\"Title and content are required\")\n\n    repo = PostRepository(db_pool)\n    post = Post(\n        id=None,\n        title=title,\n        content=content,\n        author_id=author_id\n    )\n\n    created_post = await repo.create(post)\n\n    response.content_type(\"application/json\")\n    response.body({\n        \"id\": created_post.id,\n        \"title\": created_post.title,\n        \"content\": created_post.content,\n        \"author_id\": created_post.author_id,\n        \"created_at\": created_post.created_at.isoformat()\n    })\n</code></pre></p>"},{"location":"guides/database/#database-migrations","title":"Database Migrations","text":""},{"location":"guides/database/#simple-migration-system","title":"Simple Migration System","text":"<p>extensions/database/migrations.py: <pre><code>import asyncpg\nfrom typing import List, Callable\nfrom dataclasses import dataclass\n\n@dataclass\nclass Migration:\n    version: str\n    description: str\n    up: Callable\n    down: Callable\n\nclass MigrationRunner:\n    def __init__(self, db_pool: asyncpg.Pool):\n        self.db_pool = db_pool\n        self.migrations: List[Migration] = []\n\n    def add_migration(self, version: str, description: str, up: Callable, down: Callable):\n        \"\"\"Add a migration\"\"\"\n        migration = Migration(version, description, up, down)\n        self.migrations.append(migration)\n\n    async def run_migrations(self):\n        \"\"\"Run all pending migrations\"\"\"\n        async with self.db_pool.acquire() as connection:\n            # Create migrations table if it doesn't exist\n            await connection.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS migrations (\n                    version VARCHAR(50) PRIMARY KEY,\n                    description TEXT,\n                    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n\n            # Get applied migrations\n            applied = await connection.fetch(\"SELECT version FROM migrations\")\n            applied_versions = {row[\"version\"] for row in applied}\n\n            # Run pending migrations\n            for migration in sorted(self.migrations, key=lambda m: m.version):\n                if migration.version not in applied_versions:\n                    print(f\"Running migration {migration.version}: {migration.description}\")\n\n                    async with connection.transaction():\n                        await migration.up(connection)\n                        await connection.execute(\"\"\"\n                            INSERT INTO migrations (version, description)\n                            VALUES ($1, $2)\n                        \"\"\", migration.version, migration.description)\n\n                    print(f\"Migration {migration.version} completed\")\n\n# Example migrations\nasync def create_users_table(connection):\n    await connection.execute(\"\"\"\n        CREATE TABLE users (\n            id SERIAL PRIMARY KEY,\n            username VARCHAR(50) UNIQUE NOT NULL,\n            email VARCHAR(100) UNIQUE NOT NULL,\n            password_hash VARCHAR(255) NOT NULL,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n    \"\"\")\n\nasync def create_posts_table(connection):\n    await connection.execute(\"\"\"\n        CREATE TABLE posts (\n            id SERIAL PRIMARY KEY,\n            title VARCHAR(200) NOT NULL,\n            content TEXT NOT NULL,\n            author_id INTEGER REFERENCES users(id),\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n    \"\"\")\n\nasync def add_posts_index(connection):\n    await connection.execute(\"\"\"\n        CREATE INDEX idx_posts_author_id ON posts(author_id);\n        CREATE INDEX idx_posts_created_at ON posts(created_at);\n    \"\"\")\n\n# Register migrations\ndef setup_migrations(runner: MigrationRunner):\n    runner.add_migration(\n        \"001\", \n        \"Create users table\", \n        create_users_table, \n        lambda conn: conn.execute(\"DROP TABLE users\")\n    )\n\n    runner.add_migration(\n        \"002\", \n        \"Create posts table\", \n        create_posts_table, \n        lambda conn: conn.execute(\"DROP TABLE posts\")\n    )\n\n    runner.add_migration(\n        \"003\", \n        \"Add posts indexes\", \n        add_posts_index, \n        lambda conn: conn.execute(\"DROP INDEX idx_posts_author_id, idx_posts_created_at\")\n    )\n</code></pre></p>"},{"location":"guides/database/#configuration-management","title":"Configuration Management","text":""},{"location":"guides/database/#environment-based-configuration","title":"Environment-Based Configuration","text":"<p>serv.config.yaml: <pre><code>site_info:\n  name: \"My Blog App\"\n  description: \"A blog built with Serv\"\n\nextensions:\n  - extension: database\n    settings:\n      database_url: \"${DATABASE_URL:postgresql://localhost/myapp}\"\n      pool_size: \"${DB_POOL_SIZE:10}\"\n      max_overflow: \"${DB_MAX_OVERFLOW:20}\"\n</code></pre></p> <p>Production configuration (serv.prod.config.yaml): <pre><code>site_info:\n  name: \"My Blog App\"\n  description: \"A blog built with Serv\"\n\nextensions:\n  - extension: database\n    settings:\n      database_url: \"${DATABASE_URL}\"\n      pool_size: 20\n      max_overflow: 40\n      ssl_mode: \"require\"\n</code></pre></p>"},{"location":"guides/database/#database-configuration-extension","title":"Database Configuration Extension","text":"<p>extensions/database/config.py: <pre><code>import os\nfrom serv.extensions import Extension\n\nclass DatabaseConfig:\n    def __init__(self, config: dict):\n        self.database_url = self._resolve_env_var(config.get(\"database_url\"))\n        self.pool_size = int(self._resolve_env_var(config.get(\"pool_size\", \"10\")))\n        self.max_overflow = int(self._resolve_env_var(config.get(\"max_overflow\", \"20\")))\n        self.ssl_mode = config.get(\"ssl_mode\", \"prefer\")\n\n    def _resolve_env_var(self, value: str) -&gt; str:\n        \"\"\"Resolve environment variables in configuration values\"\"\"\n        if isinstance(value, str) and value.startswith(\"${\") and value.endswith(\"}\"):\n            # Extract variable name and default value\n            var_spec = value[2:-1]  # Remove ${ and }\n            if \":\" in var_spec:\n                var_name, default_value = var_spec.split(\":\", 1)\n                return os.getenv(var_name, default_value)\n            else:\n                return os.getenv(var_spec, \"\")\n        return value\n</code></pre></p>"},{"location":"guides/database/#testing-with-databases","title":"Testing with Databases","text":""},{"location":"guides/database/#test-database-setup","title":"Test Database Setup","text":"<p>tests/conftest.py: <pre><code>import pytest\nimport asyncpg\nfrom serv.app import App\n\n@pytest.fixture\nasync def test_db_pool():\n    \"\"\"Create a test database pool\"\"\"\n    pool = await asyncpg.create_pool(\n        \"postgresql://localhost/test_db\",\n        min_size=1,\n        max_size=5\n    )\n\n    # Clean up tables before each test\n    async with pool.acquire() as connection:\n        await connection.execute(\"TRUNCATE TABLE posts, users RESTART IDENTITY CASCADE\")\n\n    yield pool\n\n    await pool.close()\n\n@pytest.fixture\nasync def test_app_with_db(test_db_pool):\n    \"\"\"Create test app with database\"\"\"\n    app = App(dev_mode=True)\n\n    # Override database pool\n    app._container.instances[asyncpg.Pool] = test_db_pool\n\n    return app\n</code></pre></p>"},{"location":"guides/database/#database-integration-tests","title":"Database Integration Tests","text":"<p>tests/test_database_integration.py: <pre><code>import pytest\nimport asyncpg\nfrom httpx import AsyncClient\nfrom serv.app import App\n\n@pytest.mark.asyncio\nasync def test_create_and_get_post(test_app_with_db, test_db_pool):\n    \"\"\"Test creating and retrieving a post\"\"\"\n\n    # Create a test user first\n    async with test_db_pool.acquire() as connection:\n        user_id = await connection.fetchval(\"\"\"\n            INSERT INTO users (username, email, password_hash)\n            VALUES ('testuser', 'test@example.com', 'hash')\n            RETURNING id\n        \"\"\")\n\n    async with AsyncClient(app=test_app_with_db, base_url=\"http://test\") as client:\n        # Create a post\n        response = await client.post(\"/posts\", data={\n            \"title\": \"Test Post\",\n            \"content\": \"This is a test post\",\n            \"author_id\": str(user_id)\n        })\n\n        assert response.status_code == 200\n        post_data = response.json()\n        assert post_data[\"title\"] == \"Test Post\"\n\n        # Get the post\n        response = await client.get(f\"/posts/{post_data['id']}\")\n        assert response.status_code == 200\n        retrieved_post = response.json()\n        assert retrieved_post[\"title\"] == \"Test Post\"\n        assert retrieved_post[\"content\"] == \"This is a test post\"\n\n@pytest.mark.asyncio\nasync def test_repository_pattern(test_db_pool):\n    \"\"\"Test repository pattern\"\"\"\n    from extensions.blog.repositories import PostRepository, Post\n\n    repo = PostRepository(test_db_pool)\n\n    # Create a test user\n    async with test_db_pool.acquire() as connection:\n        user_id = await connection.fetchval(\"\"\"\n            INSERT INTO users (username, email, password_hash)\n            VALUES ('testuser', 'test@example.com', 'hash')\n            RETURNING id\n        \"\"\")\n\n    # Create a post using repository\n    post = Post(\n        id=None,\n        title=\"Repository Test\",\n        content=\"Testing repository pattern\",\n        author_id=user_id\n    )\n\n    created_post = await repo.create(post)\n    assert created_post.id is not None\n    assert created_post.title == \"Repository Test\"\n\n    # Get the post\n    retrieved_post = await repo.get_by_id(created_post.id)\n    assert retrieved_post is not None\n    assert retrieved_post.title == \"Repository Test\"\n</code></pre></p>"},{"location":"guides/database/#best-practices","title":"Best Practices","text":""},{"location":"guides/database/#1-use-connection-pooling","title":"1. Use Connection Pooling","text":"<pre><code># Good: Use connection pools for production\nself.pool = await asyncpg.create_pool(\n    self.database_url,\n    min_size=1,\n    max_size=10\n)\n\n# Avoid: Single connections for production apps\nself.connection = await asyncpg.connect(self.database_url)\n</code></pre>"},{"location":"guides/database/#2-handle-database-errors-gracefully","title":"2. Handle Database Errors Gracefully","text":"<pre><code># Good: Proper error handling\nasync def CreatePost(request, db_pool = dependency()):\n    try:\n        async with db_pool.acquire() as connection:\n            # Database operations\n            pass\n    except asyncpg.UniqueViolationError:\n        raise HTTPBadRequestException(\"Post title already exists\")\n    except asyncpg.ForeignKeyViolationError:\n        raise HTTPBadRequestException(\"Invalid author ID\")\n    except Exception as e:\n        logger.error(f\"Database error: {e}\")\n        raise HTTPInternalServerError(\"Database operation failed\")\n</code></pre>"},{"location":"guides/database/#3-use-transactions-for-data-consistency","title":"3. Use Transactions for Data Consistency","text":"<pre><code># Good: Use transactions for related operations\nasync with connection.transaction():\n    user_id = await connection.fetchval(\n        \"INSERT INTO users (...) VALUES (...) RETURNING id\"\n    )\n    await connection.execute(\n        \"INSERT INTO user_profiles (user_id, ...) VALUES ($1, ...)\",\n        user_id\n    )\n</code></pre>"},{"location":"guides/database/#4-validate-input-before-database-operations","title":"4. Validate Input Before Database Operations","text":"<pre><code># Good: Validate before database operations\nif not title or len(title) &gt; 200:\n    raise HTTPBadRequestException(\"Title must be 1-200 characters\")\n\nif not content or len(content) &gt; 10000:\n    raise HTTPBadRequestException(\"Content must be 1-10000 characters\")\n\n# Then proceed with database operations\n</code></pre>"},{"location":"guides/database/#5-use-repository-pattern-for-complex-applications","title":"5. Use Repository Pattern for Complex Applications","text":"<pre><code># Good: Repository pattern for clean separation\nclass PostService:\n    def __init__(self, post_repo: PostRepository, user_repo: UserRepository):\n        self.post_repo = post_repo\n        self.user_repo = user_repo\n\n    async def create_post(self, title: str, content: str, author_id: int) -&gt; Post:\n        # Validate author exists\n        author = await self.user_repo.get_by_id(author_id)\n        if not author:\n            raise ValueError(\"Author not found\")\n\n        # Create post\n        return await self.post_repo.create(Post(\n            id=None, title=title, content=content, author_id=author_id\n        ))\n</code></pre>"},{"location":"guides/database/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/database/#1-plan-your-database-schema","title":"1. Plan Your Database Schema","text":"<p>Design your database schema before implementing: - Identify entities and relationships - Plan indexes for performance - Consider data constraints and validation</p>"},{"location":"guides/database/#2-create-database-extension","title":"2. Create Database Extension","text":"<pre><code>serv create extension --name \"Database\"\n</code></pre>"},{"location":"guides/database/#3-implement-models-and-repositories","title":"3. Implement Models and Repositories","text":"<p>Create data models and repository classes for clean data access.</p>"},{"location":"guides/database/#4-add-database-middleware","title":"4. Add Database Middleware","text":"<p>Implement middleware for transaction management and connection handling.</p>"},{"location":"guides/database/#5-write-tests","title":"5. Write Tests","text":"<p>Create comprehensive tests for database operations and edge cases.</p>"},{"location":"guides/database/#6-set-up-migrations","title":"6. Set Up Migrations","text":"<p>Implement a migration system for schema changes.</p>"},{"location":"guides/database/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication - Secure your database with user authentication</li> <li>Testing - Advanced testing techniques for database operations</li> <li>Deployment - Deploy applications with database connections</li> <li>Performance - Optimize database performance </li> </ul>"},{"location":"guides/dependency-injection/","title":"Dependency Injection","text":"<p>Serv uses the powerful <code>bevy</code> library for dependency injection, making your code clean, testable, and maintainable. This guide covers everything you need to know about dependency injection in Serv.</p>"},{"location":"guides/dependency-injection/#what-is-dependency-injection","title":"What is Dependency Injection?","text":"<p>Dependency injection (DI) is a design pattern where objects receive their dependencies from external sources rather than creating them internally. This makes code more modular, testable, and flexible.</p>"},{"location":"guides/dependency-injection/#without-di-tightly-coupled","title":"Without DI (tightly coupled)","text":"<pre><code>class UserService:\n    def __init__(self):\n        self.db = Database()  # Hard dependency\n\n    def get_user(self, user_id: int):\n        return self.db.query(f\"SELECT * FROM users WHERE id = {user_id}\")\n</code></pre>"},{"location":"guides/dependency-injection/#with-di-loosely-coupled","title":"With DI (loosely coupled)","text":"<pre><code>class UserService:\n    def __init__(self, db: Database):\n        self.db = db  # Injected dependency\n\n    def get_user(self, user_id: int):\n        return self.db.query(f\"SELECT * FROM users WHERE id = {user_id}\")\n</code></pre>"},{"location":"guides/dependency-injection/#basic-dependency-injection","title":"Basic Dependency Injection","text":""},{"location":"guides/dependency-injection/#using-dependency","title":"Using <code>dependency()</code>","text":"<p>The simplest way to inject dependencies in Serv is using the <code>dependency()</code> function:</p> <pre><code>from serv.responses import ResponseBuilder\nfrom serv.requests import Request\nfrom bevy import dependency\n\nasync def my_handler(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    response.content_type(\"text/plain\")\n    response.body(f\"Hello from {request.path}\")\n</code></pre>"},{"location":"guides/dependency-injection/#built-in-dependencies","title":"Built-in Dependencies","text":"<p>Serv automatically provides several built-in dependencies:</p> <pre><code>from serv import App\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom serv.extensions.routing import Router\nfrom bevy import dependency, Container\n\nasync def handler_with_all_deps(\n    request: Request = dependency(),           # Current request\n    response: ResponseBuilder = dependency(),  # Response builder\n    router: Router = dependency(),            # Current router\n    container: Container = dependency(),      # DI container\n    app: App = dependency()                   # Application instance\n):\n    # Use all the dependencies\n    pass\n</code></pre>"},{"location":"guides/dependency-injection/#custom-dependencies","title":"Custom Dependencies","text":""},{"location":"guides/dependency-injection/#registering-services","title":"Registering Services","text":"<p>Register your own services in the DI container:</p> <pre><code>from bevy import dependency\n\nclass DatabaseService:\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n\n    def query(self, sql: str):\n        # Database query implementation\n        pass\n\nclass MyExtension(Extension):\n    async def on_app_startup(self, container: Container = dependency()):\n        # Register the database service\n        db_service = DatabaseService(\"postgresql://localhost/mydb\")\n        container.instances[DatabaseService] = db_service\n\n    async def on_app_request_begin(self, router: Router = dependency()):\n        router.add_route(\"/users\", self.list_users)\n\n    async def list_users(\n        self,\n        db: DatabaseService = dependency(),\n        response: ResponseBuilder = dependency()\n    ):\n        users = db.query(\"SELECT * FROM users\")\n        response.content_type(\"application/json\")\n        response.body(json.dumps(users))\n</code></pre>"},{"location":"guides/dependency-injection/#factory-functions","title":"Factory Functions","text":"<p>Use factory functions for complex object creation:</p> <pre><code>from bevy import dependency\n\ndef create_email_service(config: dict) -&gt; EmailService:\n    return EmailService(\n        smtp_host=config.get('smtp_host'),\n        smtp_port=config.get('smtp_port'),\n        username=config.get('smtp_user'),\n        password=config.get('smtp_password')\n    )\n\nclass EmailExtension(Extension):\n    async def on_app_startup(self, container: Container = dependency()):\n        config = self.get_config()\n        email_service = create_email_service(config)\n        container.instances[EmailService] = email_service\n</code></pre>"},{"location":"guides/dependency-injection/#advanced-dependency-injection","title":"Advanced Dependency Injection","text":""},{"location":"guides/dependency-injection/#interface-based-dependencies","title":"Interface-Based Dependencies","text":"<p>Use abstract base classes for better testability:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass UserRepository(ABC):\n    @abstractmethod\n    async def get_user(self, user_id: int) -&gt; User:\n        pass\n\n    @abstractmethod\n    async def create_user(self, user_data: dict) -&gt; User:\n        pass\n\nclass DatabaseUserRepository(UserRepository):\n    def __init__(self, db: Database):\n        self.db = db\n\n    async def get_user(self, user_id: int) -&gt; User:\n        # Database implementation\n        pass\n\n    async def create_user(self, user_data: dict) -&gt; User:\n        # Database implementation\n        pass\n\nclass InMemoryUserRepository(UserRepository):\n    def __init__(self):\n        self.users = {}\n\n    async def get_user(self, user_id: int) -&gt; User:\n        # In-memory implementation\n        pass\n\n    async def create_user(self, user_data: dict) -&gt; User:\n        # In-memory implementation\n        pass\n\n# Register the implementation\nclass UserExtension(Extension):\n    async def on_app_startup(self, container: Container = dependency()):\n        # Use database implementation in production\n        db = container.get(Database)\n        user_repo = DatabaseUserRepository(db)\n        container.instances[UserRepository] = user_repo\n</code></pre>"},{"location":"guides/dependency-injection/#conditional-dependencies","title":"Conditional Dependencies","text":"<p>Register different implementations based on configuration:</p> <pre><code>class StorageExtension(Extension):\n    async def on_app_startup(self, container: Container = dependency()):\n        config = self.get_config()\n        storage_type = config.get('storage_type', 'local')\n\n        if storage_type == 'local':\n            storage = LocalFileStorage(config.get('local_path', './uploads'))\n        elif storage_type == 's3':\n            storage = S3Storage(\n                bucket=config.get('s3_bucket'),\n                access_key=config.get('s3_access_key'),\n                secret_key=config.get('s3_secret_key')\n            )\n        else:\n            raise ValueError(f\"Unknown storage type: {storage_type}\")\n\n        container.instances[FileStorage] = storage\n</code></pre>"},{"location":"guides/dependency-injection/#scoped-dependencies","title":"Scoped Dependencies","text":"<p>Create request-scoped dependencies that are unique per request:</p> <pre><code>class RequestScopedService:\n    def __init__(self, request_id: str):\n        self.request_id = request_id\n        self.data = {}\n\n    def store(self, key: str, value: any):\n        self.data[key] = value\n\n    def get(self, key: str):\n        return self.data.get(key)\n\nclass ScopedExtension(Extension):\n    async def on_app_request_begin(\n        self,\n        container: Container = dependency(),\n        request: Request = dependency()\n    ):\n        # Create a request-scoped service\n        request_id = request.headers.get('X-Request-ID', str(uuid.uuid4()))\n        scoped_service = RequestScopedService(request_id)\n        container.instances[RequestScopedService] = scoped_service\n</code></pre>"},{"location":"guides/dependency-injection/#dependency-injection-in-different-contexts","title":"Dependency Injection in Different Contexts","text":""},{"location":"guides/dependency-injection/#in-route-handlers","title":"In Route Handlers","text":"<pre><code>async def user_handler(\n    user_id: str,\n    user_service: UserService = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    user = await user_service.get_user(int(user_id))\n    if user:\n        response.content_type(\"application/json\")\n        response.body(json.dumps(user.to_dict()))\n    else:\n        response.set_status(404)\n        response.body(\"User not found\")\n</code></pre>"},{"location":"guides/dependency-injection/#in-class-based-routes","title":"In Class-Based Routes","text":"<pre><code>from serv.routes import Route\n\nclass UserRoute(Route):\n    async def get_user(\n        self,\n        request: GetRequest,\n        user_service: UserService = dependency(),\n        response: ResponseBuilder = dependency()\n    ):\n        user_id = request.path_params.get('user_id')\n        user = await user_service.get_user(int(user_id))\n        # Handle response...\n\n    async def create_user(\n        self,\n        form: CreateUserForm,\n        user_service: UserService = dependency(),\n        response: ResponseBuilder = dependency()\n    ):\n        user = await user_service.create_user(form.to_dict())\n        # Handle response...\n</code></pre>"},{"location":"guides/dependency-injection/#in-middleware","title":"In Middleware","text":"<pre><code>from typing import AsyncIterator\n\nasync def auth_middleware(\n    request: Request = dependency(),\n    auth_service: AuthService = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    # Check authentication before request\n    token = request.headers.get('Authorization')\n    if not token or not auth_service.validate_token(token):\n        response.set_status(401)\n        response.body(\"Unauthorized\")\n        return\n\n    # Set current user in request context\n    user = auth_service.get_user_from_token(token)\n    request.context['current_user'] = user\n\n    yield  # Process the request\n\n    # Cleanup after request if needed\n</code></pre>"},{"location":"guides/dependency-injection/#in-extension-event-handlers","title":"In Extension Event Handlers","text":"<pre><code>class MyExtension(Extension):\n    async def on_app_startup(\n        self,\n        container: Container = dependency(),\n        app: App = dependency()\n    ):\n        # Initialize services\n        config = self.get_config()\n        service = MyService(config)\n        container.instances[MyService] = service\n\n    async def on_app_request_begin(\n        self,\n        router: Router = dependency(),\n        my_service: MyService = dependency()\n    ):\n        # Use the service to configure routes\n        if my_service.is_enabled():\n            router.add_route(\"/my-route\", self.my_handler)\n</code></pre>"},{"location":"guides/dependency-injection/#testing-with-dependency-injection","title":"Testing with Dependency Injection","text":""},{"location":"guides/dependency-injection/#mocking-dependencies","title":"Mocking Dependencies","text":"<p>DI makes testing much easier by allowing you to mock dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom bevy import Container\n\n@pytest.mark.asyncio\nasync def test_user_handler():\n    # Create mocks\n    mock_user_service = Mock(spec=UserService)\n    mock_user_service.get_user = AsyncMock(return_value=User(id=1, name=\"John\"))\n\n    mock_response = Mock(spec=ResponseBuilder)\n\n    # Create container with mocked dependencies\n    container = Container()\n    container.instances[UserService] = mock_user_service\n    container.instances[ResponseBuilder] = mock_response\n\n    # Test the handler\n    await container.call(user_handler, user_id=\"1\")\n\n    # Verify interactions\n    mock_user_service.get_user.assert_called_once_with(1)\n    mock_response.content_type.assert_called_once_with(\"application/json\")\n</code></pre>"},{"location":"guides/dependency-injection/#test-fixtures","title":"Test Fixtures","text":"<p>Create reusable test fixtures:</p> <pre><code>@pytest.fixture\ndef mock_user_service():\n    service = Mock(spec=UserService)\n    service.get_user = AsyncMock()\n    service.create_user = AsyncMock()\n    return service\n\n@pytest.fixture\ndef test_container(mock_user_service):\n    container = Container()\n    container.instances[UserService] = mock_user_service\n    return container\n\n@pytest.mark.asyncio\nasync def test_create_user(test_container, mock_user_service):\n    mock_user_service.create_user.return_value = User(id=1, name=\"John\")\n\n    # Test using the container\n    result = await test_container.call(create_user_handler, user_data={\"name\": \"John\"})\n\n    assert result is not None\n    mock_user_service.create_user.assert_called_once()\n</code></pre>"},{"location":"guides/dependency-injection/#best-practices","title":"Best Practices","text":""},{"location":"guides/dependency-injection/#1-use-type-hints","title":"1. Use Type Hints","text":"<p>Always use type hints for better IDE support and clarity:</p> <pre><code>async def handler(\n    user_service: UserService = dependency(),  # Clear type\n    response: ResponseBuilder = dependency()\n) -&gt; None:  # Clear return type\n    pass\n</code></pre>"},{"location":"guides/dependency-injection/#2-prefer-interfaces","title":"2. Prefer Interfaces","text":"<p>Use abstract base classes for better testability:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass EmailService(ABC):\n    @abstractmethod\n    async def send_email(self, to: str, subject: str, body: str) -&gt; bool:\n        pass\n\nclass SMTPEmailService(EmailService):\n    async def send_email(self, to: str, subject: str, body: str) -&gt; bool:\n        # SMTP implementation\n        pass\n\nclass MockEmailService(EmailService):\n    async def send_email(self, to: str, subject: str, body: str) -&gt; bool:\n        # Mock implementation for testing\n        return True\n</code></pre>"},{"location":"guides/dependency-injection/#3-register-dependencies-early","title":"3. Register Dependencies Early","text":"<p>Register dependencies during application startup:</p> <pre><code>class MyExtension(Extension):\n    async def on_app_startup(self, container: Container = dependency()):\n        # Register all services early\n        container.instances[UserService] = UserService()\n        container.instances[EmailService] = SMTPEmailService()\n        container.instances[CacheService] = RedisCache()\n</code></pre>"},{"location":"guides/dependency-injection/#4-avoid-circular-dependencies","title":"4. Avoid Circular Dependencies","text":"<p>Be careful about circular dependencies:</p> <pre><code># Bad: Circular dependency\nclass UserService:\n    def __init__(self, order_service: OrderService):\n        self.order_service = order_service\n\nclass OrderService:\n    def __init__(self, user_service: UserService):\n        self.user_service = user_service\n\n# Good: Use events or interfaces to break the cycle\nclass UserService:\n    def __init__(self, event_bus: EventBus):\n        self.event_bus = event_bus\n\n    def create_user(self, user_data):\n        user = User(**user_data)\n        self.event_bus.emit('user.created', user)\n        return user\n\nclass OrderService:\n    def __init__(self, event_bus: EventBus):\n        self.event_bus = event_bus\n        self.event_bus.subscribe('user.created', self.on_user_created)\n\n    def on_user_created(self, user):\n        # Handle user creation\n        pass\n</code></pre>"},{"location":"guides/dependency-injection/#5-use-factory-functions-for-complex-setup","title":"5. Use Factory Functions for Complex Setup","text":"<p>For complex object creation, use factory functions:</p> <pre><code>def create_database_service(config: dict) -&gt; DatabaseService:\n    connection_pool = create_connection_pool(\n        host=config['db_host'],\n        port=config['db_port'],\n        database=config['db_name'],\n        username=config['db_user'],\n        password=config['db_password'],\n        pool_size=config.get('db_pool_size', 10)\n    )\n\n    return DatabaseService(connection_pool)\n\nclass DatabaseExtension(Extension):\n    async def on_app_startup(self, container: Container = dependency()):\n        config = self.get_config()\n        db_service = create_database_service(config)\n        container.instances[DatabaseService] = db_service\n</code></pre>"},{"location":"guides/dependency-injection/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/dependency-injection/#service-locator-pattern","title":"Service Locator Pattern","text":"<p>Sometimes you need to access the container directly:</p> <pre><code>from bevy import dependency\n\nclass ServiceLocator:\n    def __init__(self, container: Container):\n        self.container = container\n\n    def get_service(self, service_type: type):\n        return self.container.get(service_type)\n\nclass MyExtension(Extension):\n    async def on_app_startup(self, container: Container = dependency()):\n        locator = ServiceLocator(container)\n        container.instances[ServiceLocator] = locator\n</code></pre>"},{"location":"guides/dependency-injection/#configuration-injection","title":"Configuration Injection","text":"<p>Inject configuration objects:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass DatabaseConfig:\n    host: str\n    port: int\n    database: str\n    username: str\n    password: str\n\nclass DatabaseExtension(Extension):\n    async def on_app_startup(self, container: Container = dependency()):\n        config_dict = self.get_config()\n        db_config = DatabaseConfig(**config_dict)\n        container.instances[DatabaseConfig] = db_config\n\n        # Use config to create service\n        db_service = DatabaseService(db_config)\n        container.instances[DatabaseService] = db_service\n\nasync def handler(\n    db_config: DatabaseConfig = dependency(),\n    response: ResponseBuilder = dependency()\n):\n    response.body(f\"Connected to {db_config.host}:{db_config.port}\")\n</code></pre>"},{"location":"guides/dependency-injection/#next-steps","title":"Next Steps","text":"<ul> <li>Extensions - Learn how to create extensions that use DI</li> <li>Middleware - Use DI in middleware</li> <li>Testing - Test code that uses dependency injection</li> <li>Routing - Use DI in route handlers </li> </ul>"},{"location":"guides/deployment/","title":"Deployment","text":"<p>Deploying Serv applications to production requires careful consideration of server configuration, environment setup, security, and monitoring. This guide covers everything you need to know about deploying Serv applications effectively.</p>"},{"location":"guides/deployment/#overview","title":"Overview","text":"<p>Serv deployment considerations:</p> <ol> <li>ASGI Servers: Choose the right ASGI server for your needs</li> <li>Environment Configuration: Manage settings across environments</li> <li>Containerization: Docker and container orchestration</li> <li>Security: SSL/TLS, secrets management, and security headers</li> <li>Performance: Optimization and scaling strategies</li> <li>Monitoring: Logging, metrics, and health checks</li> </ol>"},{"location":"guides/deployment/#asgi-servers","title":"ASGI Servers","text":"<p>Serv is an ASGI framework that integrates tightly with uvicorn. The App class must be instantiated within a running asyncio event loop, which makes uvicorn the preferred deployment option.</p>"},{"location":"guides/deployment/#serv-cli-recommended","title":"Serv CLI (Recommended)","text":"<p>The easiest way to deploy Serv applications is using the built-in CLI commands:</p> <pre><code># Production deployment\nserv launch --host 0.0.0.0 --port 8000 --workers 4\n\n# Development server\nserv --dev launch --host 0.0.0.0 --port 8000\n\n# Test configuration before deployment\nserv launch --dry-run\n\n# Custom configuration\nserv launch --config config/production.yaml --host 0.0.0.0 --port 8000 --workers 4\n</code></pre>"},{"location":"guides/deployment/#uvicorn-direct-usage","title":"Uvicorn Direct Usage","text":"<p>Important: Serv's App class must be instantiated within a running asyncio event loop. This means you cannot use uvicorn's CLI directly with a pre-instantiated App object. Instead, you must use an application factory pattern:</p> <pre><code># main.py - Application factory for uvicorn\nimport asyncio\nfrom serv.app import App\n\ndef create_app():\n    \"\"\"Application factory that creates the app within the event loop\"\"\"\n    # This function will be called by uvicorn within the event loop\n    app = App(\n        config=\"config/production.yaml\",\n        extension_dir=\"./extensions\",\n        dev_mode=False\n    )\n    return app\n\n# For uvicorn, use the factory\napp = create_app\n</code></pre> <pre><code># Install Uvicorn\npip install uvicorn[standard]\n\n# Use the factory function (note the lack of parentheses)\nuvicorn main:app --host 0.0.0.0 --port 8000 --factory\n\n# With workers for better performance\nuvicorn main:app --host 0.0.0.0 --port 8000 --workers 4 --factory\n\n# With SSL\nuvicorn main:app --host 0.0.0.0 --port 8000 --ssl-keyfile key.pem --ssl-certfile cert.pem --factory\n</code></pre> <p>Note: The <code>--factory</code> flag tells uvicorn to call the function to create the app instance rather than importing a pre-created instance.</p>"},{"location":"guides/deployment/#gunicorn-with-uvicorn-workers","title":"Gunicorn with Uvicorn Workers","text":"<p>For production deployments, use Gunicorn with Uvicorn workers:</p> <pre><code># Install Gunicorn\npip install gunicorn\n\n# Run with Uvicorn workers\ngunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000\n\n# With configuration file\ngunicorn main:app -c gunicorn.conf.py\n</code></pre> <p>gunicorn.conf.py: <pre><code># Gunicorn configuration for production\n\n# Server socket\nbind = \"0.0.0.0:8000\"\nbacklog = 2048\n\n# Worker processes\nworkers = 4\nworker_class = \"uvicorn.workers.UvicornWorker\"\nworker_connections = 1000\nmax_requests = 1000\nmax_requests_jitter = 50\npreload_app = True\n\n# Restart workers after this many requests, to help prevent memory leaks\nmax_requests = 1200\nmax_requests_jitter = 50\n\n# Timeout for graceful workers restart\ntimeout = 30\nkeepalive = 2\n\n# Logging\naccesslog = \"-\"\nerrorlog = \"-\"\nloglevel = \"info\"\naccess_log_format = '%(h)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\" %(D)s'\n\n# Process naming\nproc_name = \"serv_app\"\n\n# Server mechanics\ndaemon = False\npidfile = \"/tmp/gunicorn.pid\"\nuser = None\ngroup = None\ntmp_upload_dir = None\n\n# SSL\nkeyfile = None\ncertfile = None\n</code></pre></p>"},{"location":"guides/deployment/#hypercorn","title":"Hypercorn","text":"<p>Alternative ASGI server with HTTP/2 support:</p> <pre><code># Install Hypercorn\npip install hypercorn\n\n# Basic run\nhypercorn main:app --bind 0.0.0.0:8000\n\n# With workers\nhypercorn main:app --bind 0.0.0.0:8000 --workers 4\n\n# With HTTP/2\nhypercorn main:app --bind 0.0.0.0:8000 --http2\n</code></pre>"},{"location":"guides/deployment/#application-configuration","title":"Application Configuration","text":""},{"location":"guides/deployment/#production-app-setup","title":"Production App Setup","text":"<p>main.py: <pre><code>import os\nfrom serv.app import App\n\ndef create_app():\n    \"\"\"Application factory for production deployment.\"\"\"\n\n    # Determine environment\n    environment = os.getenv(\"ENVIRONMENT\", \"production\")\n\n    # Load appropriate configuration\n    config_file = f\"config/{environment}.yaml\"\n\n    # Create app with production settings\n    app = App(\n        config=config_file,\n        extension_dir=\"./extensions\",\n        dev_mode=environment == \"development\"\n    )\n\n    return app\n\n# Export the factory function for ASGI servers\napp = create_app\n\n# For development server\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        \"main:app\",\n        host=\"127.0.0.1\",\n        port=8000,\n        reload=True,\n        factory=True\n    )\n</code></pre></p>"},{"location":"guides/deployment/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>config/production.yaml: <pre><code>site:\n  name: \"My Production App\"\n  description: \"Production deployment\"\n  debug: false\n\ndatabase:\n  url: \"${DATABASE_URL}\"\n  pool_size: 20\n  max_overflow: 30\n\nredis:\n  url: \"${REDIS_URL}\"\n  max_connections: 50\n\nsecurity:\n  secret_key: \"${SECRET_KEY}\"\n  allowed_hosts:\n    - \"myapp.com\"\n    - \"www.myapp.com\"\n  cors_origins:\n    - \"https://myapp.com\"\n    - \"https://www.myapp.com\"\n\nlogging:\n  level: \"INFO\"\n  format: \"json\"\n  handlers:\n    - \"console\"\n    - \"file\"\n\nextensions:\n  - name: \"auth\"\n    enabled: true\n    config:\n      session_timeout: 3600\n      jwt_secret: \"${JWT_SECRET}\"\n\n  - name: \"database\"\n    enabled: true\n    config:\n      database_url: \"${DATABASE_URL}\"\n\n  - name: \"monitoring\"\n    enabled: true\n    config:\n      metrics_endpoint: \"/metrics\"\n      health_endpoint: \"/health\"\n</code></pre></p> <p>config/staging.yaml: <pre><code>site:\n  name: \"My Staging App\"\n  description: \"Staging environment\"\n  debug: true\n\ndatabase:\n  url: \"${STAGING_DATABASE_URL}\"\n  pool_size: 10\n  max_overflow: 20\n\nredis:\n  url: \"${STAGING_REDIS_URL}\"\n  max_connections: 25\n\nsecurity:\n  secret_key: \"${STAGING_SECRET_KEY}\"\n  allowed_hosts:\n    - \"staging.myapp.com\"\n  cors_origins:\n    - \"https://staging.myapp.com\"\n\nlogging:\n  level: \"DEBUG\"\n  format: \"text\"\n  handlers:\n    - \"console\"\n\nextensions:\n  - name: \"auth\"\n    enabled: true\n    config:\n      session_timeout: 1800\n      jwt_secret: \"${STAGING_JWT_SECRET}\"\n\n  - name: \"database\"\n    enabled: true\n    config:\n      database_url: \"${STAGING_DATABASE_URL}\"\n</code></pre></p>"},{"location":"guides/deployment/#environment-variables","title":"Environment Variables","text":"<p>.env.production: <pre><code># Environment\nENVIRONMENT=production\n\n# Database\nDATABASE_URL=postgresql://user:password@db.example.com:5432/myapp\nREDIS_URL=redis://redis.example.com:6379/0\n\n# Security\nSECRET_KEY=your-super-secret-key-change-this\nJWT_SECRET=your-jwt-secret-key\n\n# External Services\nSMTP_HOST=smtp.example.com\nSMTP_PORT=587\nSMTP_USER=noreply@myapp.com\nSMTP_PASSWORD=smtp-password\n\n# Monitoring\nSENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id\n\n# Feature Flags\nENABLE_ANALYTICS=true\nENABLE_CACHING=true\n</code></pre></p>"},{"location":"guides/deployment/#containerization","title":"Containerization","text":""},{"location":"guides/deployment/#docker-setup","title":"Docker Setup","text":"<p>Dockerfile: <pre><code># Use Python 3.13 slim image\nFROM python:3.13-slim\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1 \\\n    PYTHONUNBUFFERED=1 \\\n    PYTHONPATH=/app \\\n    PORT=8000\n\n# Set work directory\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update \\\n    &amp;&amp; apt-get install -y --no-install-recommends \\\n        build-essential \\\n        curl \\\n        libpq-dev \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install Python dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY . .\n\n# Create non-root user\nRUN adduser --disabled-password --gecos '' appuser \\\n    &amp;&amp; chown -R appuser:appuser /app\nUSER appuser\n\n# Expose port\nEXPOSE $PORT\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:$PORT/health || exit 1\n\n# Run the application\nCMD [\"sh\", \"-c\", \"gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:$PORT\"]\n</code></pre></p> <p>requirements.txt: <pre><code>getserving&gt;=0.1.0\nuvicorn[standard]&gt;=0.34.0\ngunicorn&gt;=23.0.0\npsycopg2-binary&gt;=2.9.0\nredis&gt;=5.0.0\npython-multipart&gt;=0.0.20\njinja2&gt;=3.1.0\npyyaml&gt;=6.0.0\nhttpx&gt;=0.28.0\n</code></pre></p> <p>docker-compose.yml: <pre><code>version: '3.8'\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - ENVIRONMENT=production\n      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp\n      - REDIS_URL=redis://redis:6379/0\n    depends_on:\n      - db\n      - redis\n    volumes:\n      - ./logs:/app/logs\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  db:\n    image: postgres:16\n    environment:\n      - POSTGRES_DB=myapp\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./init.sql:/docker-entrypoint-initdb.d/init.sql\n    restart: unless-stopped\n\n  redis:\n    image: redis:7-alpine\n    volumes:\n      - redis_data:/data\n    restart: unless-stopped\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n      - ./ssl:/etc/nginx/ssl\n    depends_on:\n      - app\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:\n  redis_data:\n</code></pre></p>"},{"location":"guides/deployment/#multi-stage-docker-build","title":"Multi-stage Docker Build","text":"<p>Dockerfile.multistage: <pre><code># Build stage\nFROM python:3.13-slim as builder\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1 \\\n    PYTHONUNBUFFERED=1\n\n# Install build dependencies\nRUN apt-get update \\\n    &amp;&amp; apt-get install -y --no-install-recommends \\\n        build-essential \\\n        libpq-dev \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install Python dependencies\nCOPY requirements.txt .\nRUN pip install --user --no-cache-dir -r requirements.txt\n\n# Production stage\nFROM python:3.13-slim\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1 \\\n    PYTHONUNBUFFERED=1 \\\n    PYTHONPATH=/app \\\n    PATH=/home/appuser/.local/bin:$PATH \\\n    PORT=8000\n\n# Install runtime dependencies\nRUN apt-get update \\\n    &amp;&amp; apt-get install -y --no-install-recommends \\\n        libpq5 \\\n        curl \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Create non-root user\nRUN adduser --disabled-password --gecos '' appuser\n\n# Copy Python dependencies from builder stage\nCOPY --from=builder /root/.local /home/appuser/.local\n\n# Set work directory\nWORKDIR /app\n\n# Copy application code\nCOPY --chown=appuser:appuser . .\n\n# Switch to non-root user\nUSER appuser\n\n# Expose port\nEXPOSE $PORT\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:$PORT/health || exit 1\n\n# Run the application\nCMD [\"sh\", \"-c\", \"gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:$PORT\"]\n</code></pre></p>"},{"location":"guides/deployment/#reverse-proxy-configuration","title":"Reverse Proxy Configuration","text":""},{"location":"guides/deployment/#nginx-configuration","title":"Nginx Configuration","text":"<p>nginx.conf: <pre><code>events {\n    worker_connections 1024;\n}\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    # Logging\n    log_format main '$remote_addr - $remote_user [$time_local] \"$request\" '\n                    '$status $body_bytes_sent \"$http_referer\" '\n                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log /var/log/nginx/access.log main;\n    error_log /var/log/nginx/error.log;\n\n    # Basic settings\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    keepalive_timeout 65;\n    types_hash_max_size 2048;\n    client_max_body_size 100M;\n\n    # Gzip compression\n    gzip on;\n    gzip_vary on;\n    gzip_min_length 1024;\n    gzip_proxied any;\n    gzip_comp_level 6;\n    gzip_types\n        text/plain\n        text/css\n        text/xml\n        text/javascript\n        application/json\n        application/javascript\n        application/xml+rss\n        application/atom+xml\n        image/svg+xml;\n\n    # Rate limiting\n    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;\n    limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m;\n\n    # Upstream servers\n    upstream app_servers {\n        least_conn;\n        server app:8000 max_fails=3 fail_timeout=30s;\n        # Add more servers for load balancing\n        # server app2:8000 max_fails=3 fail_timeout=30s;\n        # server app3:8000 max_fails=3 fail_timeout=30s;\n    }\n\n    # HTTP to HTTPS redirect\n    server {\n        listen 80;\n        server_name myapp.com www.myapp.com;\n        return 301 https://$server_name$request_uri;\n    }\n\n    # HTTPS server\n    server {\n        listen 443 ssl http2;\n        server_name myapp.com www.myapp.com;\n\n        # SSL configuration\n        ssl_certificate /etc/nginx/ssl/cert.pem;\n        ssl_certificate_key /etc/nginx/ssl/key.pem;\n        ssl_protocols TLSv1.2 TLSv1.3;\n        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;\n        ssl_prefer_server_ciphers off;\n        ssl_session_cache shared:SSL:10m;\n        ssl_session_timeout 10m;\n\n        # Security headers\n        add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n        add_header X-Content-Type-Options nosniff always;\n        add_header X-Frame-Options DENY always;\n        add_header X-XSS-Protection \"1; mode=block\" always;\n        add_header Referrer-Policy \"strict-origin-when-cross-origin\" always;\n\n        # Static files\n        location /static/ {\n            alias /app/static/;\n            expires 1y;\n            add_header Cache-Control \"public, immutable\";\n        }\n\n        # API rate limiting\n        location /api/ {\n            limit_req zone=api burst=20 nodelay;\n            proxy_pass http://app_servers;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_set_header X-Forwarded-Host $host;\n            proxy_set_header X-Forwarded-Port $server_port;\n        }\n\n        # Login rate limiting\n        location /login {\n            limit_req zone=login burst=5 nodelay;\n            proxy_pass http://app_servers;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n        }\n\n        # Health check\n        location /health {\n            proxy_pass http://app_servers;\n            access_log off;\n        }\n\n        # Main application\n        location / {\n            proxy_pass http://app_servers;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_set_header X-Forwarded-Host $host;\n            proxy_set_header X-Forwarded-Port $server_port;\n\n            # WebSocket support\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n\n            # Timeouts\n            proxy_connect_timeout 60s;\n            proxy_send_timeout 60s;\n            proxy_read_timeout 60s;\n        }\n    }\n}\n</code></pre></p>"},{"location":"guides/deployment/#apache-configuration","title":"Apache Configuration","text":"<p>apache.conf: <pre><code>&lt;VirtualHost *:80&gt;\n    ServerName myapp.com\n    ServerAlias www.myapp.com\n    Redirect permanent / https://myapp.com/\n&lt;/VirtualHost&gt;\n\n&lt;VirtualHost *:443&gt;\n    ServerName myapp.com\n    ServerAlias www.myapp.com\n\n    # SSL Configuration\n    SSLEngine on\n    SSLCertificateFile /etc/ssl/certs/cert.pem\n    SSLCertificateKeyFile /etc/ssl/private/key.pem\n    SSLProtocol all -SSLv3 -TLSv1 -TLSv1.1\n    SSLCipherSuite ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\n\n    # Security Headers\n    Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains\"\n    Header always set X-Content-Type-Options nosniff\n    Header always set X-Frame-Options DENY\n    Header always set X-XSS-Protection \"1; mode=block\"\n\n    # Static files\n    Alias /static /app/static\n    &lt;Directory \"/app/static\"&gt;\n        Require all granted\n        ExpiresActive On\n        ExpiresDefault \"access plus 1 year\"\n    &lt;/Directory&gt;\n\n    # Proxy to application\n    ProxyPreserveHost On\n    ProxyPass /static !\n    ProxyPass / http://localhost:8000/\n    ProxyPassReverse / http://localhost:8000/\n\n    # Set headers for the backend\n    ProxyPassReverse / http://localhost:8000/\n    ProxyPreserveHost On\n    RequestHeader set X-Forwarded-Proto \"https\"\n    RequestHeader set X-Forwarded-Port \"443\"\n&lt;/VirtualHost&gt;\n</code></pre></p>"},{"location":"guides/deployment/#security-configuration","title":"Security Configuration","text":""},{"location":"guides/deployment/#ssltls-setup","title":"SSL/TLS Setup","text":"<p>Generate SSL certificates with Let's Encrypt: <pre><code># Install Certbot\nsudo apt-get install certbot python3-certbot-nginx\n\n# Generate certificate\nsudo certbot --nginx -d myapp.com -d www.myapp.com\n\n# Auto-renewal\nsudo crontab -e\n# Add: 0 12 * * * /usr/bin/certbot renew --quiet\n</code></pre></p>"},{"location":"guides/deployment/#security-extension","title":"Security Extension","text":"<p>extensions/security/security_extension.py: <pre><code>from serv.extensions import Extension\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\nfrom typing import AsyncIterator\n\nclass SecurityExtension(Extension):\n    \"\"\"Security extension for production deployments.\"\"\"\n\n    async def on_app_startup(self):\n        \"\"\"Initialize security settings.\"\"\"\n        config = self.__extension_spec__.config\n        self.allowed_hosts = config.get(\"allowed_hosts\", [])\n        self.cors_origins = config.get(\"cors_origins\", [])\n        self.force_https = config.get(\"force_https\", True)\n\n    async def on_app_request_begin(self, router):\n        \"\"\"Add security middleware.\"\"\"\n        router.add_middleware(self.security_middleware)\n\n    async def security_middleware(\n        self,\n        request: Request = dependency(),\n        response: ResponseBuilder = dependency()\n    ) -&gt; AsyncIterator[None]:\n        \"\"\"Security middleware for production.\"\"\"\n\n        # Check allowed hosts\n        host = request.headers.get(\"host\", \"\")\n        if self.allowed_hosts and host not in self.allowed_hosts:\n            response.set_status(400)\n            response.body(\"Invalid host\")\n            return\n\n        # Force HTTPS in production\n        if self.force_https and request.headers.get(\"x-forwarded-proto\") != \"https\":\n            if request.method == \"GET\":\n                https_url = f\"https://{host}{request.path}\"\n                if request.query_string:\n                    https_url += f\"?{request.query_string}\"\n                response.redirect(https_url, status_code=301)\n                return\n            else:\n                response.set_status(400)\n                response.body(\"HTTPS required\")\n                return\n\n        # Add security headers\n        response.add_header(\"X-Content-Type-Options\", \"nosniff\")\n        response.add_header(\"X-Frame-Options\", \"DENY\")\n        response.add_header(\"X-XSS-Protection\", \"1; mode=block\")\n        response.add_header(\"Referrer-Policy\", \"strict-origin-when-cross-origin\")\n\n        if self.force_https:\n            response.add_header(\n                \"Strict-Transport-Security\", \n                \"max-age=31536000; includeSubDomains\"\n            )\n\n        # CORS headers\n        origin = request.headers.get(\"origin\")\n        if origin and origin in self.cors_origins:\n            response.add_header(\"Access-Control-Allow-Origin\", origin)\n            response.add_header(\"Access-Control-Allow-Credentials\", \"true\")\n            response.add_header(\n                \"Access-Control-Allow-Methods\", \n                \"GET, POST, PUT, DELETE, OPTIONS\"\n            )\n            response.add_header(\n                \"Access-Control-Allow-Headers\",\n                \"Content-Type, Authorization, X-Requested-With\"\n            )\n\n        yield\n</code></pre></p>"},{"location":"guides/deployment/#secrets-management","title":"Secrets Management","text":"<p>extensions/secrets/secrets_extension.py: <pre><code>import os\nimport json\nfrom serv.extensions import Extension\n\nclass SecretsExtension(Extension):\n    \"\"\"Manage secrets from various sources.\"\"\"\n\n    async def on_app_startup(self):\n        \"\"\"Load secrets from environment or external services.\"\"\"\n        config = self.__extension_spec__.config\n\n        # Load from environment variables\n        self.secrets = {}\n        for key in config.get(\"env_secrets\", []):\n            value = os.getenv(key)\n            if value:\n                self.secrets[key] = value\n\n        # Load from file (for Docker secrets)\n        secrets_file = config.get(\"secrets_file\")\n        if secrets_file and os.path.exists(secrets_file):\n            with open(secrets_file) as f:\n                file_secrets = json.load(f)\n                self.secrets.update(file_secrets)\n\n        # Load from external service (AWS Secrets Manager, etc.)\n        await self._load_external_secrets(config)\n\n        # Register secrets for dependency injection\n        from serv.app import get_current_app\n        app = get_current_app()\n        app._container.instances[dict] = self.secrets\n\n    async def _load_external_secrets(self, config):\n        \"\"\"Load secrets from external services.\"\"\"\n        # Example: AWS Secrets Manager\n        aws_config = config.get(\"aws_secrets\")\n        if aws_config:\n            try:\n                import boto3\n                client = boto3.client(\"secretsmanager\")\n\n                for secret_name in aws_config.get(\"secret_names\", []):\n                    response = client.get_secret_value(SecretId=secret_name)\n                    secret_data = json.loads(response[\"SecretString\"])\n                    self.secrets.update(secret_data)\n            except ImportError:\n                print(\"boto3 not installed, skipping AWS secrets\")\n            except Exception as e:\n                print(f\"Error loading AWS secrets: {e}\")\n</code></pre></p>"},{"location":"guides/deployment/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"guides/deployment/#health-check-extension","title":"Health Check Extension","text":"<p>extensions/monitoring/monitoring_extension.py: <pre><code>import time\nimport psutil\nfrom serv.extensions import Extension\nfrom serv.routes import GetRequest\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nclass MonitoringExtension(Extension):\n    \"\"\"Monitoring and health check extension.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.start_time = time.time()\n\n    async def on_app_request_begin(self, router):\n        \"\"\"Add monitoring routes.\"\"\"\n        config = self.__extension_spec__.config\n\n        health_endpoint = config.get(\"health_endpoint\", \"/health\")\n        metrics_endpoint = config.get(\"metrics_endpoint\", \"/metrics\")\n\n        router.add_route(health_endpoint, self.health_check, methods=[\"GET\"])\n        router.add_route(metrics_endpoint, self.metrics, methods=[\"GET\"])\n\n    async def health_check(\n        self,\n        request: GetRequest,\n        response: ResponseBuilder = dependency()\n    ):\n        \"\"\"Health check endpoint.\"\"\"\n\n        # Basic health check\n        health_data = {\n            \"status\": \"healthy\",\n            \"timestamp\": time.time(),\n            \"uptime\": time.time() - self.start_time,\n            \"version\": \"1.0.0\"\n        }\n\n        # Check database connection\n        try:\n            # Add your database health check here\n            health_data[\"database\"] = \"healthy\"\n        except Exception as e:\n            health_data[\"database\"] = f\"unhealthy: {str(e)}\"\n            health_data[\"status\"] = \"unhealthy\"\n            response.set_status(503)\n\n        # Check Redis connection\n        try:\n            # Add your Redis health check here\n            health_data[\"redis\"] = \"healthy\"\n        except Exception as e:\n            health_data[\"redis\"] = f\"unhealthy: {str(e)}\"\n            health_data[\"status\"] = \"unhealthy\"\n            response.set_status(503)\n\n        response.content_type(\"application/json\")\n        response.body(health_data)\n\n    async def metrics(\n        self,\n        request: GetRequest,\n        response: ResponseBuilder = dependency()\n    ):\n        \"\"\"Metrics endpoint for monitoring.\"\"\"\n\n        # System metrics\n        cpu_percent = psutil.cpu_percent()\n        memory = psutil.virtual_memory()\n        disk = psutil.disk_usage('/')\n\n        metrics_data = {\n            \"system\": {\n                \"cpu_percent\": cpu_percent,\n                \"memory_percent\": memory.percent,\n                \"memory_available\": memory.available,\n                \"disk_percent\": (disk.used / disk.total) * 100,\n                \"disk_free\": disk.free\n            },\n            \"application\": {\n                \"uptime\": time.time() - self.start_time,\n                \"timestamp\": time.time()\n            }\n        }\n\n        response.content_type(\"application/json\")\n        response.body(metrics_data)\n</code></pre></p>"},{"location":"guides/deployment/#structured-logging","title":"Structured Logging","text":"<p>extensions/logging/logging_extension.py: <pre><code>import logging\nimport json\nimport sys\nfrom datetime import datetime\nfrom serv.extensions import Extension\n\nclass JSONFormatter(logging.Formatter):\n    \"\"\"JSON formatter for structured logging.\"\"\"\n\n    def format(self, record):\n        log_entry = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"level\": record.levelname,\n            \"logger\": record.name,\n            \"message\": record.getMessage(),\n            \"module\": record.module,\n            \"function\": record.funcName,\n            \"line\": record.lineno\n        }\n\n        # Add exception info if present\n        if record.exc_info:\n            log_entry[\"exception\"] = self.formatException(record.exc_info)\n\n        # Add extra fields\n        for key, value in record.__dict__.items():\n            if key not in [\"name\", \"msg\", \"args\", \"levelname\", \"levelno\", \n                          \"pathname\", \"filename\", \"module\", \"lineno\", \n                          \"funcName\", \"created\", \"msecs\", \"relativeCreated\", \n                          \"thread\", \"threadName\", \"processName\", \"process\",\n                          \"getMessage\", \"exc_info\", \"exc_text\", \"stack_info\"]:\n                log_entry[key] = value\n\n        return json.dumps(log_entry)\n\nclass LoggingExtension(Extension):\n    \"\"\"Configure structured logging for production.\"\"\"\n\n    async def on_app_startup(self):\n        \"\"\"Configure logging.\"\"\"\n        config = self.__extension_spec__.config\n\n        # Get configuration\n        log_level = config.get(\"level\", \"INFO\")\n        log_format = config.get(\"format\", \"text\")\n        handlers = config.get(\"handlers\", [\"console\"])\n\n        # Configure root logger\n        root_logger = logging.getLogger()\n        root_logger.setLevel(getattr(logging, log_level))\n\n        # Clear existing handlers\n        root_logger.handlers.clear()\n\n        # Add configured handlers\n        for handler_name in handlers:\n            if handler_name == \"console\":\n                handler = logging.StreamHandler(sys.stdout)\n            elif handler_name == \"file\":\n                handler = logging.FileHandler(\"app.log\")\n            else:\n                continue\n\n            # Set formatter\n            if log_format == \"json\":\n                formatter = JSONFormatter()\n            else:\n                formatter = logging.Formatter(\n                    \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n                )\n\n            handler.setFormatter(formatter)\n            root_logger.addHandler(handler)\n\n        # Configure specific loggers\n        logging.getLogger(\"uvicorn.access\").setLevel(logging.INFO)\n        logging.getLogger(\"uvicorn.error\").setLevel(logging.INFO)\n</code></pre></p>"},{"location":"guides/deployment/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guides/deployment/#caching-extension","title":"Caching Extension","text":"<p>extensions/caching/caching_extension.py: <pre><code>import redis\nimport json\nimport hashlib\nfrom typing import Any, Optional\nfrom serv.extensions import Extension\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\nfrom typing import AsyncIterator\n\nclass CachingExtension(Extension):\n    \"\"\"Redis-based caching extension.\"\"\"\n\n    async def on_app_startup(self):\n        \"\"\"Initialize Redis connection.\"\"\"\n        config = self.__extension_spec__.config\n        redis_url = config.get(\"redis_url\", \"redis://localhost:6379/0\")\n\n        self.redis_client = redis.from_url(redis_url)\n        self.default_ttl = config.get(\"default_ttl\", 300)  # 5 minutes\n        self.cache_prefix = config.get(\"cache_prefix\", \"serv_cache:\")\n\n        # Register for dependency injection\n        from serv.app import get_current_app\n        app = get_current_app()\n        app._container.instances[redis.Redis] = self.redis_client\n\n    async def on_app_shutdown(self):\n        \"\"\"Close Redis connection.\"\"\"\n        if hasattr(self, 'redis_client'):\n            await self.redis_client.aclose()\n\n    def cache_key(self, request: Request) -&gt; str:\n        \"\"\"Generate cache key for request.\"\"\"\n        key_data = f\"{request.method}:{request.path}:{request.query_string}\"\n        key_hash = hashlib.md5(key_data.encode()).hexdigest()\n        return f\"{self.cache_prefix}{key_hash}\"\n\n    async def get_cached_response(self, request: Request) -&gt; Optional[dict]:\n        \"\"\"Get cached response for request.\"\"\"\n        cache_key = self.cache_key(request)\n\n        try:\n            cached_data = await self.redis_client.get(cache_key)\n            if cached_data:\n                return json.loads(cached_data)\n        except Exception as e:\n            print(f\"Cache get error: {e}\")\n\n        return None\n\n    async def set_cached_response(\n        self, \n        request: Request, \n        response_data: dict, \n        ttl: Optional[int] = None\n    ):\n        \"\"\"Cache response for request.\"\"\"\n        cache_key = self.cache_key(request)\n        ttl = ttl or self.default_ttl\n\n        try:\n            await self.redis_client.setex(\n                cache_key, \n                ttl, \n                json.dumps(response_data)\n            )\n        except Exception as e:\n            print(f\"Cache set error: {e}\")\n\n    async def cache_middleware(\n        self,\n        request: Request = dependency(),\n        response: ResponseBuilder = dependency()\n    ) -&gt; AsyncIterator[None]:\n        \"\"\"Caching middleware.\"\"\"\n\n        # Only cache GET requests\n        if request.method != \"GET\":\n            yield\n            return\n\n        # Check for cached response\n        cached_response = await self.get_cached_response(request)\n        if cached_response:\n            response.set_status(cached_response[\"status\"])\n            for header, value in cached_response[\"headers\"].items():\n                response.add_header(header, value)\n            response.body(cached_response[\"body\"])\n            return\n\n        # Process request\n        yield\n\n        # Cache successful responses\n        if 200 &lt;= response._status &lt; 300:\n            response_data = {\n                \"status\": response._status,\n                \"headers\": dict(response._headers),\n                \"body\": response._body_components[0] if response._body_components else \"\"\n            }\n            await self.set_cached_response(request, response_data)\n</code></pre></p>"},{"location":"guides/deployment/#database-connection-pooling","title":"Database Connection Pooling","text":"<p>extensions/database/database_extension.py: <pre><code>import asyncpg\nfrom typing import Optional\nfrom serv.extensions import Extension\n\nclass DatabaseExtension(Extension):\n    \"\"\"Database connection pooling extension.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.pool: Optional[asyncpg.Pool] = None\n\n    async def on_app_startup(self):\n        \"\"\"Initialize database connection pool.\"\"\"\n        config = self.__extension_spec__.config\n\n        database_url = config.get(\"database_url\")\n        min_size = config.get(\"min_size\", 5)\n        max_size = config.get(\"max_size\", 20)\n\n        self.pool = await asyncpg.create_pool(\n            database_url,\n            min_size=min_size,\n            max_size=max_size,\n            command_timeout=60,\n            server_settings={\n                'jit': 'off'  # Disable JIT for better connection pool performance\n            }\n        )\n\n        print(f\"Database pool created: {min_size}-{max_size} connections\")\n\n        # Register pool for dependency injection\n        from serv.app import get_current_app\n        app = get_current_app()\n        app._container.instances[asyncpg.Pool] = self.pool\n\n    async def on_app_shutdown(self):\n        \"\"\"Close database connection pool.\"\"\"\n        if self.pool:\n            await self.pool.close()\n            print(\"Database pool closed\")\n</code></pre></p>"},{"location":"guides/deployment/#cloud-deployment","title":"Cloud Deployment","text":""},{"location":"guides/deployment/#aws-deployment","title":"AWS Deployment","text":"<p>deploy/aws/ecs-task-definition.json: <pre><code>{\n  \"family\": \"serv-app\",\n  \"networkMode\": \"awsvpc\",\n  \"requiresCompatibilities\": [\"FARGATE\"],\n  \"cpu\": \"512\",\n  \"memory\": \"1024\",\n  \"executionRoleArn\": \"arn:aws:iam::ACCOUNT:role/ecsTaskExecutionRole\",\n  \"taskRoleArn\": \"arn:aws:iam::ACCOUNT:role/ecsTaskRole\",\n  \"containerDefinitions\": [\n    {\n      \"name\": \"serv-app\",\n      \"image\": \"your-account.dkr.ecr.region.amazonaws.com/serv-app:latest\",\n      \"portMappings\": [\n        {\n          \"containerPort\": 8000,\n          \"protocol\": \"tcp\"\n        }\n      ],\n      \"environment\": [\n        {\n          \"name\": \"ENVIRONMENT\",\n          \"value\": \"production\"\n        }\n      ],\n      \"secrets\": [\n        {\n          \"name\": \"DATABASE_URL\",\n          \"valueFrom\": \"arn:aws:secretsmanager:region:account:secret:prod/database-url\"\n        },\n        {\n          \"name\": \"SECRET_KEY\",\n          \"valueFrom\": \"arn:aws:secretsmanager:region:account:secret:prod/secret-key\"\n        }\n      ],\n      \"logConfiguration\": {\n        \"logDriver\": \"awslogs\",\n        \"options\": {\n          \"awslogs-group\": \"/ecs/serv-app\",\n          \"awslogs-region\": \"us-west-2\",\n          \"awslogs-stream-prefix\": \"ecs\"\n        }\n      },\n      \"healthCheck\": {\n        \"command\": [\"CMD-SHELL\", \"curl -f http://localhost:8000/health || exit 1\"],\n        \"interval\": 30,\n        \"timeout\": 5,\n        \"retries\": 3,\n        \"startPeriod\": 60\n      }\n    }\n  ]\n}\n</code></pre></p> <p>deploy/aws/cloudformation.yaml: <pre><code>AWSTemplateFormatVersion: '2010-09-09'\nDescription: 'Serv Application Infrastructure'\n\nParameters:\n  Environment:\n    Type: String\n    Default: production\n    AllowedValues: [development, staging, production]\n\n  ImageTag:\n    Type: String\n    Default: latest\n\nResources:\n  # VPC and Networking\n  VPC:\n    Type: AWS::EC2::VPC\n    Properties:\n      CidrBlock: 10.0.0.0/16\n      EnableDnsHostnames: true\n      EnableDnsSupport: true\n      Tags:\n        - Key: Name\n          Value: !Sub '${Environment}-serv-vpc'\n\n  PublicSubnet1:\n    Type: AWS::EC2::Subnet\n    Properties:\n      VpcId: !Ref VPC\n      CidrBlock: 10.0.1.0/24\n      AvailabilityZone: !Select [0, !GetAZs '']\n      MapPublicIpOnLaunch: true\n\n  PublicSubnet2:\n    Type: AWS::EC2::Subnet\n    Properties:\n      VpcId: !Ref VPC\n      CidrBlock: 10.0.2.0/24\n      AvailabilityZone: !Select [1, !GetAZs '']\n      MapPublicIpOnLaunch: true\n\n  # ECS Cluster\n  ECSCluster:\n    Type: AWS::ECS::Cluster\n    Properties:\n      ClusterName: !Sub '${Environment}-serv-cluster'\n      CapacityProviders:\n        - FARGATE\n        - FARGATE_SPOT\n\n  # Application Load Balancer\n  ALB:\n    Type: AWS::ElasticLoadBalancingV2::LoadBalancer\n    Properties:\n      Name: !Sub '${Environment}-serv-alb'\n      Scheme: internet-facing\n      Type: application\n      Subnets:\n        - !Ref PublicSubnet1\n        - !Ref PublicSubnet2\n      SecurityGroups:\n        - !Ref ALBSecurityGroup\n\n  # ECS Service\n  ECSService:\n    Type: AWS::ECS::Service\n    Properties:\n      ServiceName: !Sub '${Environment}-serv-service'\n      Cluster: !Ref ECSCluster\n      TaskDefinition: !Ref ECSTaskDefinition\n      DesiredCount: 2\n      LaunchType: FARGATE\n      NetworkConfiguration:\n        AwsvpcConfiguration:\n          SecurityGroups:\n            - !Ref AppSecurityGroup\n          Subnets:\n            - !Ref PublicSubnet1\n            - !Ref PublicSubnet2\n          AssignPublicIp: ENABLED\n      LoadBalancers:\n        - ContainerName: serv-app\n          ContainerPort: 8000\n          TargetGroupArn: !Ref ALBTargetGroup\n\n  # RDS Database\n  DBSubnetGroup:\n    Type: AWS::RDS::DBSubnetGroup\n    Properties:\n      DBSubnetGroupDescription: Subnet group for RDS database\n      SubnetIds:\n        - !Ref PublicSubnet1\n        - !Ref PublicSubnet2\n\n  Database:\n    Type: AWS::RDS::DBInstance\n    Properties:\n      DBInstanceIdentifier: !Sub '${Environment}-serv-db'\n      DBInstanceClass: db.t3.micro\n      Engine: postgres\n      EngineVersion: '16.1'\n      AllocatedStorage: 20\n      StorageType: gp2\n      DBName: servapp\n      MasterUsername: postgres\n      MasterUserPassword: !Ref DatabasePassword\n      DBSubnetGroupName: !Ref DBSubnetGroup\n      VPCSecurityGroups:\n        - !Ref DatabaseSecurityGroup\n\nOutputs:\n  LoadBalancerDNS:\n    Description: DNS name of the load balancer\n    Value: !GetAtt ALB.DNSName\n    Export:\n      Name: !Sub '${Environment}-serv-alb-dns'\n</code></pre></p>"},{"location":"guides/deployment/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<p>k8s/deployment.yaml: <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: serv-app\n  labels:\n    app: serv-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: serv-app\n  template:\n    metadata:\n      labels:\n        app: serv-app\n    spec:\n      containers:\n      - name: serv-app\n        image: your-registry/serv-app:latest\n        ports:\n        - containerPort: 8000\n        env:\n        - name: ENVIRONMENT\n          value: \"production\"\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: serv-secrets\n              key: database-url\n        - name: SECRET_KEY\n          valueFrom:\n            secretKeyRef:\n              name: serv-secrets\n              key: secret-key\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: serv-app-service\nspec:\n  selector:\n    app: serv-app\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8000\n  type: ClusterIP\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: serv-app-ingress\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n    nginx.ingress.kubernetes.io/rate-limit: \"100\"\nspec:\n  tls:\n  - hosts:\n    - myapp.com\n    secretName: serv-app-tls\n  rules:\n  - host: myapp.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: serv-app-service\n            port:\n              number: 80\n</code></pre></p>"},{"location":"guides/deployment/#deployment-scripts","title":"Deployment Scripts","text":""},{"location":"guides/deployment/#automated-deployment-script","title":"Automated Deployment Script","text":"<p>deploy.sh: <pre><code>#!/bin/bash\n\nset -e\n\n# Configuration\nENVIRONMENT=${1:-production}\nIMAGE_TAG=${2:-latest}\nREGISTRY=\"your-registry.com\"\nAPP_NAME=\"serv-app\"\n\necho \"\ud83d\ude80 Deploying $APP_NAME to $ENVIRONMENT environment\"\n\n# Build and push Docker image\necho \"\ud83d\udce6 Building Docker image...\"\ndocker build -t $REGISTRY/$APP_NAME:$IMAGE_TAG .\n\necho \"\ud83d\udce4 Pushing Docker image...\"\ndocker push $REGISTRY/$APP_NAME:$IMAGE_TAG\n\n# Deploy based on environment\ncase $ENVIRONMENT in\n  \"production\")\n    echo \"\ud83c\udf10 Deploying to production...\"\n    # Update ECS service\n    aws ecs update-service \\\n      --cluster production-serv-cluster \\\n      --service production-serv-service \\\n      --force-new-deployment\n    ;;\n\n  \"staging\")\n    echo \"\ud83e\uddea Deploying to staging...\"\n    # Update staging environment\n    kubectl set image deployment/serv-app-staging \\\n      serv-app=$REGISTRY/$APP_NAME:$IMAGE_TAG\n    ;;\n\n  \"development\")\n    echo \"\ud83d\udd27 Deploying to development...\"\n    docker-compose -f docker-compose.dev.yml up -d\n    ;;\n\n  *)\n    echo \"\u274c Unknown environment: $ENVIRONMENT\"\n    exit 1\n    ;;\nesac\n\necho \"\u2705 Deployment completed successfully!\"\n\n# Health check\necho \"\ud83c\udfe5 Performing health check...\"\nsleep 30\n\ncase $ENVIRONMENT in\n  \"production\")\n    HEALTH_URL=\"https://myapp.com/health\"\n    ;;\n  \"staging\")\n    HEALTH_URL=\"https://staging.myapp.com/health\"\n    ;;\n  \"development\")\n    HEALTH_URL=\"http://localhost:8000/health\"\n    ;;\nesac\n\nif curl -f $HEALTH_URL &gt; /dev/null 2&gt;&amp;1; then\n  echo \"\u2705 Health check passed!\"\nelse\n  echo \"\u274c Health check failed!\"\n  exit 1\nfi\n</code></pre></p>"},{"location":"guides/deployment/#cicd-pipeline-github-actions","title":"CI/CD Pipeline (GitHub Actions)","text":"<p>.github/workflows/deploy.yml: <pre><code>name: Deploy Serv Application\n\non:\n  push:\n    branches: [main, staging, develop]\n  pull_request:\n    branches: [main]\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.13'\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n        pip install pytest pytest-asyncio\n\n    - name: Run tests\n      run: pytest\n\n    - name: Run linting\n      run: |\n        pip install ruff\n        ruff check .\n\n  build:\n    needs: test\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v4\n\n    - name: Log in to Container Registry\n      uses: docker/login-action@v3\n      with:\n        registry: ${{ env.REGISTRY }}\n        username: ${{ github.actor }}\n        password: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Extract metadata\n      id: meta\n      uses: docker/metadata-action@v5\n      with:\n        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n        tags: |\n          type=ref,event=branch\n          type=ref,event=pr\n          type=sha\n\n    - name: Build and push Docker image\n      uses: docker/build-push-action@v5\n      with:\n        context: .\n        push: true\n        tags: ${{ steps.meta.outputs.tags }}\n        labels: ${{ steps.meta.outputs.labels }}\n\n  deploy-staging:\n    if: github.ref == 'refs/heads/staging'\n    needs: build\n    runs-on: ubuntu-latest\n    environment: staging\n\n    steps:\n    - name: Deploy to staging\n      run: |\n        echo \"Deploying to staging environment\"\n        # Add your staging deployment commands here\n\n  deploy-production:\n    if: github.ref == 'refs/heads/main'\n    needs: build\n    runs-on: ubuntu-latest\n    environment: production\n\n    steps:\n    - name: Deploy to production\n      run: |\n        echo \"Deploying to production environment\"\n        # Add your production deployment commands here\n</code></pre></p>"},{"location":"guides/deployment/#best-practices","title":"Best Practices","text":""},{"location":"guides/deployment/#1-environment-separation","title":"1. Environment Separation","text":"<pre><code># Good: Separate configurations for each environment\nconfig/\n\u251c\u2500\u2500 development.yaml\n\u251c\u2500\u2500 staging.yaml\n\u251c\u2500\u2500 production.yaml\n\u2514\u2500\u2500 testing.yaml\n\n# Avoid: Single configuration file with environment variables\n</code></pre>"},{"location":"guides/deployment/#2-security-hardening","title":"2. Security Hardening","text":"<pre><code># Good: Security-focused configuration\n- Use HTTPS in production\n- Set secure headers\n- Validate all inputs\n- Use secrets management\n- Regular security updates\n\n# Avoid: Development settings in production\n</code></pre>"},{"location":"guides/deployment/#3-monitoring-and-alerting","title":"3. Monitoring and Alerting","text":"<pre><code># Good: Comprehensive monitoring\n- Health checks\n- Application metrics\n- Error tracking\n- Performance monitoring\n- Log aggregation\n\n# Avoid: No monitoring or basic monitoring only\n</code></pre>"},{"location":"guides/deployment/#4-graceful-shutdown","title":"4. Graceful Shutdown","text":"<pre><code># Good: Handle shutdown gracefully\nasync def graceful_shutdown():\n    # Close database connections\n    # Finish processing requests\n    # Clean up resources\n    pass\n\n# Avoid: Abrupt termination\n</code></pre>"},{"location":"guides/deployment/#5-resource-management","title":"5. Resource Management","text":"<pre><code># Good: Proper resource limits\nresources:\n  requests:\n    memory: \"256Mi\"\n    cpu: \"250m\"\n  limits:\n    memory: \"512Mi\"\n    cpu: \"500m\"\n\n# Avoid: No resource limits\n</code></pre>"},{"location":"guides/deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/deployment/#common-issues","title":"Common Issues","text":"<ol> <li>Application won't start</li> <li>Check configuration files</li> <li>Verify environment variables</li> <li>Check database connectivity</li> <li> <p>Review logs for errors</p> </li> <li> <p>High memory usage</p> </li> <li>Check for memory leaks</li> <li>Review database connection pooling</li> <li>Monitor garbage collection</li> <li> <p>Optimize caching</p> </li> <li> <p>Slow response times</p> </li> <li>Add database indexes</li> <li>Implement caching</li> <li>Optimize queries</li> <li> <p>Use connection pooling</p> </li> <li> <p>SSL/TLS issues</p> </li> <li>Verify certificate validity</li> <li>Check certificate chain</li> <li>Ensure proper configuration</li> <li>Test with SSL tools</li> </ol>"},{"location":"guides/deployment/#debugging-commands","title":"Debugging Commands","text":"<pre><code># Check application logs\ndocker logs serv-app\n\n# Check resource usage\ndocker stats serv-app\n\n# Test health endpoint\ncurl -f http://localhost:8000/health\n\n# Check database connectivity\npsql $DATABASE_URL -c \"SELECT 1\"\n\n# Monitor application metrics\ncurl http://localhost:8000/metrics\n</code></pre>"},{"location":"guides/deployment/#next-steps","title":"Next Steps","text":"<ul> <li>Performance - Optimize application performance</li> <li>Monitoring - Advanced monitoring and alerting</li> <li>Security - Advanced security practices </li> </ul>"},{"location":"guides/error-handling/","title":"Error Handling","text":"<p>Effective error handling is crucial for building robust web applications. Serv provides comprehensive error handling capabilities including custom exceptions, error middleware, logging integration, and graceful error responses. This guide covers everything you need to know about handling errors in Serv applications.</p>"},{"location":"guides/error-handling/#overview","title":"Overview","text":"<p>Serv's error handling features:</p> <ol> <li>HTTP Exceptions: Built-in exceptions for common HTTP errors</li> <li>Custom Error Pages: Create custom error responses and pages</li> <li>Error Middleware: Centralized error handling and logging</li> <li>Exception Propagation: Proper exception handling throughout the stack</li> <li>Development vs Production: Different error handling for different environments</li> </ol>"},{"location":"guides/error-handling/#http-exceptions","title":"HTTP Exceptions","text":""},{"location":"guides/error-handling/#built-in-http-exceptions","title":"Built-in HTTP Exceptions","text":"<p>Serv provides exceptions for common HTTP status codes:</p> <pre><code>from serv.routes import Route, GetRequest, PostRequest\nfrom serv.exceptions import (\n    HTTPBadRequestException,\n    HTTPUnauthorizedException,\n    HTTPForbiddenException,\n    HTTPNotFoundException,\n    HTTPMethodNotAllowedException,\n    HTTPInternalServerErrorException\n)\nfrom typing import Annotated\nfrom serv.responses import JsonResponse\n\nclass ErrorExampleRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Demonstrate various HTTP exceptions\"\"\"\n        error_type = request.query_params.get(\"error\", \"none\")\n\n        if error_type == \"bad_request\":\n            raise HTTPBadRequestException(\"Invalid request parameters\")\n\n        elif error_type == \"unauthorized\":\n            raise HTTPUnauthorizedException(\"Authentication required\")\n\n        elif error_type == \"forbidden\":\n            raise HTTPForbiddenException(\"Access denied\")\n\n        elif error_type == \"not_found\":\n            raise HTTPNotFoundException(\"Resource not found\")\n\n        elif error_type == \"method_not_allowed\":\n            raise HTTPMethodNotAllowedException(\"Method not allowed\")\n\n        elif error_type == \"internal_error\":\n            raise HTTPInternalServerErrorException(\"Internal server error\")\n\n        return {\"message\": \"No error requested\"}\n</code></pre>"},{"location":"guides/error-handling/#custom-http-exceptions","title":"Custom HTTP Exceptions","text":"<p>Create your own HTTP exceptions for specific use cases:</p> <pre><code>from serv.exceptions import HTTPException\n\nclass HTTPValidationException(HTTPException):\n    \"\"\"Custom validation error exception\"\"\"\n\n    def __init__(self, message: str, field: str = None, details: dict = None):\n        self.field = field\n        self.details = details or {}\n        super().__init__(status_code=422, detail=message)\n\nclass HTTPRateLimitException(HTTPException):\n    \"\"\"Rate limit exceeded exception\"\"\"\n\n    def __init__(self, retry_after: int = 60):\n        self.retry_after = retry_after\n        super().__init__(\n            status_code=429,\n            detail=\"Rate limit exceeded\",\n            headers={\"Retry-After\": str(retry_after)}\n        )\n\nclass HTTPMaintenanceException(HTTPException):\n    \"\"\"Service maintenance exception\"\"\"\n\n    def __init__(self, message: str = \"Service temporarily unavailable\"):\n        super().__init__(status_code=503, detail=message)\n\nclass ValidationRoute(Route):\n    async def handle_post(self, request: PostRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Route with custom validation errors\"\"\"\n        data = await request.json()\n\n        # Validate email\n        email = data.get(\"email\", \"\").strip()\n        if not email:\n            raise HTTPValidationException(\"Email is required\", field=\"email\")\n\n        if \"@\" not in email:\n            raise HTTPValidationException(\n                \"Invalid email format\",\n                field=\"email\",\n                details={\"provided\": email, \"expected_format\": \"user@domain.com\"}\n            )\n\n        # Check rate limiting\n        if await self.is_rate_limited(request):\n            raise HTTPRateLimitException(retry_after=120)\n\n        # Check maintenance mode\n        if await self.is_maintenance_mode():\n            raise HTTPMaintenanceException(\"System is under maintenance\")\n\n        return {\"message\": \"Validation passed\"}\n\n    async def is_rate_limited(self, request) -&gt; bool:\n        \"\"\"Check if request is rate limited\"\"\"\n        # Implement rate limiting logic\n        return False\n\n    async def is_maintenance_mode(self) -&gt; bool:\n        \"\"\"Check if system is in maintenance mode\"\"\"\n        # Check maintenance flag\n        return False\n</code></pre>"},{"location":"guides/error-handling/#error-middleware","title":"Error Middleware","text":""},{"location":"guides/error-handling/#global-error-handler","title":"Global Error Handler","text":"<p>Create middleware to handle all errors consistently:</p> <pre><code>import logging\nimport traceback\nfrom serv.middleware import Middleware\nfrom serv.responses import JsonResponse, HtmlResponse\nfrom serv.exceptions import HTTPException\n\nlogger = logging.getLogger(__name__)\n\nclass ErrorHandlingMiddleware(Middleware):\n    \"\"\"Global error handling middleware\"\"\"\n\n    async def __call__(self, request, call_next):\n        try:\n            response = await call_next(request)\n            return response\n\n        except HTTPException as e:\n            # Handle known HTTP exceptions\n            return await self.handle_http_exception(request, e)\n\n        except Exception as e:\n            # Handle unexpected exceptions\n            return await self.handle_unexpected_exception(request, e)\n\n    async def handle_http_exception(self, request, exception: HTTPException):\n        \"\"\"Handle HTTP exceptions with proper responses\"\"\"\n        logger.warning(\n            f\"HTTP {exception.status_code}: {exception.detail}\",\n            extra={\n                \"path\": request.url.path,\n                \"method\": request.method,\n                \"status_code\": exception.status_code\n            }\n        )\n\n        # Determine response format based on Accept header\n        accept = request.headers.get(\"accept\", \"\")\n\n        if \"application/json\" in accept or request.url.path.startswith(\"/api/\"):\n            # Return JSON error for API requests\n            error_data = {\n                \"error\": {\n                    \"code\": exception.status_code,\n                    \"message\": exception.detail,\n                    \"type\": exception.__class__.__name__\n                }\n            }\n\n            # Add custom exception data if available\n            if hasattr(exception, 'field'):\n                error_data[\"error\"][\"field\"] = exception.field\n\n            if hasattr(exception, 'details'):\n                error_data[\"error\"][\"details\"] = exception.details\n\n            return JsonResponse(\n                error_data,\n                status_code=exception.status_code,\n                headers=getattr(exception, 'headers', None)\n            )\n\n        else:\n            # Return HTML error page for web requests\n            return await self.render_error_page(request, exception)\n\n    async def handle_unexpected_exception(self, request, exception: Exception):\n        \"\"\"Handle unexpected exceptions\"\"\"\n        logger.exception(\n            f\"Unexpected error: {str(exception)}\",\n            extra={\n                \"path\": request.url.path,\n                \"method\": request.method,\n                \"exception_type\": exception.__class__.__name__\n            }\n        )\n\n        # In development, show detailed error\n        if request.app.debug:\n            error_data = {\n                \"error\": {\n                    \"code\": 500,\n                    \"message\": str(exception),\n                    \"type\": exception.__class__.__name__,\n                    \"traceback\": traceback.format_exc().split('\\n')\n                }\n            }\n        else:\n            # In production, show generic error\n            error_data = {\n                \"error\": {\n                    \"code\": 500,\n                    \"message\": \"Internal server error\",\n                    \"type\": \"InternalServerError\"\n                }\n            }\n\n        accept = request.headers.get(\"accept\", \"\")\n\n        if \"application/json\" in accept or request.url.path.startswith(\"/api/\"):\n            return JsonResponse(error_data, status_code=500)\n        else:\n            return await self.render_error_page(request, HTTPInternalServerErrorException())\n\n    async def render_error_page(self, request, exception: HTTPException):\n        \"\"\"Render HTML error page\"\"\"\n        error_templates = {\n            400: \"errors/400.html\",\n            401: \"errors/401.html\",\n            403: \"errors/403.html\",\n            404: \"errors/404.html\",\n            500: \"errors/500.html\"\n        }\n\n        template_name = error_templates.get(exception.status_code, \"errors/generic.html\")\n\n        # Try to render custom error template\n        try:\n            # If you have a template engine, render the template\n            html_content = await self.render_template(template_name, {\n                \"error\": exception,\n                \"request\": request\n            })\n        except:\n            # Fallback to simple HTML\n            html_content = f\"\"\"\n            &lt;!DOCTYPE html&gt;\n            &lt;html&gt;\n            &lt;head&gt;\n                &lt;title&gt;Error {exception.status_code}&lt;/title&gt;\n                &lt;style&gt;\n                    body {{ font-family: Arial, sans-serif; margin: 40px; text-align: center; }}\n                    .error-container {{ max-width: 600px; margin: 0 auto; }}\n                    .error-code {{ font-size: 72px; color: #dc3545; margin: 20px 0; }}\n                    .error-message {{ font-size: 24px; color: #6c757d; margin: 20px 0; }}\n                    .back-link {{ margin-top: 30px; }}\n                    .back-link a {{ color: #007bff; text-decoration: none; }}\n                &lt;/style&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;div class=\"error-container\"&gt;\n                    &lt;div class=\"error-code\"&gt;{exception.status_code}&lt;/div&gt;\n                    &lt;div class=\"error-message\"&gt;{exception.detail}&lt;/div&gt;\n                    &lt;div class=\"back-link\"&gt;\n                        &lt;a href=\"/\"&gt;\u2190 Back to Home&lt;/a&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/body&gt;\n            &lt;/html&gt;\n            \"\"\"\n\n        return HtmlResponse(html_content, status_code=exception.status_code)\n\n    async def render_template(self, template_name: str, context: dict) -&gt; str:\n        \"\"\"Render template (implement based on your template engine)\"\"\"\n        # This would integrate with your template engine\n        # For example, with Jinja2:\n        # return await self.template_engine.render(template_name, context)\n        raise NotImplementedError(\"Template rendering not implemented\")\n</code></pre>"},{"location":"guides/error-handling/#logging-middleware","title":"Logging Middleware","text":"<p>Add detailed logging for debugging:</p> <pre><code>import time\nimport uuid\nfrom serv.middleware import Middleware\n\nclass LoggingMiddleware(Middleware):\n    \"\"\"Request/response logging middleware\"\"\"\n\n    async def __call__(self, request, call_next):\n        # Generate request ID\n        request_id = str(uuid.uuid4())[:8]\n        request.state.request_id = request_id\n\n        # Log request\n        start_time = time.time()\n        logger.info(\n            f\"Request started\",\n            extra={\n                \"request_id\": request_id,\n                \"method\": request.method,\n                \"path\": request.url.path,\n                \"query\": str(request.query_params),\n                \"user_agent\": request.headers.get(\"user-agent\", \"\"),\n                \"client_ip\": request.client.host if request.client else None\n            }\n        )\n\n        try:\n            response = await call_next(request)\n\n            # Log successful response\n            duration = time.time() - start_time\n            logger.info(\n                f\"Request completed\",\n                extra={\n                    \"request_id\": request_id,\n                    \"status_code\": response.status_code,\n                    \"duration_ms\": round(duration * 1000, 2)\n                }\n            )\n\n            return response\n\n        except Exception as e:\n            # Log error\n            duration = time.time() - start_time\n            logger.error(\n                f\"Request failed\",\n                extra={\n                    \"request_id\": request_id,\n                    \"error\": str(e),\n                    \"error_type\": e.__class__.__name__,\n                    \"duration_ms\": round(duration * 1000, 2)\n                }\n            )\n            raise\n</code></pre>"},{"location":"guides/error-handling/#application-level-error-handlers","title":"Application-Level Error Handlers","text":""},{"location":"guides/error-handling/#custom-error-handlers","title":"Custom Error Handlers","text":"<p>Serv allows you to register custom error handlers at the application level for specific exception types:</p> <pre><code>from serv.app import App\nfrom serv.exceptions import HTTPNotFoundException, HTTPBadRequestException\nfrom serv.responses import ResponseBuilder\nfrom serv.requests import Request\nfrom bevy import dependency\n\n# Create custom error handlers\nasync def custom_404_handler(\n    error: HTTPNotFoundException,\n    response: ResponseBuilder = dependency(),\n    request: Request = dependency()\n):\n    \"\"\"Custom 404 error handler\"\"\"\n    response.set_status(404)\n    response.content_type(\"text/html\")\n    response.body(f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Page Not Found&lt;/title&gt;\n        &lt;style&gt;\n            body {{ font-family: Arial, sans-serif; text-align: center; margin-top: 100px; }}\n            .error-code {{ font-size: 72px; color: #dc3545; }}\n            .error-message {{ font-size: 24px; color: #6c757d; }}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=\"error-code\"&gt;404&lt;/div&gt;\n        &lt;div class=\"error-message\"&gt;Oops! The page \"{request.path}\" was not found.&lt;/div&gt;\n        &lt;p&gt;&lt;a href=\"/\"&gt;Return to Home&lt;/a&gt;&lt;/p&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\")\n\nasync def validation_error_handler(\n    error: HTTPBadRequestException,\n    response: ResponseBuilder = dependency(),\n    request: Request = dependency()\n):\n    \"\"\"Custom validation error handler\"\"\"\n    # Check if this is an API request\n    if request.path.startswith(\"/api/\") or \"application/json\" in request.headers.get(\"accept\", \"\"):\n        response.set_status(400)\n        response.content_type(\"application/json\")\n        response.body({\n            \"error\": {\n                \"type\": \"validation_error\",\n                \"message\": str(error),\n                \"path\": request.path,\n                \"timestamp\": time.time()\n            }\n        })\n    else:\n        response.set_status(400)\n        response.content_type(\"text/html\")\n        response.body(f\"\"\"\n        &lt;h1&gt;Validation Error&lt;/h1&gt;\n        &lt;p&gt;{str(error)}&lt;/p&gt;\n        &lt;a href=\"javascript:history.back()\"&gt;Go Back&lt;/a&gt;\n        \"\"\")\n\n# Register error handlers with the app\napp = App()\napp.add_error_handler(HTTPNotFoundException, custom_404_handler)\napp.add_error_handler(HTTPBadRequestException, validation_error_handler)\n</code></pre>"},{"location":"guides/error-handling/#generic-error-handler","title":"Generic Error Handler","text":"<p>You can also register a catch-all error handler for any unhandled exceptions:</p> <pre><code>async def generic_error_handler(\n    error: Exception,\n    response: ResponseBuilder = dependency(),\n    request: Request = dependency()\n):\n    \"\"\"Handle any unhandled exceptions\"\"\"\n    import logging\n    import traceback\n\n    logger = logging.getLogger(__name__)\n    logger.exception(f\"Unhandled error on {request.path}: {error}\")\n\n    # In development, show detailed error\n    if app.dev_mode:\n        response.set_status(500)\n        response.content_type(\"text/html\")\n        response.body(f\"\"\"\n        &lt;h1&gt;Internal Server Error&lt;/h1&gt;\n        &lt;h2&gt;{type(error).__name__}: {str(error)}&lt;/h2&gt;\n        &lt;pre&gt;{traceback.format_exc()}&lt;/pre&gt;\n        \"\"\")\n    else:\n        # In production, show generic error\n        response.set_status(500)\n        response.content_type(\"text/html\")\n        response.body(\"\"\"\n        &lt;h1&gt;Internal Server Error&lt;/h1&gt;\n        &lt;p&gt;Something went wrong. Please try again later.&lt;/p&gt;\n        \"\"\")\n\napp.add_error_handler(Exception, generic_error_handler)\n</code></pre>"},{"location":"guides/error-handling/#route-level-error-handling","title":"Route-Level Error Handling","text":""},{"location":"guides/error-handling/#route-error-handlers","title":"Route Error Handlers","text":"<p>Route classes can define their own error handlers for exceptions that occur within that specific route:</p> <pre><code>from serv.routes import Route, GetRequest, PostRequest\nfrom serv.responses import JsonResponse, HtmlResponse\nfrom typing import Annotated\n\nclass UserRoute(Route):\n    \"\"\"Route with custom error handling\"\"\"\n\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Get user by ID\"\"\"\n        user_id = request.path_params.get(\"user_id\")\n\n        if not user_id.isdigit():\n            raise ValueError(\"User ID must be a number\")\n\n        user = await self.get_user(int(user_id))\n        if not user:\n            raise HTTPNotFoundException(f\"User {user_id} not found\")\n\n        return {\"user\": user}\n\n    async def handle_post(self, request: PostRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Create new user\"\"\"\n        data = await request.json()\n\n        # This might raise a custom exception\n        user = await self.create_user(data)\n\n        return {\"user\": user, \"message\": \"User created\"}\n\n    async def handle_value_error(self, error: ValueError) -&gt; JsonResponse:\n        \"\"\"Handle ValueError exceptions in this route\"\"\"\n        return JsonResponse(\n            {\n                \"error\": \"Invalid input\",\n                \"message\": str(error),\n                \"type\": \"validation_error\"\n            },\n            status_code=400\n        )\n\n    async def handle_database_error(self, error: DatabaseError) -&gt; JsonResponse:\n        \"\"\"Handle database errors in this route\"\"\"\n        return JsonResponse(\n            {\n                \"error\": \"Database error\",\n                \"message\": \"Unable to process request\",\n                \"type\": \"database_error\"\n            },\n            status_code=503\n        )\n\n    async def get_user(self, user_id: int):\n        \"\"\"Mock user retrieval that might fail\"\"\"\n        if user_id == 999:\n            raise DatabaseError(\"Database connection failed\")\n\n        return {\"id\": user_id, \"name\": f\"User {user_id}\"}\n\n    async def create_user(self, data):\n        \"\"\"Mock user creation that might fail\"\"\"\n        if not data.get(\"email\"):\n            raise ValueError(\"Email is required\")\n\n        return {\"id\": 123, \"email\": data[\"email\"]}\n\n# Register route error handlers\nUserRoute.add_error_handler(ValueError, UserRoute.handle_value_error)\nUserRoute.add_error_handler(DatabaseError, UserRoute.handle_database_error)\n</code></pre>"},{"location":"guides/error-handling/#error-handler-inheritance","title":"Error Handler Inheritance","text":"<p>Route error handlers take precedence over application-level handlers. If a route doesn't have a specific error handler, the application-level handler will be used:</p> <pre><code>class BaseApiRoute(Route):\n    \"\"\"Base route with common error handling\"\"\"\n\n    async def handle_validation_error(self, error: ValidationError) -&gt; JsonResponse:\n        \"\"\"Common validation error handler for API routes\"\"\"\n        return JsonResponse(\n            {\n                \"error\": \"validation_failed\",\n                \"message\": str(error),\n                \"field\": getattr(error, 'field', None)\n            },\n            status_code=422\n        )\n\nclass ProductRoute(BaseApiRoute):\n    \"\"\"Product route inheriting error handling\"\"\"\n\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Get product - uses inherited error handling\"\"\"\n        product_id = request.path_params.get(\"product_id\")\n\n        if not product_id:\n            raise ValidationError(\"Product ID is required\", field=\"product_id\")\n\n        return {\"product\": {\"id\": product_id, \"name\": \"Sample Product\"}}\n\n# Register error handler on base class\nBaseApiRoute.add_error_handler(ValidationError, BaseApiRoute.handle_validation_error)\n</code></pre>"},{"location":"guides/error-handling/#custom-error-pages","title":"Custom Error Pages","text":""},{"location":"guides/error-handling/#creating-error-templates","title":"Creating Error Templates","text":"<p>Create custom HTML templates for different error types:</p> <p>templates/errors/404.html: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Page Not Found - 404&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            margin: 0;\n            padding: 0;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            min-height: 100vh;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        .error-container {\n            text-align: center;\n            color: white;\n            max-width: 600px;\n            padding: 40px;\n        }\n        .error-code {\n            font-size: 120px;\n            font-weight: bold;\n            margin: 0;\n            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);\n        }\n        .error-title {\n            font-size: 32px;\n            margin: 20px 0;\n            font-weight: 300;\n        }\n        .error-description {\n            font-size: 18px;\n            margin: 30px 0;\n            line-height: 1.6;\n            opacity: 0.9;\n        }\n        .action-buttons {\n            margin-top: 40px;\n        }\n        .btn {\n            display: inline-block;\n            padding: 12px 30px;\n            margin: 0 10px;\n            background: rgba(255,255,255,0.2);\n            color: white;\n            text-decoration: none;\n            border-radius: 25px;\n            border: 2px solid rgba(255,255,255,0.3);\n            transition: all 0.3s ease;\n        }\n        .btn:hover {\n            background: rgba(255,255,255,0.3);\n            border-color: rgba(255,255,255,0.5);\n        }\n        .btn-primary {\n            background: rgba(255,255,255,0.9);\n            color: #667eea;\n            border-color: transparent;\n        }\n        .btn-primary:hover {\n            background: white;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"error-container\"&gt;\n        &lt;h1 class=\"error-code\"&gt;404&lt;/h1&gt;\n        &lt;h2 class=\"error-title\"&gt;Page Not Found&lt;/h2&gt;\n        &lt;p class=\"error-description\"&gt;\n            The page you're looking for doesn't exist or has been moved.\n            Don't worry, it happens to the best of us!\n        &lt;/p&gt;\n        &lt;div class=\"action-buttons\"&gt;\n            &lt;a href=\"/\" class=\"btn btn-primary\"&gt;Go Home&lt;/a&gt;\n            &lt;a href=\"javascript:history.back()\" class=\"btn\"&gt;Go Back&lt;/a&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p>templates/errors/500.html: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Server Error - 500&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            margin: 0;\n            padding: 0;\n            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);\n            min-height: 100vh;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        .error-container {\n            text-align: center;\n            color: white;\n            max-width: 600px;\n            padding: 40px;\n        }\n        .error-code {\n            font-size: 120px;\n            font-weight: bold;\n            margin: 0;\n            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);\n        }\n        .error-title {\n            font-size: 32px;\n            margin: 20px 0;\n            font-weight: 300;\n        }\n        .error-description {\n            font-size: 18px;\n            margin: 30px 0;\n            line-height: 1.6;\n            opacity: 0.9;\n        }\n        .action-buttons {\n            margin-top: 40px;\n        }\n        .btn {\n            display: inline-block;\n            padding: 12px 30px;\n            margin: 0 10px;\n            background: rgba(255,255,255,0.2);\n            color: white;\n            text-decoration: none;\n            border-radius: 25px;\n            border: 2px solid rgba(255,255,255,0.3);\n            transition: all 0.3s ease;\n        }\n        .btn:hover {\n            background: rgba(255,255,255,0.3);\n            border-color: rgba(255,255,255,0.5);\n        }\n        .btn-primary {\n            background: rgba(255,255,255,0.9);\n            color: #ff6b6b;\n            border-color: transparent;\n        }\n        .btn-primary:hover {\n            background: white;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"error-container\"&gt;\n        &lt;h1 class=\"error-code\"&gt;500&lt;/h1&gt;\n        &lt;h2 class=\"error-title\"&gt;Server Error&lt;/h2&gt;\n        &lt;p class=\"error-description\"&gt;\n            Something went wrong on our end. We've been notified and are working to fix it.\n            Please try again in a few minutes.\n        &lt;/p&gt;\n        &lt;div class=\"action-buttons\"&gt;\n            &lt;a href=\"/\" class=\"btn btn-primary\"&gt;Go Home&lt;/a&gt;\n            &lt;a href=\"javascript:location.reload()\" class=\"btn\"&gt;Try Again&lt;/a&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"guides/error-handling/#dynamic-error-pages","title":"Dynamic Error Pages","text":"<p>Create error pages with dynamic content:</p> <pre><code>class ErrorPageRoute(Route):\n    \"\"\"Custom error page handler\"\"\"\n\n    async def handle_get(self, request: GetRequest) -&gt; HtmlResponse:\n        \"\"\"Render custom error page\"\"\"\n        error_code = request.path_params.get(\"code\", \"404\")\n\n        error_info = {\n            \"400\": {\n                \"title\": \"Bad Request\",\n                \"description\": \"The request could not be understood by the server.\",\n                \"color\": \"#ffc107\"\n            },\n            \"401\": {\n                \"title\": \"Unauthorized\",\n                \"description\": \"You need to log in to access this resource.\",\n                \"color\": \"#fd7e14\"\n            },\n            \"403\": {\n                \"title\": \"Forbidden\",\n                \"description\": \"You don't have permission to access this resource.\",\n                \"color\": \"#dc3545\"\n            },\n            \"404\": {\n                \"title\": \"Not Found\",\n                \"description\": \"The page you're looking for doesn't exist.\",\n                \"color\": \"#6f42c1\"\n            },\n            \"500\": {\n                \"title\": \"Server Error\",\n                \"description\": \"Something went wrong on our end.\",\n                \"color\": \"#e83e8c\"\n            }\n        }\n\n        info = error_info.get(error_code, error_info[\"404\"])\n\n        html_content = f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;Error {error_code} - {info['title']}&lt;/title&gt;\n            &lt;style&gt;\n                body {{\n                    font-family: Arial, sans-serif;\n                    background: linear-gradient(135deg, {info['color']} 0%, #333 100%);\n                    color: white;\n                    margin: 0;\n                    padding: 40px;\n                    min-height: 100vh;\n                    display: flex;\n                    align-items: center;\n                    justify-content: center;\n                }}\n                .container {{\n                    text-align: center;\n                    max-width: 600px;\n                }}\n                .code {{ font-size: 100px; margin: 20px 0; }}\n                .title {{ font-size: 36px; margin: 20px 0; }}\n                .description {{ font-size: 18px; margin: 30px 0; }}\n                .actions {{ margin-top: 40px; }}\n                .btn {{\n                    display: inline-block;\n                    padding: 12px 24px;\n                    margin: 0 10px;\n                    background: rgba(255,255,255,0.2);\n                    color: white;\n                    text-decoration: none;\n                    border-radius: 5px;\n                    border: 1px solid rgba(255,255,255,0.3);\n                }}\n                .btn:hover {{\n                    background: rgba(255,255,255,0.3);\n                }}\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;div class=\"container\"&gt;\n                &lt;div class=\"code\"&gt;{error_code}&lt;/div&gt;\n                &lt;div class=\"title\"&gt;{info['title']}&lt;/div&gt;\n                &lt;div class=\"description\"&gt;{info['description']}&lt;/div&gt;\n                &lt;div class=\"actions\"&gt;\n                    &lt;a href=\"/\" class=\"btn\"&gt;Go Home&lt;/a&gt;\n                    &lt;a href=\"javascript:history.back()\" class=\"btn\"&gt;Go Back&lt;/a&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n        return HtmlResponse(html_content, status_code=int(error_code))\n</code></pre>"},{"location":"guides/error-handling/#validation-errors","title":"Validation Errors","text":""},{"location":"guides/error-handling/#form-validation","title":"Form Validation","text":"<p>Handle form validation errors gracefully:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List, Dict, Any\n\n@dataclass\nclass ValidationError:\n    field: str\n    message: str\n    code: str = None\n\nclass FormValidationException(HTTPException):\n    \"\"\"Exception for form validation errors\"\"\"\n\n    def __init__(self, errors: List[ValidationError]):\n        self.errors = errors\n        error_messages = [f\"{error.field}: {error.message}\" for error in errors]\n        super().__init__(\n            status_code=422,\n            detail=\"Validation failed: \" + \"; \".join(error_messages)\n        )\n\nclass UserRegistrationRoute(Route):\n    async def handle_post(self, request: PostRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"User registration with comprehensive validation\"\"\"\n        data = await request.json()\n\n        # Validate the form\n        errors = await self.validate_registration_form(data)\n\n        if errors:\n            raise FormValidationException(errors)\n\n        # Process registration\n        user = await self.create_user(data)\n\n        return {\"user\": user, \"message\": \"Registration successful\"}\n\n    async def validate_registration_form(self, data: Dict[str, Any]) -&gt; List[ValidationError]:\n        \"\"\"Validate registration form data\"\"\"\n        errors = []\n\n        # Validate name\n        name = data.get(\"name\", \"\").strip()\n        if not name:\n            errors.append(ValidationError(\"name\", \"Name is required\", \"REQUIRED\"))\n        elif len(name) &lt; 2:\n            errors.append(ValidationError(\"name\", \"Name must be at least 2 characters\", \"MIN_LENGTH\"))\n        elif len(name) &gt; 50:\n            errors.append(ValidationError(\"name\", \"Name must be less than 50 characters\", \"MAX_LENGTH\"))\n\n        # Validate email\n        email = data.get(\"email\", \"\").strip().lower()\n        if not email:\n            errors.append(ValidationError(\"email\", \"Email is required\", \"REQUIRED\"))\n        elif not self.is_valid_email(email):\n            errors.append(ValidationError(\"email\", \"Invalid email format\", \"INVALID_FORMAT\"))\n        elif await self.email_exists(email):\n            errors.append(ValidationError(\"email\", \"Email already registered\", \"ALREADY_EXISTS\"))\n\n        # Validate password\n        password = data.get(\"password\", \"\")\n        if not password:\n            errors.append(ValidationError(\"password\", \"Password is required\", \"REQUIRED\"))\n        elif len(password) &lt; 8:\n            errors.append(ValidationError(\"password\", \"Password must be at least 8 characters\", \"MIN_LENGTH\"))\n        elif not self.is_strong_password(password):\n            errors.append(ValidationError(\"password\", \"Password must contain uppercase, lowercase, and numbers\", \"WEAK\"))\n\n        # Validate password confirmation\n        password_confirm = data.get(\"password_confirm\", \"\")\n        if password and password != password_confirm:\n            errors.append(ValidationError(\"password_confirm\", \"Passwords do not match\", \"MISMATCH\"))\n\n        # Validate age\n        age = data.get(\"age\")\n        if age is not None:\n            try:\n                age = int(age)\n                if age &lt; 13:\n                    errors.append(ValidationError(\"age\", \"Must be at least 13 years old\", \"MIN_VALUE\"))\n                elif age &gt; 120:\n                    errors.append(ValidationError(\"age\", \"Invalid age\", \"MAX_VALUE\"))\n            except (ValueError, TypeError):\n                errors.append(ValidationError(\"age\", \"Age must be a number\", \"INVALID_TYPE\"))\n\n        return errors\n\n    def is_valid_email(self, email: str) -&gt; bool:\n        \"\"\"Basic email validation\"\"\"\n        import re\n        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        return re.match(pattern, email) is not None\n\n    async def email_exists(self, email: str) -&gt; bool:\n        \"\"\"Check if email already exists\"\"\"\n        # Implement database check\n        return False\n\n    def is_strong_password(self, password: str) -&gt; bool:\n        \"\"\"Check password strength\"\"\"\n        import re\n        # At least one uppercase, one lowercase, one digit\n        return (\n            re.search(r'[A-Z]', password) and\n            re.search(r'[a-z]', password) and\n            re.search(r'\\d', password)\n        )\n\n    async def create_user(self, data: Dict[str, Any]):\n        \"\"\"Create user in database\"\"\"\n        return {\n            \"id\": 123,\n            \"name\": data[\"name\"],\n            \"email\": data[\"email\"]\n        }\n</code></pre>"},{"location":"guides/error-handling/#error-recovery","title":"Error Recovery","text":""},{"location":"guides/error-handling/#retry-mechanisms","title":"Retry Mechanisms","text":"<p>Implement retry logic for transient errors:</p> <pre><code>import asyncio\nfrom typing import Callable, Any\n\nclass RetryableRoute(Route):\n    \"\"\"Route with retry mechanisms for external services\"\"\"\n\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Get data with retry logic\"\"\"\n        try:\n            # Try to get data from external service with retries\n            data = await self.retry_operation(\n                self.fetch_external_data,\n                max_retries=3,\n                delay=1.0,\n                backoff=2.0\n            )\n\n            return {\"data\": data}\n\n        except Exception as e:\n            logger.error(f\"Failed to fetch data after retries: {str(e)}\")\n            raise HTTPInternalServerErrorException(\"Service temporarily unavailable\")\n\n    async def retry_operation(\n        self,\n        operation: Callable,\n        max_retries: int = 3,\n        delay: float = 1.0,\n        backoff: float = 2.0,\n        *args,\n        **kwargs\n    ) -&gt; Any:\n        \"\"\"Retry an operation with exponential backoff\"\"\"\n        last_exception = None\n\n        for attempt in range(max_retries + 1):\n            try:\n                return await operation(*args, **kwargs)\n\n            except Exception as e:\n                last_exception = e\n\n                if attempt == max_retries:\n                    # Last attempt failed\n                    break\n\n                # Log retry attempt\n                logger.warning(\n                    f\"Operation failed (attempt {attempt + 1}/{max_retries + 1}): {str(e)}. \"\n                    f\"Retrying in {delay} seconds...\"\n                )\n\n                # Wait before retry\n                await asyncio.sleep(delay)\n                delay *= backoff  # Exponential backoff\n\n        # All retries failed\n        raise last_exception\n\n    async def fetch_external_data(self):\n        \"\"\"Simulate external service call\"\"\"\n        import random\n\n        # Simulate random failures\n        if random.random() &lt; 0.7:  # 70% failure rate for demo\n            raise ConnectionError(\"External service unavailable\")\n\n        return {\"external_data\": \"success\"}\n</code></pre>"},{"location":"guides/error-handling/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<p>Implement circuit breaker for failing services:</p> <pre><code>import time\nfrom enum import Enum\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"\n    OPEN = \"open\"\n    HALF_OPEN = \"half_open\"\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker implementation\"\"\"\n\n    def __init__(\n        self,\n        failure_threshold: int = 5,\n        timeout: float = 60.0,\n        expected_exception: type = Exception\n    ):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.expected_exception = expected_exception\n\n        self.failure_count = 0\n        self.last_failure_time = None\n        self.state = CircuitState.CLOSED\n\n    async def call(self, operation: Callable, *args, **kwargs):\n        \"\"\"Execute operation through circuit breaker\"\"\"\n        if self.state == CircuitState.OPEN:\n            if self._should_attempt_reset():\n                self.state = CircuitState.HALF_OPEN\n            else:\n                raise HTTPServiceUnavailableException(\"Circuit breaker is open\")\n\n        try:\n            result = await operation(*args, **kwargs)\n            self._on_success()\n            return result\n\n        except self.expected_exception as e:\n            self._on_failure()\n            raise\n\n    def _should_attempt_reset(self) -&gt; bool:\n        \"\"\"Check if enough time has passed to attempt reset\"\"\"\n        return (\n            self.last_failure_time and\n            time.time() - self.last_failure_time &gt;= self.timeout\n        )\n\n    def _on_success(self):\n        \"\"\"Handle successful operation\"\"\"\n        self.failure_count = 0\n        self.state = CircuitState.CLOSED\n\n    def _on_failure(self):\n        \"\"\"Handle failed operation\"\"\"\n        self.failure_count += 1\n        self.last_failure_time = time.time()\n\n        if self.failure_count &gt;= self.failure_threshold:\n            self.state = CircuitState.OPEN\n\nclass CircuitBreakerRoute(Route):\n    \"\"\"Route using circuit breaker pattern\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.circuit_breaker = CircuitBreaker(\n            failure_threshold=3,\n            timeout=30.0,\n            expected_exception=ConnectionError\n        )\n\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Get data through circuit breaker\"\"\"\n        try:\n            data = await self.circuit_breaker.call(self.fetch_external_data)\n            return {\"data\": data, \"circuit_state\": self.circuit_breaker.state.value}\n\n        except HTTPException:\n            raise\n\n        except Exception as e:\n            logger.error(f\"Circuit breaker operation failed: {str(e)}\")\n            raise HTTPServiceUnavailableException(\"External service unavailable\")\n\n    async def fetch_external_data(self):\n        \"\"\"Simulate external service call\"\"\"\n        import random\n\n        if random.random() &lt; 0.6:  # 60% failure rate for demo\n            raise ConnectionError(\"External service down\")\n\n        return {\"service_data\": \"available\"}\n</code></pre>"},{"location":"guides/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"guides/error-handling/#1-use-appropriate-exception-types","title":"1. Use Appropriate Exception Types","text":"<pre><code># Good: Use specific exceptions\nif not user_id:\n    raise HTTPBadRequestException(\"User ID is required\")\n\nif not await user_exists(user_id):\n    raise HTTPNotFoundException(f\"User {user_id} not found\")\n\nif not await has_permission(user, resource):\n    raise HTTPForbiddenException(\"Access denied\")\n\n# Avoid: Generic exceptions\nif not user_id:\n    raise Exception(\"Error\")  # Too generic\n</code></pre>"},{"location":"guides/error-handling/#2-log-errors-appropriately","title":"2. Log Errors Appropriately","text":"<pre><code># Good: Structured logging with context\nlogger.error(\n    \"Database connection failed\",\n    extra={\n        \"user_id\": user_id,\n        \"operation\": \"fetch_user\",\n        \"database\": \"users_db\",\n        \"error_code\": \"CONNECTION_TIMEOUT\"\n    }\n)\n\n# Avoid: Minimal logging\nlogger.error(\"Error occurred\")  # Not helpful\n</code></pre>"},{"location":"guides/error-handling/#3-provide-helpful-error-messages","title":"3. Provide Helpful Error Messages","text":"<pre><code># Good: Clear, actionable error messages\nraise HTTPBadRequestException(\n    \"Invalid email format. Please provide a valid email address like 'user@example.com'\"\n)\n\n# Avoid: Vague error messages\nraise HTTPBadRequestException(\"Invalid input\")  # Not helpful\n</code></pre>"},{"location":"guides/error-handling/#4-handle-errors-at-the-right-level","title":"4. Handle Errors at the Right Level","text":"<pre><code># Good: Handle errors where you can take action\nasync def handle_post(self, request: PostRequest):\n    try:\n        data = await request.json()\n    except ValueError:\n        raise HTTPBadRequestException(\"Invalid JSON format\")\n\n    # Continue processing...\n\n# Avoid: Catching and re-raising without adding value\nasync def handle_post(self, request: PostRequest):\n    try:\n        data = await request.json()\n    except Exception as e:\n        raise e  # Pointless catch and re-raise\n</code></pre>"},{"location":"guides/error-handling/#5-differentiate-development-and-production","title":"5. Differentiate Development and Production","text":"<pre><code># Good: Different error handling for different environments\nif app.debug:\n    # Show detailed errors in development\n    error_data = {\n        \"error\": str(exception),\n        \"traceback\": traceback.format_exc(),\n        \"request_data\": await request.json()\n    }\nelse:\n    # Show generic errors in production\n    error_data = {\n        \"error\": \"Internal server error\"\n    }\n\n# Avoid: Always showing detailed errors\nerror_data = {\n    \"error\": str(exception),\n    \"traceback\": traceback.format_exc()  # Security risk in production\n}\n</code></pre>"},{"location":"guides/error-handling/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/error-handling/#1-plan-error-scenarios","title":"1. Plan Error Scenarios","text":"<p>Identify potential error conditions: - Invalid input - Missing resources - Permission issues - External service failures - Database errors</p>"},{"location":"guides/error-handling/#2-create-custom-exceptions","title":"2. Create Custom Exceptions","text":"<p>Define exceptions specific to your domain.</p>"},{"location":"guides/error-handling/#3-implement-error-middleware","title":"3. Implement Error Middleware","text":"<p>Set up centralized error handling and logging.</p>"},{"location":"guides/error-handling/#4-create-error-pages","title":"4. Create Error Pages","text":"<p>Design user-friendly error pages for web interfaces.</p>"},{"location":"guides/error-handling/#5-test-error-handling","title":"5. Test Error Handling","text":"<p>Test various error scenarios and edge cases.</p>"},{"location":"guides/error-handling/#next-steps","title":"Next Steps","text":"<ul> <li>Testing - Test your error handling logic</li> <li>Logging - Set up comprehensive logging</li> <li>Monitoring - Monitor errors in production</li> <li>Security - Secure error handling practices </li> </ul>"},{"location":"guides/extensions/","title":"Extensions","text":"<p>Extensions are the foundation of Serv's modular architecture. They provide a clean way to organize your application into reusable, configurable components. This guide covers everything you need to know about creating and using extensions in Serv.</p>"},{"location":"guides/extensions/#what-are-extensions","title":"What are Extensions?","text":"<p>In Serv, extensions are:</p> <ol> <li>Event-driven components that contain Listener classes responding to application lifecycle events</li> <li>Configuration containers that define routes, middleware, and settings declaratively</li> <li>Modular packages that can be easily shared and reused</li> <li>CLI-managed entities that are created and maintained using Serv's command-line tools</li> </ol>"},{"location":"guides/extensions/#extension-architecture","title":"Extension Architecture","text":""},{"location":"guides/extensions/#core-principles","title":"Core Principles","text":"<p>Serv extensions follow these key principles:</p> <ul> <li>Declarative Configuration: Routes and middleware are defined in <code>extension.yaml</code> files</li> <li>Event-Only Code: Listener classes only handle events, not route definitions</li> <li>CLI-First Development: Use CLI commands to create and manage extensions</li> <li>Automatic Wiring: Serv automatically connects configuration to functionality</li> </ul>"},{"location":"guides/extensions/#extension-structure","title":"Extension Structure","text":"<p>A typical extension has this structure:</p> <pre><code>extensions/\n\u2514\u2500\u2500 my_extension/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 extension.yaml          # Extension configuration and metadata\n    \u251c\u2500\u2500 my_extension.py         # Main listener class (event handlers only)\n    \u251c\u2500\u2500 route_*.py           # Route handler files\n    \u251c\u2500\u2500 middleware_*.py      # Middleware files\n    \u2514\u2500\u2500 templates/           # Optional: Jinja2 templates\n        \u2514\u2500\u2500 *.html\n</code></pre>"},{"location":"guides/extensions/#creating-extensions","title":"Creating Extensions","text":""},{"location":"guides/extensions/#using-the-cli","title":"Using the CLI","text":"<p>The recommended way to create extensions is using the Serv CLI:</p> <pre><code># Create a new extension\nserv create extension --name \"User Management\"\n\n# This creates:\n# - extensions/user_management/ directory\n# - extension.yaml with basic configuration\n# - user_management.py with extension class\n</code></pre>"},{"location":"guides/extensions/#generated-extension-structure","title":"Generated Extension Structure","text":"<p>After running the command above, you'll have:</p> <p>extensions/user_management/extension.yaml: <pre><code>name: User Management\ndescription: A cool Serv extension.\nversion: 0.1.0\nauthor: Your Name\n\n# Routes will be added here when you create them\nrouters: []\n\n# Middleware will be added here when you create them\nmiddleware: []\n\n# Entry points for additional listener classes\nentry_points: []\n</code></pre></p> <p>extensions/user_management/user_management.py: <pre><code>from serv.extensions import Listener\nfrom bevy import dependency\n\nclass UserManagement(Listener):\n    async def on_app_startup(self):\n        \"\"\"Called when the application starts up\"\"\"\n        print(\"User Management extension starting up\")\n\n    async def on_app_shutdown(self):\n        \"\"\"Called when the application shuts down\"\"\"\n        print(\"User Management extension shutting down\")\n</code></pre></p>"},{"location":"guides/extensions/#adding-routes-to-extensions","title":"Adding Routes to Extensions","text":""},{"location":"guides/extensions/#using-the-cli_1","title":"Using the CLI","text":"<p>Add routes to your extension using the CLI:</p> <pre><code># Add a route to the extension\nserv create route --name \"user_list\" --path \"/users\" --extension \"user_management\"\n\n# Add another route with a parameter\nserv create route --name \"user_detail\" --path \"/users/{id}\" --extension \"user_management\"\n\n# Add an API route to a specific router\nserv create route --name \"api_users\" --path \"/users\" --router \"api_router\" --extension \"user_management\"\n</code></pre>"},{"location":"guides/extensions/#updated-extension-configuration","title":"Updated Extension Configuration","text":"<p>After adding routes, your <code>extension.yaml</code> will be updated:</p> <pre><code>name: User Management\ndescription: A cool Serv extension.\nversion: 0.1.0\nauthor: Your Name\n\nrouters:\n  - name: main_router\n    routes:\n      - path: /users\n        handler: route_user_list:UserList\n      - path: /users/{id}\n        handler: route_user_detail:UserDetail\n\n  - name: api_router\n    mount: /api/v1\n    routes:\n      - path: /users\n        handler: route_api_users:ApiUsers\n</code></pre>"},{"location":"guides/extensions/#generated-route-handlers","title":"Generated Route Handlers","text":"<p>The CLI creates route handler files:</p> <p>extensions/user_management/route_user_list.py: <pre><code>from serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def UserList(response: ResponseBuilder = dependency(), **path_params):\n    \"\"\"Handle requests to /users\"\"\"\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;User List&lt;/h1&gt;\")\n</code></pre></p> <p>extensions/user_management/route_user_detail.py: <pre><code>from serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def UserDetail(user_id: str, response: ResponseBuilder = dependency()):\n    \"\"\"Handle requests to /users/{id}\"\"\"\n    response.content_type(\"text/html\")\n    response.body(f\"&lt;h1&gt;User {user_id}&lt;/h1&gt;\")\n</code></pre></p>"},{"location":"guides/extensions/#extension-events","title":"Extension Events","text":"<p>Listener classes are used exclusively for handling application events. Here are the key events:</p>"},{"location":"guides/extensions/#lifecycle-events","title":"Lifecycle Events","text":"<pre><code>from serv.extensions import Listener\nfrom bevy import dependency\n\nclass MyListener(Listener):\n    async def on_app_startup(self):\n        \"\"\"Called when the application starts\"\"\"\n        print(\"Application is starting up\")\n        # Initialize databases, external connections, etc.\n        self.database = await connect_to_database()\n\n    async def on_app_shutdown(self):\n        \"\"\"Called when the application shuts down\"\"\"\n        print(\"Application is shutting down\")\n        # Clean up resources, close connections, etc.\n        if hasattr(self, 'database'):\n            await self.database.close()\n</code></pre>"},{"location":"guides/extensions/#request-events","title":"Request Events","text":"<pre><code>class RequestLoggingListener(Listener):\n    async def on_app_request_begin(self, request = dependency()):\n        \"\"\"Called at the beginning of each request\"\"\"\n        print(f\"Request started: {request.method} {request.path}\")\n\n    async def on_app_request_before_router(self, request = dependency()):\n        \"\"\"Called before routing happens\"\"\"\n        # Log requests, add headers, etc.\n        print(f\"Processing {request.method} {request.path}\")\n\n    async def on_app_request_after_router(self, request = dependency(), error=None):\n        \"\"\"Called after routing (whether successful or not)\"\"\"\n        if error:\n            print(f\"Request failed: {error}\")\n        else:\n            print(f\"Request completed successfully\")\n\n    async def on_app_request_end(self, request = dependency(), error=None):\n        \"\"\"Called at the end of each request\"\"\"\n        print(f\"Request finished: {request.method} {request.path}\")\n</code></pre>"},{"location":"guides/extensions/#custom-events","title":"Custom Events","text":"<p>You can emit and handle custom events:</p> <pre><code>class UserListener(Listener):\n    async def on_user_created(self, user_id: int, email: str):\n        \"\"\"Handle custom user_created event\"\"\"\n        print(f\"User {user_id} created with email {email}\")\n        # Send welcome email, create user directory, etc.\n\n    async def on_user_deleted(self, user_id: int):\n        \"\"\"Handle custom user_deleted event\"\"\"\n        print(f\"User {user_id} deleted\")\n        # Clean up user data, send notifications, etc.\n\n# Emit custom events from your route handlers\nasync def CreateUser(request: PostRequest, app = dependency()):\n    # Create user logic here\n    user_id = create_user_in_database()\n\n    # Emit custom event\n    await app.emit(\"user_created\", user_id=user_id, email=user_email)\n</code></pre>"},{"location":"guides/extensions/#adding-middleware-to-extensions","title":"Adding Middleware to Extensions","text":""},{"location":"guides/extensions/#using-the-cli_2","title":"Using the CLI","text":"<p>Add middleware to your extension:</p> <pre><code>serv create middleware --name \"auth_check\" --extension \"user_management\"\n</code></pre> <p>This updates your <code>extension.yaml</code>:</p> <pre><code>name: User Management\n# ... other configuration ...\n\nmiddleware:\n  - entry: middleware_auth_check:auth_check_middleware\n    config:\n      timeout: 30\n</code></pre> <p>And creates extensions/user_management/middleware_auth_check.py:</p> <pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def auth_check_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Authentication middleware\"\"\"\n\n    # Check authentication before request\n    auth_header = request.headers.get(\"authorization\")\n    if not auth_header and request.path.startswith(\"/admin\"):\n        response.set_status(401)\n        response.body(\"Authentication required\")\n        return\n\n    yield  # Continue to next middleware/handler\n\n    # Code here runs after the request is handled\n    print(\"Auth check completed\")\n</code></pre>"},{"location":"guides/extensions/#extension-configuration","title":"Extension Configuration","text":""},{"location":"guides/extensions/#basic-configuration","title":"Basic Configuration","text":"<p>Define extension settings in <code>extension.yaml</code>:</p> <pre><code>name: User Management\ndescription: Handles user authentication and management\nversion: 1.0.0\nauthor: Your Name\n\n# Extension settings with defaults\nsettings:\n  database_url: \"sqlite:///users.db\"\n  session_timeout: 3600\n  enable_registration: true\n  admin_email: \"admin@example.com\"\n\nrouters:\n  - name: main_router\n    routes:\n      - path: /login\n        handler: route_login:LoginPage\n      - path: /register\n        handler: route_register:RegisterPage\n\nmiddleware:\n  - entry: middleware_auth:auth_middleware\n    config:\n      timeout: 30\n</code></pre>"},{"location":"guides/extensions/#accessing-configuration-in-extension-code","title":"Accessing Configuration in Extension Code","text":"<pre><code>class UserManagementListener(Listener):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # Access extension configuration\n        config = self.__extension_spec__.config\n        self.database_url = config.get(\"database_url\", \"sqlite:///users.db\")\n        self.session_timeout = config.get(\"session_timeout\", 3600)\n        self.enable_registration = config.get(\"enable_registration\", True)\n\n    async def on_app_startup(self):\n        \"\"\"Initialize extension with configuration\"\"\"\n        print(f\"Connecting to database: {self.database_url}\")\n        self.db = await connect_database(self.database_url)\n\n        if self.enable_registration:\n            print(\"User registration is enabled\")\n</code></pre>"},{"location":"guides/extensions/#application-level-configuration-override","title":"Application-Level Configuration Override","text":"<p>Users can override extension settings in their <code>serv.config.yaml</code>:</p> <pre><code>site_info:\n  name: \"My Application\"\n  description: \"A Serv application\"\n\nextensions:\n  - extension: user_management\n    settings:\n      database_url: \"postgresql://localhost/myapp\"\n      session_timeout: 7200\n      enable_registration: false\n      admin_email: \"admin@mycompany.com\"\n</code></pre>"},{"location":"guides/extensions/#advanced-extension-patterns","title":"Advanced Extension Patterns","text":""},{"location":"guides/extensions/#extension-with-database-integration","title":"Extension with Database Integration","text":"<pre><code>import asyncpg\nfrom serv.extensions import Listener\n\nclass DatabaseListener(Listener):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        config = self.__extension_spec__.config\n        self.database_url = config.get(\"database_url\")\n        self.pool = None\n\n    async def on_app_startup(self):\n        \"\"\"Initialize database connection pool\"\"\"\n        self.pool = await asyncpg.create_pool(self.database_url)\n        print(f\"Database pool created: {self.database_url}\")\n\n        # Make pool available to route handlers\n        from serv.app import get_current_app\n        app = get_current_app()\n        app._container.instances[asyncpg.Pool] = self.pool\n\n    async def on_app_shutdown(self):\n        \"\"\"Close database connections\"\"\"\n        if self.pool:\n            await self.pool.close()\n            print(\"Database pool closed\")\n</code></pre>"},{"location":"guides/extensions/#extension-with-external-service-integration","title":"Extension with External Service Integration","text":"<pre><code>import httpx\nfrom serv.extensions import Listener\n\nclass EmailListener(Listener):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        config = self.__extension_spec__.config\n        self.api_key = config.get(\"api_key\")\n        self.base_url = config.get(\"base_url\", \"https://api.emailservice.com\")\n        self.client = None\n\n    async def on_app_startup(self):\n        \"\"\"Initialize HTTP client for email service\"\"\"\n        self.client = httpx.AsyncClient(\n            base_url=self.base_url,\n            headers={\"Authorization\": f\"Bearer {self.api_key}\"}\n        )\n        print(\"Email service client initialized\")\n\n    async def on_app_shutdown(self):\n        \"\"\"Close HTTP client\"\"\"\n        if self.client:\n            await self.client.aclose()\n\n    async def on_user_created(self, user_id: int, email: str):\n        \"\"\"Send welcome email when user is created\"\"\"\n        if self.client:\n            await self.client.post(\"/send\", json={\n                \"to\": email,\n                \"template\": \"welcome\",\n                \"data\": {\"user_id\": user_id}\n            })\n</code></pre>"},{"location":"guides/extensions/#extension-with-scheduled-tasks","title":"Extension with Scheduled Tasks","text":"<pre><code>import asyncio\nfrom serv.extensions import Listener\n\nclass SchedulerListener(Listener):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.tasks = []\n\n    async def on_app_startup(self):\n        \"\"\"Start background tasks\"\"\"\n        # Start a cleanup task that runs every hour\n        task = asyncio.create_task(self._cleanup_task())\n        self.tasks.append(task)\n        print(\"Scheduler extension started background tasks\")\n\n    async def on_app_shutdown(self):\n        \"\"\"Cancel background tasks\"\"\"\n        for task in self.tasks:\n            task.cancel()\n        await asyncio.gather(*self.tasks, return_exceptions=True)\n        print(\"Scheduler extension stopped background tasks\")\n\n    async def _cleanup_task(self):\n        \"\"\"Background task that runs periodically\"\"\"\n        while True:\n            try:\n                print(\"Running cleanup task...\")\n                # Perform cleanup operations\n                await self._perform_cleanup()\n                await asyncio.sleep(3600)  # Wait 1 hour\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                print(f\"Cleanup task error: {e}\")\n                await asyncio.sleep(60)  # Wait 1 minute on error\n\n    async def _perform_cleanup(self):\n        \"\"\"Actual cleanup logic\"\"\"\n        # Clean up temporary files, expired sessions, etc.\n        pass\n</code></pre>"},{"location":"guides/extensions/#extension-management","title":"Extension Management","text":""},{"location":"guides/extensions/#enabling-and-disabling-extensions","title":"Enabling and Disabling Extensions","text":"<p>Use the CLI to manage extensions:</p> <pre><code># Enable a extension\nserv extension enable user_management\n\n# Disable a extension\nserv extension disable user_management\n\n# List all extensions\nserv extension list\n\n# List available extensions\nserv extension list --available\n\n# Validate extension configuration\nserv extension validate user_management\n\n# Validate all extensions\nserv extension validate --all\n</code></pre>"},{"location":"guides/extensions/#extension-dependencies","title":"Extension Dependencies","text":"<p>Define dependencies between extensions in <code>extension.yaml</code>:</p> <pre><code>name: Blog\ndescription: Blog functionality\nversion: 1.0.0\ndependencies:\n  - user_management  # Requires user management for authentication\n  - email_service    # Requires email service for notifications\n\nrouters:\n  - name: blog_router\n    routes:\n      - path: /blog\n        handler: route_blog_home:BlogHome\n      - path: /blog/new\n        handler: route_create_post:CreatePost  # Uses user auth\n</code></pre>"},{"location":"guides/extensions/#extension-entry-points","title":"Extension Entry Points","text":"<p>Define multiple entry points for complex extensions:</p> <pre><code>name: Admin Panel\ndescription: Administrative interface\nversion: 1.0.0\n\n# Main extension class\nentry: admin_panel:AdminPanelExtension\n\n# Additional entry points\nentry_points:\n  - entry: admin_auth:AdminAuthExtension\n    config:\n      require_2fa: true\n  - entry: admin_logging:AdminLoggingExtension\n    config:\n      log_level: \"DEBUG\"\n\nrouters:\n  - name: admin_router\n    mount: /admin\n    routes:\n      - path: /dashboard\n        handler: route_dashboard:AdminDashboard\n</code></pre>"},{"location":"guides/extensions/#testing-extensions","title":"Testing Extensions","text":""},{"location":"guides/extensions/#unit-testing-extension-events","title":"Unit Testing Extension Events","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom extensions.user_management.user_management import UserManagementExtension\n\n@pytest.mark.asyncio\nasync def test_extension_startup():\n    \"\"\"Test extension startup event\"\"\"\n    extension = UserManagementExtension()\n\n    # Mock the database connection\n    extension.connect_database = AsyncMock()\n\n    await extension.on_app_startup()\n\n    extension.connect_database.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_user_created_event():\n    \"\"\"Test custom user created event\"\"\"\n    extension = UserManagementExtension()\n    extension.send_welcome_email = AsyncMock()\n\n    await extension.on_user_created(user_id=123, email=\"test@example.com\")\n\n    extension.send_welcome_email.assert_called_once_with(\"test@example.com\")\n</code></pre>"},{"location":"guides/extensions/#integration-testing","title":"Integration Testing","text":"<pre><code>import pytest\nfrom httpx import AsyncClient\nfrom serv.app import App\n\n@pytest.mark.asyncio\nasync def test_extension_routes():\n    \"\"\"Test that extension routes work correctly\"\"\"\n    app = App(config=\"test_config.yaml\")\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test user list route\n        response = await client.get(\"/users\")\n        assert response.status_code == 200\n        assert \"User List\" in response.text\n\n        # Test user detail route\n        response = await client.get(\"/users/123\")\n        assert response.status_code == 200\n        assert \"User 123\" in response.text\n</code></pre>"},{"location":"guides/extensions/#testing-extension-configuration","title":"Testing Extension Configuration","text":"<pre><code>def test_extension_configuration():\n    \"\"\"Test extension configuration loading\"\"\"\n    from extensions.user_management.user_management import UserManagementExtension\n\n    # Mock extension spec with configuration\n    mock_spec = Mock()\n    mock_spec.config = {\n        \"database_url\": \"postgresql://test\",\n        \"session_timeout\": 1800\n    }\n\n    extension = UserManagementExtension(extension_spec=mock_spec)\n\n    assert extension.database_url == \"postgresql://test\"\n    assert extension.session_timeout == 1800\n</code></pre>"},{"location":"guides/extensions/#best-practices","title":"Best Practices","text":""},{"location":"guides/extensions/#1-use-cli-for-all-extension-operations","title":"1. Use CLI for All Extension Operations","text":"<pre><code># Good: Use CLI commands\nserv create extension --name \"My Feature\"\nserv create route --name \"feature_api\" --extension \"my_feature\"\nserv extension enable my_feature\n\n# Avoid: Manual file creation and configuration\n</code></pre>"},{"location":"guides/extensions/#2-keep-extension-classes-event-only","title":"2. Keep Extension Classes Event-Only","text":"<pre><code># Good: Extension class only handles events\nclass MyExtension(Extension):\n    async def on_app_startup(self):\n        # Initialize resources\n        pass\n\n    async def on_user_created(self, user_id: int):\n        # Handle custom event\n        pass\n\n# Avoid: Adding routes in extension class\nclass BadExtension(Extension):\n    async def on_app_request_begin(self, router = dependency()):\n        # Don't do this - use declarative routing instead\n        router.add_route(\"/bad\", self.bad_handler)\n</code></pre>"},{"location":"guides/extensions/#3-use-declarative-configuration","title":"3. Use Declarative Configuration","text":"<pre><code># Good: Define routes in extension.yaml\nrouters:\n  - name: api_router\n    mount: /api/v1\n    routes:\n      - path: /users\n        handler: route_users:UserList\n        methods: [\"GET\", \"POST\"]\n\n# Avoid: Programmatic route registration\n</code></pre>"},{"location":"guides/extensions/#4-organize-by-feature","title":"4. Organize by Feature","text":"<pre><code>extensions/\n\u251c\u2500\u2500 user_management/     # User-related functionality\n\u251c\u2500\u2500 blog/               # Blog functionality  \n\u251c\u2500\u2500 api/                # API endpoints\n\u251c\u2500\u2500 admin/              # Admin interface\n\u2514\u2500\u2500 email/              # Email service integration\n</code></pre>"},{"location":"guides/extensions/#5-handle-errors-gracefully","title":"5. Handle Errors Gracefully","text":"<pre><code>class RobustExtension(Extension):\n    async def on_app_startup(self):\n        try:\n            self.service = await initialize_external_service()\n        except Exception as e:\n            print(f\"Failed to initialize service: {e}\")\n            self.service = None\n\n    async def on_user_created(self, user_id: int, email: str):\n        if not self.service:\n            print(\"Service not available, skipping user notification\")\n            return\n\n        try:\n            await self.service.send_notification(email)\n        except Exception as e:\n            print(f\"Failed to send notification: {e}\")\n</code></pre>"},{"location":"guides/extensions/#6-document-your-extensions","title":"6. Document Your Extensions","text":"<pre><code># extension.yaml\nname: User Management\ndescription: |\n  Comprehensive user management system with authentication,\n  authorization, and user profile management.\n\n  Features:\n  - User registration and login\n  - Password reset functionality\n  - Role-based access control\n  - User profile management\n\n  Configuration:\n  - database_url: Database connection string\n  - session_timeout: Session timeout in seconds\n  - enable_registration: Allow new user registration\n\nversion: 1.0.0\nauthor: Your Name\n</code></pre>"},{"location":"guides/extensions/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/extensions/#1-plan-your-extension","title":"1. Plan Your Extension","text":"<p>Define what your extension will do: - What routes will it provide? - What events will it handle? - What configuration options will it need? - What dependencies does it have?</p>"},{"location":"guides/extensions/#2-create-the-extension","title":"2. Create the Extension","text":"<pre><code>serv create extension --name \"My Feature\"\n</code></pre>"},{"location":"guides/extensions/#3-add-routes","title":"3. Add Routes","text":"<pre><code>serv create route --name \"feature_home\" --path \"/feature\" --extension \"my_feature\"\nserv create route --name \"feature_api\" --path \"/api/feature\" --router \"api_router\" --extension \"my_feature\"\n</code></pre>"},{"location":"guides/extensions/#4-add-middleware-if-needed","title":"4. Add Middleware (if needed)","text":"<pre><code>serv create middleware --name \"feature_auth\" --extension \"my_feature\"\n</code></pre>"},{"location":"guides/extensions/#5-implement-event-handlers","title":"5. Implement Event Handlers","text":"<p>Edit the extension class to handle events:</p> <pre><code>class MyFeatureExtension(Extension):\n    async def on_app_startup(self):\n        # Initialize extension\n        pass\n\n    async def on_feature_event(self, data):\n        # Handle custom events\n        pass\n</code></pre>"},{"location":"guides/extensions/#6-configure-and-test","title":"6. Configure and Test","text":"<pre><code># Enable the extension\nserv extension enable my_feature\n\n# Validate configuration\nserv extension validate my_feature\n\n# Test the application\nserv --dev launch\n</code></pre>"},{"location":"guides/extensions/#next-steps","title":"Next Steps","text":"<ul> <li>Routing - Learn about declarative routing configuration</li> <li>Middleware - Add cross-cutting concerns to your application</li> <li>Dependency Injection - Master dependency injection patterns</li> <li>Configuration - Advanced configuration techniques </li> </ul>"},{"location":"guides/forms/","title":"Forms and Validation","text":"<p>Serv provides a powerful form handling system built around the <code>routes.Form</code> base class. This system automatically detects form submissions, handles type conversion, and integrates seamlessly with dataclasses, Pydantic models, and attrs classes for structured data processing.</p>"},{"location":"guides/forms/#overview","title":"Overview","text":"<p>Serv's form system is designed around automatic detection and type safety:</p> <ol> <li>Form Base Class: Inherit from <code>routes.Form</code> to define form structure</li> <li>Automatic Detection: Handler methods with <code>Form</code> parameters are automatically detected</li> <li>Type Conversion: Form data is automatically converted to the types specified in your form class</li> <li>Validation Integration: Works with dataclasses, Pydantic, and attrs for validation</li> <li>File Upload Support: Built-in handling for single and multiple file uploads</li> </ol> <p>The key concept is that when you create a dataclass (or Pydantic/attrs class) that inherits from <code>routes.Form</code>, Serv automatically detects form submissions and routes them to handler methods that accept that form type as a parameter.</p>"},{"location":"guides/forms/#basic-form-handling","title":"Basic Form Handling","text":""},{"location":"guides/forms/#creating-a-contact-form","title":"Creating a Contact Form","text":"<p>Let's start with a complete contact form example that demonstrates the core concepts:</p> <pre><code># Create a extension for contact functionality\nserv create extension --name \"Contact\"\n\n# Create a route to handle the contact form\nserv create route --name \"contact\" --path \"/contact\" --extension \"contact\"\n</code></pre> <p>extensions/contact/route_contact.py: <pre><code>from dataclasses import dataclass\nfrom typing import Annotated, Optional\nfrom serv.routes import Route, Form, GetRequest, HtmlResponse\nfrom serv.exceptions import HTTPBadRequestException\n\n@dataclass\nclass ContactForm(Form):\n    \"\"\"Contact form definition - inherits from routes.Form for auto-detection\"\"\"\n    name: str\n    email: str\n    message: str\n    phone: Optional[str] = None\n    newsletter: bool = False\n\nclass ContactRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Display the contact form\"\"\"\n        return \"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;Contact Us&lt;/title&gt;\n            &lt;style&gt;\n                body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; }\n                .form-group { margin-bottom: 15px; }\n                label { display: block; margin-bottom: 5px; font-weight: bold; }\n                input, textarea { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }\n                button { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; }\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;h1&gt;Contact Us&lt;/h1&gt;\n            &lt;form method=\"post\" action=\"/contact\"&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"name\"&gt;Name:&lt;/label&gt;\n                    &lt;input type=\"text\" id=\"name\" name=\"name\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"email\"&gt;Email:&lt;/label&gt;\n                    &lt;input type=\"email\" id=\"email\" name=\"email\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"phone\"&gt;Phone (optional):&lt;/label&gt;\n                    &lt;input type=\"tel\" id=\"phone\" name=\"phone\"&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"message\"&gt;Message:&lt;/label&gt;\n                    &lt;textarea id=\"message\" name=\"message\" rows=\"5\" required&gt;&lt;/textarea&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label&gt;\n                        &lt;input type=\"checkbox\" name=\"newsletter\" value=\"true\"&gt;\n                        Subscribe to newsletter\n                    &lt;/label&gt;\n                &lt;/div&gt;\n                &lt;button type=\"submit\"&gt;Send Message&lt;/button&gt;\n            &lt;/form&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n    async def handle_contact_form(self, form: ContactForm) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Handle contact form submission - automatically detected by Serv\"\"\"\n\n        # Validate form data (you can also use Pydantic validators)\n        if not form.name.strip():\n            raise HTTPBadRequestException(\"Name is required\")\n\n        if \"@\" not in form.email:\n            raise HTTPBadRequestException(\"Valid email is required\")\n\n        if len(form.message.strip()) &lt; 10:\n            raise HTTPBadRequestException(\"Message must be at least 10 characters\")\n\n        # Process the form (send email, save to database, etc.)\n        await self.process_contact(form)\n\n        return f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;&lt;title&gt;Thank You&lt;/title&gt;&lt;/head&gt;\n        &lt;body style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center;\"&gt;\n            &lt;h1 style=\"color: #28a745;\"&gt;Thank You, {form.name}!&lt;/h1&gt;\n            &lt;p&gt;Your message has been sent successfully. We'll get back to you soon.&lt;/p&gt;\n            &lt;a href=\"/contact\"&gt;Send Another Message&lt;/a&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n    async def process_contact(self, form: ContactForm):\n        \"\"\"Process the contact form submission\"\"\"\n        # In a real application, you might:\n        # - Send an email notification\n        # - Save to database\n        # - Add to CRM system\n        print(f\"Contact from {form.name} ({form.email}): {form.message}\")\n        if form.newsletter:\n            print(f\"Added {form.email} to newsletter\")\n</code></pre></p> <p>extensions/contact/extension.yaml: <pre><code>name: Contact\ndescription: Contact form handling\nversion: 1.0.0\n\nrouters:\n  - name: main_router\n    routes:\n      - path: /contact\n        handler: route_contact:ContactRoute\n</code></pre></p>"},{"location":"guides/forms/#how-form-detection-works","title":"How Form Detection Works","text":"<p>The magic happens in the <code>handle_contact_form</code> method. Serv automatically detects that this method should handle form submissions because:</p> <ol> <li>The method parameter <code>form: ContactForm</code> indicates it expects a <code>ContactForm</code> instance</li> <li><code>ContactForm</code> inherits from <code>routes.Form</code></li> <li>When a POST request is made to <code>/contact</code>, Serv automatically parses the form data and creates a <code>ContactForm</code> instance</li> <li>Type conversion happens automatically (strings to booleans, numbers, etc.)</li> </ol>"},{"location":"guides/forms/#file-upload-forms","title":"File Upload Forms","text":"<p>File uploads are handled seamlessly within the form system. Here's a comprehensive example:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List, Optional\nfrom serv.routes import Route, Form, GetRequest, HtmlResponse\nfrom serv.requests import UploadFile\n\n@dataclass\nclass DocumentUploadForm(Form):\n    \"\"\"Form for uploading documents with metadata\"\"\"\n    title: str\n    description: str\n    category: str\n    file: UploadFile  # Single file upload\n    attachments: List[UploadFile]  # Multiple file uploads\n    public: bool = False\n\nclass DocumentRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Display document upload form\"\"\"\n        return \"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;Upload Document&lt;/title&gt;\n            &lt;style&gt;\n                body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; }\n                .form-group { margin-bottom: 15px; }\n                label { display: block; margin-bottom: 5px; font-weight: bold; }\n                input, textarea, select { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }\n                input[type=\"file\"] { padding: 3px; }\n                button { background: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 4px; }\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;h1&gt;Upload Document&lt;/h1&gt;\n            &lt;form method=\"post\" action=\"/documents/upload\" enctype=\"multipart/form-data\"&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"title\"&gt;Document Title:&lt;/label&gt;\n                    &lt;input type=\"text\" id=\"title\" name=\"title\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"description\"&gt;Description:&lt;/label&gt;\n                    &lt;textarea id=\"description\" name=\"description\" rows=\"3\" required&gt;&lt;/textarea&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"category\"&gt;Category:&lt;/label&gt;\n                    &lt;select id=\"category\" name=\"category\" required&gt;\n                        &lt;option value=\"\"&gt;Select category...&lt;/option&gt;\n                        &lt;option value=\"report\"&gt;Report&lt;/option&gt;\n                        &lt;option value=\"presentation\"&gt;Presentation&lt;/option&gt;\n                        &lt;option value=\"spreadsheet\"&gt;Spreadsheet&lt;/option&gt;\n                        &lt;option value=\"other\"&gt;Other&lt;/option&gt;\n                    &lt;/select&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"file\"&gt;Main Document:&lt;/label&gt;\n                    &lt;input type=\"file\" id=\"file\" name=\"file\" required&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label for=\"attachments\"&gt;Additional Files (optional):&lt;/label&gt;\n                    &lt;input type=\"file\" id=\"attachments\" name=\"attachments\" multiple&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label&gt;\n                        &lt;input type=\"checkbox\" name=\"public\" value=\"true\"&gt;\n                        Make this document public\n                    &lt;/label&gt;\n                &lt;/div&gt;\n                &lt;button type=\"submit\"&gt;Upload Document&lt;/button&gt;\n            &lt;/form&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n    async def handle_document_upload_form(self, form: DocumentUploadForm) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Handle document upload form submission\"\"\"\n\n        # Validate file types\n        allowed_types = {'.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.txt'}\n\n        if not any(form.file.filename.lower().endswith(ext) for ext in allowed_types):\n            raise HTTPBadRequestException(\"Invalid file type for main document\")\n\n        # Validate file size (10MB limit)\n        if len(form.file.content) &gt; 10 * 1024 * 1024:\n            raise HTTPBadRequestException(\"File size must be less than 10MB\")\n\n        # Save main document\n        main_file_path = await self.save_file(form.file, form.category)\n\n        # Save attachments\n        attachment_paths = []\n        for attachment in form.attachments:\n            if attachment.filename:  # Only process if file was uploaded\n                attachment_path = await self.save_file(attachment, form.category)\n                attachment_paths.append(attachment_path)\n\n        # Save document metadata to database\n        document_id = await self.save_document_metadata(\n            title=form.title,\n            description=form.description,\n            category=form.category,\n            main_file=main_file_path,\n            attachments=attachment_paths,\n            public=form.public\n        )\n\n        return f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;&lt;title&gt;Upload Successful&lt;/title&gt;&lt;/head&gt;\n        &lt;body style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px;\"&gt;\n            &lt;h1 style=\"color: #28a745;\"&gt;Upload Successful!&lt;/h1&gt;\n            &lt;p&gt;&lt;strong&gt;Document:&lt;/strong&gt; {form.title}&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Category:&lt;/strong&gt; {form.category}&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Main File:&lt;/strong&gt; {form.file.filename}&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Attachments:&lt;/strong&gt; {len(form.attachments)} files&lt;/p&gt;\n            &lt;p&gt;&lt;strong&gt;Public:&lt;/strong&gt; {'Yes' if form.public else 'No'}&lt;/p&gt;\n            &lt;p&gt;Document ID: {document_id}&lt;/p&gt;\n            &lt;a href=\"/documents/upload\"&gt;Upload Another Document&lt;/a&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n    async def save_file(self, file: UploadFile, category: str) -&gt; str:\n        \"\"\"Save uploaded file to disk\"\"\"\n        import os\n        import uuid\n\n        # Create category directory if it doesn't exist\n        upload_dir = f\"uploads/{category}\"\n        os.makedirs(upload_dir, exist_ok=True)\n\n        # Generate unique filename\n        file_extension = os.path.splitext(file.filename)[1]\n        unique_filename = f\"{uuid.uuid4()}{file_extension}\"\n        file_path = os.path.join(upload_dir, unique_filename)\n\n        # Save file\n        with open(file_path, \"wb\") as f:\n            f.write(file.content)\n\n        return file_path\n\n    async def save_document_metadata(self, **kwargs) -&gt; str:\n        \"\"\"Save document metadata (mock implementation)\"\"\"\n        import uuid\n        document_id = str(uuid.uuid4())\n\n        # In a real application, save to database\n        print(f\"Saved document {document_id} with metadata: {kwargs}\")\n\n        return document_id\n</code></pre>"},{"location":"guides/forms/#file-upload-key-points","title":"File Upload Key Points","text":"<ul> <li>Single Files: Use <code>UploadFile</code> type for single file uploads</li> <li>Multiple Files: Use <code>List[UploadFile]</code> for multiple file uploads</li> <li>Form Encoding: Always use <code>enctype=\"multipart/form-data\"</code> in your HTML form</li> <li>File Validation: Check file types, sizes, and content before processing</li> <li>Storage: Save files to disk, cloud storage, or database as needed</li> </ul>"},{"location":"guides/forms/#advanced-validation-with-pydantic","title":"Advanced Validation with Pydantic","text":"<p>For more sophisticated validation, you can use Pydantic models instead of dataclasses:</p> <pre><code>from pydantic import BaseModel, EmailStr, validator\nfrom typing import List, Optional\nfrom serv.routes import Route, Form\n\nclass UserRegistrationForm(BaseModel, Form):\n    \"\"\"User registration form with Pydantic validation\"\"\"\n    username: str\n    email: EmailStr\n    password: str\n    confirm_password: str\n    age: int\n    interests: List[str] = []\n    terms_accepted: bool\n\n    @validator('username')\n    def username_must_be_alphanumeric(cls, v):\n        if not v.isalnum():\n            raise ValueError('Username must be alphanumeric')\n        if len(v) &lt; 3:\n            raise ValueError('Username must be at least 3 characters')\n        return v\n\n    @validator('password')\n    def password_strength(cls, v):\n        if len(v) &lt; 8:\n            raise ValueError('Password must be at least 8 characters')\n        if not any(c.isupper() for c in v):\n            raise ValueError('Password must contain uppercase letter')\n        if not any(c.isdigit() for c in v):\n            raise ValueError('Password must contain a number')\n        return v\n\n    @validator('confirm_password')\n    def passwords_match(cls, v, values):\n        if 'password' in values and v != values['password']:\n            raise ValueError('Passwords do not match')\n        return v\n\n    @validator('age')\n    def age_must_be_adult(cls, v):\n        if v &lt; 18:\n            raise ValueError('Must be 18 or older to register')\n        return v\n\n    @validator('terms_accepted')\n    def terms_must_be_accepted(cls, v):\n        if not v:\n            raise ValueError('You must accept the terms and conditions')\n        return v\n\nclass RegistrationRoute(Route):\n    async def handle_user_registration_form(self, form: UserRegistrationForm) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Handle user registration with automatic Pydantic validation\"\"\"\n\n        # If we reach here, all Pydantic validators have passed\n\n        # Check if username is already taken\n        if await self.username_exists(form.username):\n            raise HTTPBadRequestException(\"Username already taken\")\n\n        # Create user account\n        user_id = await self.create_user(form)\n\n        return {\n            \"success\": True,\n            \"message\": f\"Welcome, {form.username}! Your account has been created.\",\n            \"user_id\": user_id\n        }\n\n    async def username_exists(self, username: str) -&gt; bool:\n        \"\"\"Check if username already exists\"\"\"\n        # Mock implementation\n        return username.lower() in ['admin', 'test', 'user']\n\n    async def create_user(self, form: UserRegistrationForm) -&gt; str:\n        \"\"\"Create new user account\"\"\"\n        import uuid\n        user_id = str(uuid.uuid4())\n\n        # In real application, hash password and save to database\n        print(f\"Created user {user_id}: {form.username} ({form.email})\")\n\n        return user_id\n</code></pre>"},{"location":"guides/forms/#error-handling-and-validation","title":"Error Handling and Validation","text":""},{"location":"guides/forms/#handling-validation-errors","title":"Handling Validation Errors","text":"<p>When using Pydantic or custom validation, Serv automatically catches validation errors and can return appropriate responses:</p> <pre><code>from serv.exceptions import HTTPBadRequestException\nfrom pydantic import ValidationError\n\nclass FormRoute(Route):\n    async def handle_user_registration_form(self, form: UserRegistrationForm) -&gt; JsonResponse:\n        \"\"\"Handle registration with comprehensive error handling\"\"\"\n        try:\n            # Form validation happens automatically before this method is called\n            # If we reach here, basic validation passed\n\n            # Additional business logic validation\n            if await self.email_exists(form.email):\n                raise HTTPBadRequestException(\"Email address already registered\")\n\n            # Process successful registration\n            user_id = await self.create_user(form)\n\n            return JsonResponse({\n                \"success\": True,\n                \"user_id\": user_id,\n                \"message\": \"Registration successful\"\n            })\n\n        except ValidationError as e:\n            # Pydantic validation errors are automatically handled by Serv\n            # This catch block is for demonstration - normally not needed\n            return JsonResponse({\n                \"success\": False,\n                \"errors\": e.errors(),\n                \"message\": \"Validation failed\"\n            }, status_code=422)\n\n        except HTTPBadRequestException as e:\n            # Business logic validation errors\n            return JsonResponse({\n                \"success\": False,\n                \"message\": str(e)\n            }, status_code=400)\n</code></pre>"},{"location":"guides/forms/#best-practices","title":"Best Practices","text":""},{"location":"guides/forms/#1-use-type-hints-consistently","title":"1. Use Type Hints Consistently","text":"<p>Always use proper type hints in your form classes. This enables automatic type conversion and better IDE support:</p> <pre><code># Good: Clear type hints\n@dataclass\nclass ProductForm(Form):\n    name: str\n    price: float\n    quantity: int\n    available: bool\n    tags: List[str] = field(default_factory=list)\n\n# Avoid: No type hints\n@dataclass\nclass ProductForm(Form):\n    name = \"\"\n    price = 0.0\n    quantity = 0\n</code></pre>"},{"location":"guides/forms/#2-validate-early-and-often","title":"2. Validate Early and Often","text":"<p>Implement validation at multiple levels:</p> <pre><code># Good: Multiple validation layers\n@dataclass\nclass OrderForm(Form):\n    product_id: str\n    quantity: int\n\n    def __post_init__(self):\n        if self.quantity &lt;= 0:\n            raise ValueError(\"Quantity must be positive\")\n\nasync def handle_order_form(self, form: OrderForm):\n    # Business logic validation\n    if not await self.product_exists(form.product_id):\n        raise HTTPNotFoundException(\"Product not found\")\n\n    if not await self.has_sufficient_stock(form.product_id, form.quantity):\n        raise HTTPBadRequestException(\"Insufficient stock\")\n</code></pre>"},{"location":"guides/forms/#3-handle-file-uploads-securely","title":"3. Handle File Uploads Securely","text":"<p>Always validate file uploads thoroughly:</p> <pre><code># Good: Comprehensive file validation\nasync def handle_upload_form(self, form: FileUploadForm):\n    # Validate file type\n    allowed_extensions = {'.jpg', '.png', '.pdf', '.doc'}\n    file_ext = os.path.splitext(form.file.filename)[1].lower()\n\n    if file_ext not in allowed_extensions:\n        raise HTTPBadRequestException(f\"File type {file_ext} not allowed\")\n\n    # Validate file size\n    max_size = 5 * 1024 * 1024  # 5MB\n    if len(form.file.content) &gt; max_size:\n        raise HTTPBadRequestException(\"File too large\")\n\n    # Validate file content (basic check)\n    if not form.file.content:\n        raise HTTPBadRequestException(\"Empty file\")\n</code></pre>"},{"location":"guides/forms/#4-use-appropriate-response-types","title":"4. Use Appropriate Response Types","text":"<p>Return appropriate responses based on the request type:</p> <pre><code># Good: Context-aware responses\nasync def handle_contact_form(self, form: ContactForm, request: Request):\n    # Process form...\n\n    # Return JSON for API requests\n    if request.path.startswith('/api/') or 'application/json' in request.headers.get('accept', ''):\n        return JsonResponse({\"success\": True, \"message\": \"Contact sent\"})\n\n    # Return HTML for web requests\n    return HtmlResponse(\"&lt;h1&gt;Thank you! Your message has been sent.&lt;/h1&gt;\")\n</code></pre>"},{"location":"guides/forms/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/forms/#1-design-your-forms","title":"1. Design Your Forms","text":"<p>Start by identifying what data you need to collect and design your form classes:</p> <pre><code># Create extension for your forms\nserv create extension --name \"Forms\"\n\n# Create routes for each form\nserv create route --name \"contact\" --path \"/contact\" --extension \"forms\"\n</code></pre>"},{"location":"guides/forms/#2-implement-form-classes","title":"2. Implement Form Classes","text":"<p>Create form classes that inherit from <code>routes.Form</code> and use appropriate type hints.</p>"},{"location":"guides/forms/#3-create-handler-methods","title":"3. Create Handler Methods","text":"<p>Implement handler methods that accept your form classes as parameters. Serv will automatically detect and route to these methods.</p>"},{"location":"guides/forms/#4-add-validation","title":"4. Add Validation","text":"<p>Implement validation using dataclass <code>__post_init__</code>, Pydantic validators, or custom validation logic.</p>"},{"location":"guides/forms/#5-test-your-forms","title":"5. Test Your Forms","text":"<p>Test form submission, validation, and error handling thoroughly.</p>"},{"location":"guides/forms/#next-steps","title":"Next Steps","text":"<ul> <li>Request Handling - Learn more about processing different types of requests</li> <li>Response Building - Master different response types and patterns</li> <li>Error Handling - Implement comprehensive error handling</li> <li>Testing - Test your form handling logic </li> </ul>"},{"location":"guides/middleware/","title":"Middleware","text":"<p>Middleware in Serv provides a powerful way to add cross-cutting concerns to your application. This guide covers how to create, configure, and use middleware effectively using Serv's CLI-first approach and extension-based architecture.</p>"},{"location":"guides/middleware/#what-is-middleware","title":"What is Middleware?","text":"<p>Middleware are async generator functions that execute during the request/response cycle. They can:</p> <ul> <li>Process requests before they reach route handlers</li> <li>Modify responses before they're sent to clients</li> <li>Perform authentication and authorization</li> <li>Log requests and responses</li> <li>Handle errors and add security headers</li> <li>Implement rate limiting and caching</li> </ul>"},{"location":"guides/middleware/#middleware-architecture","title":"Middleware Architecture","text":""},{"location":"guides/middleware/#core-principles","title":"Core Principles","text":"<p>Serv middleware follows these principles:</p> <ul> <li>Extension-Based: Middleware is organized within extensions</li> <li>CLI-Created: Use CLI commands to create middleware</li> <li>Declarative Configuration: Middleware is configured in <code>extension.yaml</code> files</li> <li>Dependency Injection: Full access to Serv's DI system</li> </ul>"},{"location":"guides/middleware/#middleware-structure","title":"Middleware Structure","text":"<p>Middleware in Serv is organized within extensions:</p> <pre><code>extensions/\n\u2514\u2500\u2500 my_extension/\n    \u251c\u2500\u2500 extension.yaml\n    \u251c\u2500\u2500 middleware_auth.py\n    \u251c\u2500\u2500 middleware_logging.py\n    \u2514\u2500\u2500 middleware_cors.py\n</code></pre>"},{"location":"guides/middleware/#creating-middleware","title":"Creating Middleware","text":""},{"location":"guides/middleware/#using-the-cli","title":"Using the CLI","text":"<p>The recommended way to create middleware is using the Serv CLI:</p> <pre><code># Create a extension first (if you don't have one)\nserv create extension --name \"Security\"\n\n# Create middleware within the extension\nserv create middleware --name \"auth_check\" --extension \"security\"\n\n# Create another middleware\nserv create middleware --name \"rate_limiter\" --extension \"security\"\n</code></pre>"},{"location":"guides/middleware/#generated-middleware-structure","title":"Generated Middleware Structure","text":"<p>After running the commands above, you'll have:</p> <p>extensions/security/extension.yaml: <pre><code>name: Security\ndescription: A cool Serv extension.\nversion: 0.1.0\nauthor: Your Name\n\nmiddleware:\n  - entry: middleware_auth_check:auth_check_middleware\n    config:\n      timeout: 30\n  - entry: middleware_rate_limiter:rate_limiter_middleware\n    config:\n      requests_per_minute: 60\n</code></pre></p> <p>extensions/security/middleware_auth_check.py: <pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def auth_check_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Authentication middleware\"\"\"\n\n    # Code here runs before the request is handled\n    print(f\"Checking auth for {request.path}\")\n\n    yield  # Continue to next middleware/handler\n\n    # Code here runs after the request is handled\n    print(\"Auth check completed\")\n</code></pre></p>"},{"location":"guides/middleware/#basic-middleware-patterns","title":"Basic Middleware Patterns","text":""},{"location":"guides/middleware/#request-logging-middleware","title":"Request Logging Middleware","text":"<pre><code>import time\nfrom typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def logging_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Log all requests with timing information\"\"\"\n\n    start_time = time.time()\n    print(f\"\u2192 {request.method} {request.path}\")\n\n    yield  # Process the request\n\n    duration = time.time() - start_time\n    print(f\"\u2190 {request.method} {request.path} ({response.status_code}) {duration:.3f}s\")\n\n    # Add timing header\n    response.add_header(\"X-Response-Time\", f\"{duration:.3f}s\")\n</code></pre>"},{"location":"guides/middleware/#authentication-middleware","title":"Authentication Middleware","text":"<pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def auth_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Check authentication for protected routes\"\"\"\n\n    # Skip auth for public routes\n    if request.path.startswith(\"/public\") or request.path == \"/\":\n        yield\n        return\n\n    # Check for authentication token\n    auth_header = request.headers.get(\"authorization\")\n    if not auth_header:\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"Authentication required\"}')\n        return  # Don't yield - stop processing\n\n    # Validate token (implement your validation logic)\n    if not is_valid_token(auth_header):\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"Invalid token\"}')\n        return\n\n    # Add user info to request context for route handlers\n    user = get_user_from_token(auth_header)\n    request.context['user'] = user\n\n    yield  # Continue processing\n\ndef is_valid_token(token: str) -&gt; bool:\n    \"\"\"Implement your token validation logic\"\"\"\n    return token.startswith(\"Bearer \") and len(token) &gt; 20\n\ndef get_user_from_token(token: str) -&gt; dict:\n    \"\"\"Extract user information from token\"\"\"\n    return {\"id\": 123, \"username\": \"user\", \"role\": \"user\"}\n</code></pre>"},{"location":"guides/middleware/#cors-middleware","title":"CORS Middleware","text":"<pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def cors_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Handle CORS (Cross-Origin Resource Sharing)\"\"\"\n\n    # Handle preflight requests\n    if request.method == \"OPTIONS\":\n        response.add_header(\"Access-Control-Allow-Origin\", \"*\")\n        response.add_header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n        response.add_header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n        response.add_header(\"Access-Control-Max-Age\", \"86400\")\n        response.set_status(200)\n        response.body(\"\")\n        return\n\n    yield  # Process the request\n\n    # Add CORS headers to all responses\n    response.add_header(\"Access-Control-Allow-Origin\", \"*\")\n    response.add_header(\"Access-Control-Allow-Credentials\", \"true\")\n</code></pre>"},{"location":"guides/middleware/#rate-limiting-middleware","title":"Rate Limiting Middleware","text":"<pre><code>import time\nfrom collections import defaultdict\nfrom typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\n# Simple in-memory rate limiter (use Redis in production)\nrequest_counts = defaultdict(list)\n\nasync def rate_limiter_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Rate limit requests by IP address\"\"\"\n\n    client_ip = request.client.host if request.client else \"unknown\"\n    current_time = time.time()\n    window_size = 60  # 1 minute window\n    max_requests = 60  # 60 requests per minute\n\n    # Clean old requests (outside the time window)\n    request_counts[client_ip] = [\n        req_time for req_time in request_counts[client_ip]\n        if current_time - req_time &lt; window_size\n    ]\n\n    # Check rate limit\n    if len(request_counts[client_ip]) &gt;= max_requests:\n        response.set_status(429)\n        response.content_type(\"application/json\")\n        response.add_header(\"Retry-After\", \"60\")\n        response.body('{\"error\": \"Rate limit exceeded\", \"retry_after\": 60}')\n        return\n\n    # Record this request\n    request_counts[client_ip].append(current_time)\n\n    # Add rate limit headers\n    remaining = max_requests - len(request_counts[client_ip])\n    response.add_header(\"X-RateLimit-Limit\", str(max_requests))\n    response.add_header(\"X-RateLimit-Remaining\", str(remaining))\n    response.add_header(\"X-RateLimit-Reset\", str(int(current_time + window_size)))\n\n    yield  # Continue processing\n</code></pre>"},{"location":"guides/middleware/#advanced-middleware-patterns","title":"Advanced Middleware Patterns","text":""},{"location":"guides/middleware/#error-handling-middleware","title":"Error Handling Middleware","text":"<pre><code>import traceback\nfrom typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def error_handler_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Global error handling middleware\"\"\"\n\n    try:\n        yield  # Process the request\n    except ValueError as e:\n        # Handle validation errors\n        response.set_status(400)\n        response.content_type(\"application/json\")\n        response.body(f'{{\"error\": \"Bad request\", \"message\": \"{str(e)}\"}}')\n    except PermissionError as e:\n        # Handle permission errors\n        response.set_status(403)\n        response.content_type(\"application/json\")\n        response.body(f'{{\"error\": \"Forbidden\", \"message\": \"{str(e)}\"}}')\n    except FileNotFoundError as e:\n        # Handle not found errors\n        response.set_status(404)\n        response.content_type(\"application/json\")\n        response.body(f'{{\"error\": \"Not found\", \"message\": \"{str(e)}\"}}')\n    except Exception as e:\n        # Handle all other errors\n        print(f\"Unhandled error: {e}\")\n        print(traceback.format_exc())\n\n        response.set_status(500)\n        response.content_type(\"application/json\")\n        response.body('{\"error\": \"Internal server error\"}')\n</code></pre>"},{"location":"guides/middleware/#security-headers-middleware","title":"Security Headers Middleware","text":"<pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def security_headers_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Add security headers to all responses\"\"\"\n\n    yield  # Process the request\n\n    # Add security headers\n    response.add_header(\"X-Content-Type-Options\", \"nosniff\")\n    response.add_header(\"X-Frame-Options\", \"DENY\")\n    response.add_header(\"X-XSS-Protection\", \"1; mode=block\")\n    response.add_header(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\")\n    response.add_header(\"Referrer-Policy\", \"strict-origin-when-cross-origin\")\n    response.add_header(\"Content-Security-Policy\", \"default-src 'self'\")\n</code></pre>"},{"location":"guides/middleware/#database-transaction-middleware","title":"Database Transaction Middleware","text":"<pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\nimport asyncpg\n\nasync def database_transaction_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency(),\n    db_pool: asyncpg.Pool = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Wrap requests in database transactions\"\"\"\n\n    # Only use transactions for write operations\n    if request.method in [\"POST\", \"PUT\", \"DELETE\", \"PATCH\"]:\n        async with db_pool.acquire() as connection:\n            async with connection.transaction():\n                # Make connection available to route handlers\n                request.context['db_connection'] = connection\n\n                try:\n                    yield  # Process the request\n                    # Transaction commits automatically if no exception\n                except Exception:\n                    # Transaction rolls back automatically on exception\n                    raise\n    else:\n        # For read operations, just use a connection from the pool\n        async with db_pool.acquire() as connection:\n            request.context['db_connection'] = connection\n            yield\n</code></pre>"},{"location":"guides/middleware/#middleware-configuration","title":"Middleware Configuration","text":""},{"location":"guides/middleware/#extension-configuration","title":"Extension Configuration","text":"<p>Configure middleware in your extension's <code>extension.yaml</code>:</p> <pre><code>name: Security\ndescription: Security middleware for the application\nversion: 1.0.0\nauthor: Your Name\n\nmiddleware:\n  - entry: middleware_auth:auth_middleware\n    config:\n      secret_key: \"your-secret-key\"\n      token_expiry: 3600\n\n  - entry: middleware_rate_limiter:rate_limiter_middleware\n    config:\n      requests_per_minute: 100\n      window_size: 60\n\n  - entry: middleware_cors:cors_middleware\n    config:\n      allowed_origins: [\"http://localhost:3000\", \"https://myapp.com\"]\n      allowed_methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n</code></pre>"},{"location":"guides/middleware/#accessing-configuration-in-middleware","title":"Accessing Configuration in Middleware","text":"<pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def configurable_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Middleware that uses configuration\"\"\"\n\n    # Access middleware configuration\n    # (This would be injected by the extension system)\n    config = getattr(configurable_middleware, '_config', {})\n\n    max_requests = config.get('requests_per_minute', 60)\n    window_size = config.get('window_size', 60)\n\n    # Use configuration in middleware logic\n    if should_rate_limit(request, max_requests, window_size):\n        response.set_status(429)\n        response.body('{\"error\": \"Rate limit exceeded\"}')\n        return\n\n    yield\n\ndef should_rate_limit(request, max_requests, window_size):\n    \"\"\"Implement rate limiting logic\"\"\"\n    return False  # Placeholder\n</code></pre>"},{"location":"guides/middleware/#application-level-configuration-override","title":"Application-Level Configuration Override","text":"<p>Override middleware configuration in <code>serv.config.yaml</code>:</p> <pre><code>site_info:\n  name: \"My Application\"\n\nextensions:\n  - extension: security\n    settings:\n      middleware:\n        auth_middleware:\n          secret_key: \"production-secret-key\"\n          token_expiry: 7200\n        rate_limiter_middleware:\n          requests_per_minute: 200\n</code></pre>"},{"location":"guides/middleware/#middleware-execution-order","title":"Middleware Execution Order","text":""},{"location":"guides/middleware/#understanding-middleware-flow","title":"Understanding Middleware Flow","text":"<p>Middleware executes in a specific order:</p> <ol> <li>Request Phase: Middleware executes in the order they're registered</li> <li>Response Phase: Middleware executes in reverse order (LIFO)</li> </ol> <pre><code># Middleware execution order:\n# Request:  A \u2192 B \u2192 C \u2192 Route Handler\n# Response: Route Handler \u2192 C \u2192 B \u2192 A\n\nasync def middleware_a():\n    print(\"A: Before\")\n    yield\n    print(\"A: After\")\n\nasync def middleware_b():\n    print(\"B: Before\")\n    yield\n    print(\"B: After\")\n\nasync def middleware_c():\n    print(\"C: Before\")\n    yield\n    print(\"C: After\")\n\n# Output:\n# A: Before\n# B: Before  \n# C: Before\n# [Route Handler Executes]\n# C: After\n# B: After\n# A: After\n</code></pre>"},{"location":"guides/middleware/#extension-level-ordering","title":"Extension-Level Ordering","text":"<p>Control middleware order within extensions:</p> <pre><code>name: Security\nmiddleware:\n  # These execute in order\n  - entry: middleware_cors:cors_middleware        # 1st\n  - entry: middleware_auth:auth_middleware        # 2nd\n  - entry: middleware_rate_limiter:rate_limiter_middleware  # 3rd\n</code></pre>"},{"location":"guides/middleware/#global-middleware-order","title":"Global Middleware Order","text":"<p>Control order across extensions by extension loading order in <code>serv.config.yaml</code>:</p> <pre><code>extensions:\n  - extension: logging      # Logging middleware runs first\n  - extension: security     # Security middleware runs second\n  - extension: api          # API-specific middleware runs last\n</code></pre>"},{"location":"guides/middleware/#conditional-middleware","title":"Conditional Middleware","text":""},{"location":"guides/middleware/#path-based-middleware","title":"Path-Based Middleware","text":"<pre><code>from typing import AsyncIterator\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def api_only_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Middleware that only runs for API routes\"\"\"\n\n    if not request.path.startswith(\"/api/\"):\n        # Skip this middleware for non-API routes\n        yield\n        return\n\n    # API-specific logic here\n    response.add_header(\"X-API-Version\", \"v1\")\n\n    yield\n</code></pre>"},{"location":"guides/middleware/#method-based-middleware","title":"Method-Based Middleware","text":"<pre><code>async def write_only_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Middleware that only runs for write operations\"\"\"\n\n    if request.method not in [\"POST\", \"PUT\", \"DELETE\", \"PATCH\"]:\n        yield\n        return\n\n    # Write operation logic (validation, logging, etc.)\n    print(f\"Write operation: {request.method} {request.path}\")\n\n    yield\n</code></pre>"},{"location":"guides/middleware/#header-based-middleware","title":"Header-Based Middleware","text":"<pre><code>async def api_version_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Route to different handlers based on API version\"\"\"\n\n    api_version = request.headers.get(\"X-API-Version\", \"v1\")\n\n    if api_version == \"v2\":\n        # Add v2-specific processing\n        request.context['api_version'] = \"v2\"\n        response.add_header(\"X-API-Version\", \"v2\")\n    else:\n        # Default to v1\n        request.context['api_version'] = \"v1\"\n        response.add_header(\"X-API-Version\", \"v1\")\n\n    yield\n</code></pre>"},{"location":"guides/middleware/#testing-middleware","title":"Testing Middleware","text":""},{"location":"guides/middleware/#unit-testing-middleware","title":"Unit Testing Middleware","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom extensions.security.middleware_auth import auth_middleware\n\n@pytest.mark.asyncio\nasync def test_auth_middleware_success():\n    \"\"\"Test successful authentication\"\"\"\n    request = Mock()\n    request.path = \"/protected\"\n    request.headers = {\"authorization\": \"Bearer valid-token\"}\n    request.context = {}\n\n    response = Mock()\n\n    # Create async generator\n    middleware_gen = auth_middleware(request=request, response=response)\n\n    # Should yield without setting error status\n    await middleware_gen.__anext__()\n\n    # Check that user was added to context\n    assert \"user\" in request.context\n    assert request.context[\"user\"][\"username\"] == \"user\"\n\n@pytest.mark.asyncio\nasync def test_auth_middleware_missing_token():\n    \"\"\"Test missing authentication token\"\"\"\n    request = Mock()\n    request.path = \"/protected\"\n    request.headers = {}\n\n    response = Mock()\n\n    middleware_gen = auth_middleware(request=request, response=response)\n\n    # Should not yield (stops processing)\n    with pytest.raises(StopAsyncIteration):\n        await middleware_gen.__anext__()\n\n    # Check that 401 status was set\n    response.set_status.assert_called_with(401)\n</code></pre>"},{"location":"guides/middleware/#integration-testing","title":"Integration Testing","text":"<pre><code>import pytest\nfrom httpx import AsyncClient\nfrom serv.app import App\n\n@pytest.mark.asyncio\nasync def test_middleware_integration():\n    \"\"\"Test middleware in full application context\"\"\"\n    app = App(config=\"test_config.yaml\")\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test that middleware adds headers\n        response = await client.get(\"/api/test\")\n        assert \"X-API-Version\" in response.headers\n        assert response.headers[\"X-API-Version\"] == \"v1\"\n\n        # Test rate limiting\n        for _ in range(65):  # Exceed rate limit\n            await client.get(\"/api/test\")\n\n        response = await client.get(\"/api/test\")\n        assert response.status_code == 429\n</code></pre>"},{"location":"guides/middleware/#testing-middleware-configuration","title":"Testing Middleware Configuration","text":"<pre><code>def test_middleware_configuration():\n    \"\"\"Test middleware configuration loading\"\"\"\n    from extensions.security.middleware_rate_limiter import rate_limiter_middleware\n\n    # Mock configuration\n    config = {\n        \"requests_per_minute\": 100,\n        \"window_size\": 60\n    }\n\n    # Test that middleware uses configuration\n    rate_limiter_middleware._config = config\n\n    # Test middleware behavior with configuration\n    # (Implementation depends on how you access config in middleware)\n</code></pre>"},{"location":"guides/middleware/#best-practices","title":"Best Practices","text":""},{"location":"guides/middleware/#1-use-cli-for-middleware-creation","title":"1. Use CLI for Middleware Creation","text":"<pre><code># Good: Use CLI commands\nserv create middleware --name \"auth_check\" --extension \"security\"\n\n# Avoid: Manual file creation\n</code></pre>"},{"location":"guides/middleware/#2-keep-middleware-focused","title":"2. Keep Middleware Focused","text":"<pre><code># Good: Single responsibility\nasync def auth_middleware():\n    \"\"\"Only handles authentication\"\"\"\n    pass\n\nasync def logging_middleware():\n    \"\"\"Only handles logging\"\"\"\n    pass\n\n# Avoid: Multiple responsibilities\nasync def everything_middleware():\n    \"\"\"Handles auth, logging, rate limiting, etc.\"\"\"\n    pass\n</code></pre>"},{"location":"guides/middleware/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>async def robust_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Middleware with proper error handling\"\"\"\n\n    try:\n        # Pre-processing logic\n        result = await some_external_service()\n        request.context['service_data'] = result\n    except Exception as e:\n        # Log error but don't fail the request\n        print(f\"Service unavailable: {e}\")\n        request.context['service_data'] = None\n\n    yield\n\n    try:\n        # Post-processing logic\n        await cleanup_resources()\n    except Exception as e:\n        # Log cleanup errors\n        print(f\"Cleanup failed: {e}\")\n</code></pre>"},{"location":"guides/middleware/#4-use-dependency-injection","title":"4. Use Dependency Injection","text":"<pre><code>async def database_middleware(\n    request: Request = dependency(),\n    db_pool: asyncpg.Pool = dependency(),\n    cache: RedisCache = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Leverage DI for clean middleware\"\"\"\n\n    # Use injected dependencies\n    async with db_pool.acquire() as conn:\n        request.context['db'] = conn\n\n        # Check cache first\n        cached = await cache.get(f\"user:{request.user_id}\")\n        if cached:\n            request.context['user'] = cached\n\n        yield\n</code></pre>"},{"location":"guides/middleware/#5-document-middleware-behavior","title":"5. Document Middleware Behavior","text":"<pre><code>async def auth_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Authentication middleware.\n\n    Checks for valid authentication tokens and adds user information\n    to the request context.\n\n    Request Context:\n        - Adds 'user' dict with user information if authenticated\n\n    Response Headers:\n        - None\n\n    Status Codes:\n        - 401: Missing or invalid authentication token\n\n    Configuration:\n        - secret_key: JWT secret key\n        - token_expiry: Token expiration time in seconds\n    \"\"\"\n    pass\n</code></pre>"},{"location":"guides/middleware/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/middleware/#1-plan-your-middleware","title":"1. Plan Your Middleware","text":"<p>Identify what cross-cutting concerns your application needs: - Authentication and authorization - Request/response logging - Rate limiting - CORS handling - Error handling - Security headers</p>"},{"location":"guides/middleware/#2-create-extension-and-middleware","title":"2. Create Extension and Middleware","text":"<pre><code># Create a extension for your middleware\nserv create extension --name \"Security\"\n\n# Add middleware to the extension\nserv create middleware --name \"auth_check\" --extension \"security\"\nserv create middleware --name \"rate_limiter\" --extension \"security\"\nserv create middleware --name \"cors_handler\" --extension \"security\"\n</code></pre>"},{"location":"guides/middleware/#3-implement-middleware-logic","title":"3. Implement Middleware Logic","text":"<p>Edit the generated middleware files to implement your logic.</p>"},{"location":"guides/middleware/#4-configure-middleware","title":"4. Configure Middleware","text":"<p>Update the extension's <code>extension.yaml</code> with appropriate configuration.</p>"},{"location":"guides/middleware/#5-enable-and-test","title":"5. Enable and Test","text":"<pre><code># Enable the extension\nserv extension enable security\n\n# Test the application\nserv --dev launch\n\n# Run tests\nserv test\n</code></pre>"},{"location":"guides/middleware/#next-steps","title":"Next Steps","text":"<ul> <li>Extensions - Learn about extension architecture and organization</li> <li>Routing - Understand how middleware interacts with routes</li> <li>Dependency Injection - Master DI patterns for middleware</li> <li>Error Handling - Advanced error handling techniques </li> </ul>"},{"location":"guides/requests/","title":"Request Handling","text":"<p>Serv provides powerful request handling capabilities through specialized request objects and automatic parameter injection. This guide covers everything you need to know about processing HTTP requests in Serv applications.</p>"},{"location":"guides/requests/#overview","title":"Overview","text":"<p>Serv's request handling features:</p> <ol> <li>Signature-Based Routing: Automatic handler selection based on method signatures</li> <li>Parameter Injection: Direct injection of query params, headers, and cookies via annotations</li> <li>Typed Request Objects: Specialized request classes for different HTTP methods</li> <li>Body Parsing: JSON, form data, and file uploads with automatic form matching</li> <li>Route Classes: Clean separation using Route classes with multiple handlers per method</li> </ol>"},{"location":"guides/requests/#request-types","title":"Request Types","text":"<p>Serv provides specialized request classes for different HTTP methods:</p>"},{"location":"guides/requests/#basic-request-types","title":"Basic Request Types","text":"<pre><code>from serv.routes import Route, GetRequest, PostRequest, PutRequest, DeleteRequest\nfrom typing import Annotated\nfrom serv.responses import JsonResponse\n\nclass ApiRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Handle GET requests\"\"\"\n        return {\"method\": \"GET\", \"path\": request.path}\n\n    async def handle_post(self, request: PostRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Handle POST requests\"\"\"\n        return {\"method\": \"POST\", \"path\": request.path}\n\n    async def handle_put(self, request: PutRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Handle PUT requests\"\"\"\n        return {\"method\": \"PUT\", \"path\": request.path}\n\n    async def handle_delete(self, request: DeleteRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Handle DELETE requests\"\"\"\n        return {\"method\": \"DELETE\", \"path\": request.path}\n</code></pre>"},{"location":"guides/requests/#request-object-properties","title":"Request Object Properties","text":"<p>All request objects provide access to common HTTP request data:</p> <pre><code>from serv.routes import Route, GetRequest\nfrom typing import Annotated\nfrom serv.responses import JsonResponse\n\nclass RequestInfoRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Display request information\"\"\"\n        return {\n            \"method\": request.method,\n            \"path\": request.path,\n            \"query_string\": request.query_string,\n            \"headers\": dict(request.headers),\n            \"client\": request.client,\n            \"scheme\": request.scheme,\n            \"server\": request.server,\n            \"path_params\": request.path_params,\n            \"query_params\": dict(request.query_params)\n        }\n</code></pre>"},{"location":"guides/requests/#path-parameters","title":"Path Parameters","text":""},{"location":"guides/requests/#basic-path-parameters","title":"Basic Path Parameters","text":"<p>Extract path parameters from URL patterns:</p> <pre><code>from serv.routes import Route, GetRequest\nfrom typing import Annotated\nfrom serv.responses import JsonResponse\n\nclass UserRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Get user by ID from path parameter\"\"\"\n        user_id = request.path_params.get(\"user_id\")\n\n        if not user_id:\n            return {\"error\": \"User ID is required\"}\n\n        # Fetch user data\n        user = await self.get_user(user_id)\n\n        return {\"user\": user}\n\n    async def get_user(self, user_id: str):\n        \"\"\"Mock user retrieval\"\"\"\n        return {\n            \"id\": user_id,\n            \"name\": f\"User {user_id}\",\n            \"email\": f\"user{user_id}@example.com\"\n        }\n</code></pre> <p>Extension configuration: <pre><code>routers:\n  - name: main_router\n    routes:\n      - path: /users/{user_id}\n        handler: route_user:UserRoute\n</code></pre></p>"},{"location":"guides/requests/#multiple-path-parameters","title":"Multiple Path Parameters","text":"<p>Handle multiple path parameters:</p> <pre><code>class PostRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Get post by user ID and post ID\"\"\"\n        user_id = request.path_params.get(\"user_id\")\n        post_id = request.path_params.get(\"post_id\")\n\n        if not user_id or not post_id:\n            return {\"error\": \"Both user_id and post_id are required\"}\n\n        post = await self.get_post(user_id, post_id)\n        return {\"post\": post}\n\n    async def get_post(self, user_id: str, post_id: str):\n        \"\"\"Mock post retrieval\"\"\"\n        return {\n            \"id\": post_id,\n            \"user_id\": user_id,\n            \"title\": f\"Post {post_id} by User {user_id}\",\n            \"content\": \"Sample post content\"\n        }\n</code></pre> <p>Extension configuration: <pre><code>routers:\n  - name: main_router\n    routes:\n      - path: /users/{user_id}/posts/{post_id}\n        handler: route_post:PostRoute\n</code></pre></p>"},{"location":"guides/requests/#path-parameter-validation","title":"Path Parameter Validation","text":"<p>Validate and convert path parameters:</p> <pre><code>from serv.exceptions import HTTPBadRequestException, HTTPNotFoundException\n\nclass ValidatedUserRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Get user with validated ID\"\"\"\n        user_id_str = request.path_params.get(\"user_id\")\n\n        # Validate user ID is numeric\n        try:\n            user_id = int(user_id_str)\n        except (ValueError, TypeError):\n            raise HTTPBadRequestException(\"User ID must be a number\")\n\n        # Validate user ID is positive\n        if user_id &lt;= 0:\n            raise HTTPBadRequestException(\"User ID must be positive\")\n\n        # Check if user exists\n        user = await self.get_user(user_id)\n        if not user:\n            raise HTTPNotFoundException(f\"User {user_id} not found\")\n\n        return {\"user\": user}\n\n    async def get_user(self, user_id: int):\n        \"\"\"Get user by numeric ID\"\"\"\n        # Mock database lookup\n        if user_id &gt; 1000:\n            return None  # User not found\n\n        return {\n            \"id\": user_id,\n            \"name\": f\"User {user_id}\",\n            \"email\": f\"user{user_id}@example.com\"\n        }\n</code></pre>"},{"location":"guides/requests/#query-parameters","title":"Query Parameters","text":""},{"location":"guides/requests/#basic-query-parameters-with-signature-based-routing","title":"Basic Query Parameters with Signature-Based Routing","text":"<p>Use parameter injection for clean, automatic query parameter handling:</p> <pre><code>from serv.injectors import Query\nfrom serv.exceptions import HTTPBadRequestException\n\nclass SearchRoute(Route):\n    async def handle_get(self) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Default search - no parameters\"\"\"\n        results = await self.get_default_results()\n        return {\"results\": results, \"message\": \"Default search results\"}\n\n    async def handle_get_with_query(\n        self,\n        query: Annotated[str, Query(\"q\")]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Search with query string only\"\"\"\n        results = await self.search(query)\n        return {\"query\": query, \"results\": results}\n\n    async def handle_get_paginated(\n        self,\n        query: Annotated[str, Query(\"q\")],\n        page: Annotated[str, Query(\"page\", default=\"1\")],\n        limit: Annotated[str, Query(\"limit\", default=\"10\")]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Search with pagination\"\"\"\n        # Convert and validate parameters\n        try:\n            page_num = int(page)\n            limit_num = int(limit)\n        except ValueError:\n            raise HTTPBadRequestException(\"Page and limit must be numbers\")\n\n        if page_num &lt; 1:\n            raise HTTPBadRequestException(\"Page must be &gt;= 1\")\n\n        if limit_num &lt; 1 or limit_num &gt; 100:\n            raise HTTPBadRequestException(\"Limit must be between 1 and 100\")\n\n        # Perform paginated search\n        results = await self.search_paginated(query, page_num, limit_num)\n\n        return {\n            \"query\": query,\n            \"page\": page_num,\n            \"limit\": limit_num,\n            \"results\": results,\n            \"total\": len(results)\n        }\n\n    async def handle_get_advanced(\n        self,\n        query: Annotated[str, Query(\"q\")],\n        page: Annotated[str, Query(\"page\", default=\"1\")],\n        limit: Annotated[str, Query(\"limit\", default=\"10\")],\n        sort: Annotated[str, Query(\"sort\", default=\"created_at\")],\n        category: Annotated[str, Query(\"category\", default=None)]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Advanced search with all options\"\"\"\n        page_num = int(page)\n        limit_num = int(limit)\n\n        results = await self.advanced_search(query, page_num, limit_num, sort, category)\n\n        return {\n            \"query\": query,\n            \"page\": page_num,\n            \"limit\": limit_num,\n            \"sort\": sort,\n            \"category\": category,\n            \"results\": results\n        }\n</code></pre> <p>Request routing examples: - <code>GET /search</code> \u2192 <code>handle_get</code> (no parameters) - <code>GET /search?q=python</code> \u2192 <code>handle_get_with_query</code> (has query only) - <code>GET /search?q=python&amp;page=2</code> \u2192 <code>handle_get_paginated</code> (has query and pagination) - <code>GET /search?q=python&amp;page=2&amp;sort=date&amp;category=tech</code> \u2192 <code>handle_get_advanced</code> (most specific)</p>"},{"location":"guides/requests/#multiple-values-for-same-parameter","title":"Multiple Values for Same Parameter","text":"<p>Handle query parameters with multiple values:</p> <pre><code>class FilterRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Filter with multiple values\"\"\"\n        # Get multiple values for the same parameter\n        categories = request.query_params.getlist(\"category\")\n        tags = request.query_params.getlist(\"tag\")\n\n        # Get single values with defaults\n        min_price = float(request.query_params.get(\"min_price\", \"0\"))\n        max_price = float(request.query_params.get(\"max_price\", \"1000\"))\n\n        # Apply filters\n        products = await self.filter_products(categories, tags, min_price, max_price)\n\n        return {\n            \"filters\": {\n                \"categories\": categories,\n                \"tags\": tags,\n                \"min_price\": min_price,\n                \"max_price\": max_price\n            },\n            \"products\": products\n        }\n\n    async def filter_products(self, categories, tags, min_price, max_price):\n        \"\"\"Mock product filtering\"\"\"\n        return [\n            {\n                \"id\": 1,\n                \"name\": \"Product 1\",\n                \"categories\": categories[:1] if categories else [\"general\"],\n                \"tags\": tags[:2] if tags else [\"sample\"],\n                \"price\": (min_price + max_price) / 2\n            }\n        ]\n</code></pre> <p>Example URLs: <pre><code>/filter?category=electronics&amp;category=computers&amp;tag=laptop&amp;tag=gaming&amp;min_price=500&amp;max_price=2000\n</code></pre></p>"},{"location":"guides/requests/#headers","title":"Headers","text":""},{"location":"guides/requests/#accessing-headers","title":"Accessing Headers","text":"<p>Read HTTP headers from requests using direct access or dependency injection:</p> <pre><code>from serv.injectors import Header\nfrom typing import Annotated\nfrom bevy import dependency\n\nclass HeaderRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Display request headers using direct access\"\"\"\n        # Get specific headers\n        user_agent = request.headers.get(\"user-agent\", \"Unknown\")\n        accept = request.headers.get(\"accept\", \"*/*\")\n        authorization = request.headers.get(\"authorization\")\n\n        # Get custom headers\n        api_key = request.headers.get(\"x-api-key\")\n        client_version = request.headers.get(\"x-client-version\")\n\n        return {\n            \"user_agent\": user_agent,\n            \"accept\": accept,\n            \"has_auth\": authorization is not None,\n            \"api_key\": api_key,\n            \"client_version\": client_version,\n            \"all_headers\": dict(request.headers)\n        }\n\nclass HeaderInjectionRoute(Route):\n    async def handle_get(\n        self,\n        request: GetRequest,\n        # Inject specific headers with defaults\n        user_agent: Annotated[str, Header(\"user-agent\", \"Unknown\")] = dependency(),\n        api_key: Annotated[str, Header(\"x-api-key\")] = dependency(),\n        auth_token: Annotated[str, Header(\"authorization\")] = dependency(),\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Display request headers using dependency injection\"\"\"\n        return {\n            \"user_agent\": user_agent,\n            \"api_key\": api_key,\n            \"has_auth\": auth_token is not None,\n            \"path\": request.path\n        }\n</code></pre>"},{"location":"guides/requests/#header-based-authentication","title":"Header-Based Authentication","text":"<p>Use headers for authentication:</p> <pre><code>from serv.exceptions import HTTPUnauthorizedException\n\nclass AuthenticatedRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Require authentication via header\"\"\"\n        # Check for API key\n        api_key = request.headers.get(\"x-api-key\")\n        if not api_key:\n            raise HTTPUnauthorizedException(\"API key required\")\n\n        # Validate API key\n        user = await self.validate_api_key(api_key)\n        if not user:\n            raise HTTPUnauthorizedException(\"Invalid API key\")\n\n        return {\n            \"message\": \"Authenticated successfully\",\n            \"user\": user\n        }\n\n    async def validate_api_key(self, api_key: str):\n        \"\"\"Validate API key and return user\"\"\"\n        # Mock validation\n        valid_keys = {\n            \"key123\": {\"id\": 1, \"name\": \"John Doe\"},\n            \"key456\": {\"id\": 2, \"name\": \"Jane Smith\"}\n        }\n\n        return valid_keys.get(api_key)\n</code></pre>"},{"location":"guides/requests/#content-negotiation","title":"Content Negotiation","text":"<p>Handle content negotiation based on Accept header:</p> <pre><code>from serv.responses import JsonResponse, HtmlResponse, TextResponse\n\nclass ContentNegotiationRoute(Route):\n    async def handle_get(self, request: GetRequest):\n        \"\"\"Return different content based on Accept header\"\"\"\n        accept = request.headers.get(\"accept\", \"\")\n\n        data = {\n            \"message\": \"Hello, World!\",\n            \"timestamp\": \"2024-01-01T12:00:00Z\"\n        }\n\n        if \"application/json\" in accept:\n            return JsonResponse(data)\n        elif \"text/html\" in accept:\n            html_content = f\"\"\"\n            &lt;html&gt;\n                &lt;body&gt;\n                    &lt;h1&gt;{data['message']}&lt;/h1&gt;\n                    &lt;p&gt;Timestamp: {data['timestamp']}&lt;/p&gt;\n                &lt;/body&gt;\n            &lt;/html&gt;\n            \"\"\"\n            return HtmlResponse(html_content)\n        else:\n            text_content = f\"{data['message']} at {data['timestamp']}\"\n            return TextResponse(text_content)\n</code></pre>"},{"location":"guides/requests/#request-body","title":"Request Body","text":""},{"location":"guides/requests/#json-body","title":"JSON Body","text":"<p>Parse JSON request bodies:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass CreateUserRequest:\n    name: str\n    email: str\n    age: int\n\nclass UserCreateRoute(Route):\n    async def handle_post(self, request: PostRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Create user from JSON body\"\"\"\n        try:\n            # Parse JSON body\n            data = await request.json()\n\n            # Validate required fields\n            if not data.get(\"name\"):\n                raise HTTPBadRequestException(\"Name is required\")\n\n            if not data.get(\"email\") or \"@\" not in data[\"email\"]:\n                raise HTTPBadRequestException(\"Valid email is required\")\n\n            # Create user\n            user = await self.create_user(data)\n\n            return {\"user\": user, \"message\": \"User created successfully\"}\n\n        except ValueError as e:\n            raise HTTPBadRequestException(f\"Invalid JSON: {str(e)}\")\n\n    async def create_user(self, data):\n        \"\"\"Create user in database\"\"\"\n        return {\n            \"id\": 123,\n            \"name\": data[\"name\"],\n            \"email\": data[\"email\"],\n            \"age\": data.get(\"age\", 0)\n        }\n</code></pre>"},{"location":"guides/requests/#raw-body","title":"Raw Body","text":"<p>Access raw request body:</p> <pre><code>class WebhookRoute(Route):\n    async def handle_post(self, request: PostRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Handle webhook with raw body\"\"\"\n        # Get raw body as bytes\n        body = await request.body()\n\n        # Get content type\n        content_type = request.headers.get(\"content-type\", \"\")\n\n        # Process based on content type\n        if content_type.startswith(\"application/json\"):\n            import json\n            data = json.loads(body.decode())\n        elif content_type.startswith(\"application/xml\"):\n            # Handle XML\n            data = {\"xml\": body.decode()}\n        else:\n            # Handle as text\n            data = {\"text\": body.decode()}\n\n        # Process webhook\n        result = await self.process_webhook(data, content_type)\n\n        return {\"status\": \"processed\", \"result\": result}\n\n    async def process_webhook(self, data, content_type):\n        \"\"\"Process webhook data\"\"\"\n        return {\n            \"received_at\": \"2024-01-01T12:00:00Z\",\n            \"content_type\": content_type,\n            \"data_keys\": list(data.keys()) if isinstance(data, dict) else None\n        }\n</code></pre>"},{"location":"guides/requests/#stream-processing","title":"Stream Processing","text":"<p>Handle large request bodies with streaming:</p> <pre><code>class UploadRoute(Route):\n    async def handle_post(self, request: PostRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Handle large file upload with streaming\"\"\"\n        content_length = int(request.headers.get(\"content-length\", \"0\"))\n\n        # Check file size limit (10MB)\n        max_size = 10 * 1024 * 1024\n        if content_length &gt; max_size:\n            raise HTTPBadRequestException(\"File too large\")\n\n        # Stream the body\n        chunks = []\n        async for chunk in request.stream():\n            chunks.append(chunk)\n\n        # Combine chunks\n        body = b\"\".join(chunks)\n\n        # Save file\n        filename = await self.save_file(body)\n\n        return {\n            \"filename\": filename,\n            \"size\": len(body),\n            \"message\": \"File uploaded successfully\"\n        }\n\n    async def save_file(self, content: bytes) -&gt; str:\n        \"\"\"Save uploaded file\"\"\"\n        import uuid\n        filename = f\"upload_{uuid.uuid4().hex}.bin\"\n\n        with open(f\"uploads/{filename}\", \"wb\") as f:\n            f.write(content)\n\n        return filename\n</code></pre>"},{"location":"guides/requests/#cookies","title":"Cookies","text":""},{"location":"guides/requests/#accessing-cookies","title":"Accessing Cookies","text":"<p>Access cookies using direct access or dependency injection:</p> <pre><code>from serv.injectors import Cookie\n\nclass CookieRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Access cookies using direct access\"\"\"\n        # Get cookies directly from request\n        session_id = request.cookies.get(\"session_id\")\n        theme = request.cookies.get(\"theme\", \"light\")\n        language = request.cookies.get(\"language\", \"en\")\n\n        return {\n            \"session_id\": session_id,\n            \"theme\": theme,\n            \"language\": language,\n            \"all_cookies\": request.cookies\n        }\n\nclass CookieInjectionRoute(Route):\n    async def handle_get(\n        self,\n        request: GetRequest,\n        # Inject specific cookies with defaults\n        session_id: Annotated[str, Cookie(\"session_id\")] = dependency(),\n        theme: Annotated[str, Cookie(\"theme\", \"light\")] = dependency(),\n        language: Annotated[str, Cookie(\"language\", \"en\")] = dependency(),\n        user_id: Annotated[str, Cookie(\"user_id\")] = dependency(),\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Access cookies using dependency injection\"\"\"\n\n        # Check if user is logged in\n        is_authenticated = session_id is not None and user_id is not None\n\n        return {\n            \"is_authenticated\": is_authenticated,\n            \"user_id\": user_id,\n            \"theme\": theme,\n            \"language\": language,\n            \"path\": request.path\n        }\n\nclass AuthenticatedCookieRoute(Route):\n    async def handle_get(\n        self,\n        request: GetRequest,\n        session_id: Annotated[str, Cookie(\"session_id\")] = dependency(),\n        user_id: Annotated[str, Cookie(\"user_id\")] = dependency(),\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Route that requires authentication via cookies\"\"\"\n\n        if not session_id or not user_id:\n            raise HTTPUnauthorizedException(\"Authentication required\")\n\n        # Validate session (in real app, check against database/cache)\n        if not await self.validate_session(session_id, user_id):\n            raise HTTPUnauthorizedException(\"Invalid session\")\n\n        return {\n            \"message\": \"Welcome authenticated user\",\n            \"user_id\": user_id,\n            \"session_id\": session_id\n        }\n\n    async def validate_session(self, session_id: str, user_id: str) -&gt; bool:\n        \"\"\"Mock session validation\"\"\"\n        # In a real application, validate against your session store\n        return len(session_id) &gt; 10 and user_id.isdigit()\n</code></pre>"},{"location":"guides/requests/#advanced-request-handling","title":"Advanced Request Handling","text":""},{"location":"guides/requests/#request-context","title":"Request Context","text":"<p>Store and access request-specific data:</p> <pre><code>class ContextRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Use request context for storing data\"\"\"\n        # Store data in request context\n        request.context[\"user_id\"] = 123\n        request.context[\"start_time\"] = time.time()\n\n        # Process request\n        result = await self.process_request(request)\n\n        # Calculate processing time\n        processing_time = time.time() - request.context[\"start_time\"]\n\n        return {\n            \"result\": result,\n            \"user_id\": request.context[\"user_id\"],\n            \"processing_time\": processing_time\n        }\n\n    async def process_request(self, request):\n        \"\"\"Process request with access to context\"\"\"\n        user_id = request.context.get(\"user_id\")\n        return f\"Processed for user {user_id}\"\n</code></pre>"},{"location":"guides/requests/#request-validation","title":"Request Validation","text":"<p>Create reusable request validation:</p> <pre><code>from typing import Dict, Any\n\nclass ValidationMixin:\n    \"\"\"Mixin for request validation\"\"\"\n\n    def validate_json_body(self, data: Dict[str, Any], required_fields: list):\n        \"\"\"Validate JSON body has required fields\"\"\"\n        missing_fields = []\n\n        for field in required_fields:\n            if field not in data or not data[field]:\n                missing_fields.append(field)\n\n        if missing_fields:\n            raise HTTPBadRequestException(f\"Missing required fields: {', '.join(missing_fields)}\")\n\n    def validate_email(self, email: str):\n        \"\"\"Validate email format\"\"\"\n        if not email or \"@\" not in email or \".\" not in email:\n            raise HTTPBadRequestException(\"Invalid email format\")\n\n    def validate_positive_integer(self, value: str, field_name: str) -&gt; int:\n        \"\"\"Validate and convert to positive integer\"\"\"\n        try:\n            num = int(value)\n            if num &lt;= 0:\n                raise HTTPBadRequestException(f\"{field_name} must be positive\")\n            return num\n        except ValueError:\n            raise HTTPBadRequestException(f\"{field_name} must be a number\")\n\nclass ValidatedUserRoute(Route, ValidationMixin):\n    async def handle_post(self, request: PostRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Create user with validation\"\"\"\n        data = await request.json()\n\n        # Validate required fields\n        self.validate_json_body(data, [\"name\", \"email\"])\n\n        # Validate email format\n        self.validate_email(data[\"email\"])\n\n        # Validate age if provided\n        if \"age\" in data:\n            data[\"age\"] = self.validate_positive_integer(str(data[\"age\"]), \"age\")\n\n        # Create user\n        user = await self.create_user(data)\n\n        return {\"user\": user}\n</code></pre>"},{"location":"guides/requests/#best-practices","title":"Best Practices","text":""},{"location":"guides/requests/#1-use-appropriate-request-types","title":"1. Use Appropriate Request Types","text":"<pre><code># Good: Use specific request types\nclass UserRoute(Route):\n    async def handle_get(self, request: GetRequest):\n        # Handle GET requests\n        pass\n\n    async def handle_post(self, request: PostRequest):\n        # Handle POST requests\n        pass\n\n# Avoid: Generic request handling\nasync def generic_handler(request):\n    if request.method == \"GET\":\n        # Handle GET\n        pass\n    elif request.method == \"POST\":\n        # Handle POST\n        pass\n</code></pre>"},{"location":"guides/requests/#2-validate-input-early","title":"2. Validate Input Early","text":"<pre><code># Good: Validate immediately\nasync def handle_post(self, request: PostRequest):\n    data = await request.json()\n\n    if not data.get(\"email\"):\n        raise HTTPBadRequestException(\"Email is required\")\n\n    # Continue processing...\n\n# Avoid: Late validation\nasync def handle_post(self, request: PostRequest):\n    data = await request.json()\n\n    # Lots of processing...\n\n    if not data.get(\"email\"):  # Too late!\n        raise HTTPBadRequestException(\"Email is required\")\n</code></pre>"},{"location":"guides/requests/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code># Good: Comprehensive error handling\nasync def handle_post(self, request: PostRequest):\n    try:\n        data = await request.json()\n    except ValueError:\n        raise HTTPBadRequestException(\"Invalid JSON\")\n\n    try:\n        user_id = int(request.path_params[\"user_id\"])\n    except (ValueError, KeyError):\n        raise HTTPBadRequestException(\"Invalid user ID\")\n\n    # Process request...\n\n# Avoid: Letting exceptions bubble up\nasync def handle_post(self, request: PostRequest):\n    data = await request.json()  # Could raise ValueError\n    user_id = int(request.path_params[\"user_id\"])  # Could raise ValueError/KeyError\n</code></pre>"},{"location":"guides/requests/#4-use-type-hints","title":"4. Use Type Hints","text":"<pre><code># Good: Clear type hints\nasync def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n    return {\"message\": \"Hello\"}\n\n# Avoid: No type hints\nasync def handle_get(self, request):\n    return {\"message\": \"Hello\"}\n</code></pre>"},{"location":"guides/requests/#5-sanitize-input","title":"5. Sanitize Input","text":"<pre><code># Good: Sanitize user input\nasync def handle_post(self, request: PostRequest):\n    data = await request.json()\n\n    # Sanitize string inputs\n    name = data.get(\"name\", \"\").strip()[:100]  # Limit length\n    email = data.get(\"email\", \"\").strip().lower()\n\n    # Validate after sanitization\n    if not name:\n        raise HTTPBadRequestException(\"Name is required\")\n\n# Avoid: Using raw input\nasync def handle_post(self, request: PostRequest):\n    data = await request.json()\n    name = data.get(\"name\")  # Could be None, empty, or very long\n</code></pre>"},{"location":"guides/requests/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/requests/#1-plan-your-request-handling","title":"1. Plan Your Request Handling","text":"<p>Identify what data your routes need: - Path parameters - Query parameters - Headers - Request body - File uploads</p>"},{"location":"guides/requests/#2-create-route-classes","title":"2. Create Route Classes","text":"<pre><code>serv create route --name \"user_api\" --path \"/api/users\" --extension \"api\"\n</code></pre>"},{"location":"guides/requests/#3-implement-request-handlers","title":"3. Implement Request Handlers","text":"<p>Add methods for each HTTP method you need to support.</p>"},{"location":"guides/requests/#4-add-validation","title":"4. Add Validation","text":"<p>Implement proper input validation and error handling.</p>"},{"location":"guides/requests/#5-test-request-handling","title":"5. Test Request Handling","text":"<p>Test with different types of requests and edge cases.</p>"},{"location":"guides/requests/#next-steps","title":"Next Steps","text":"<ul> <li>Response Building - Learn how to build and return responses</li> <li>Forms and File Uploads - Handle form submissions and file uploads</li> <li>Authentication - Secure your request handlers</li> <li>Testing - Test your request handling logic </li> </ul>"},{"location":"guides/responses/","title":"Response Building","text":"<p>Serv provides a flexible response system that allows you to return different types of content with proper HTTP status codes, headers, and content types. This guide covers the essential response types and patterns you'll use in Serv applications.</p>"},{"location":"guides/responses/#overview","title":"Overview","text":"<p>Serv offers multiple ways to build responses:</p> <ol> <li>Type-Annotated Responses: Use type annotations to specify response types automatically</li> <li>Response Classes: Direct instantiation of response objects for full control</li> <li>ResponseBuilder: Low-level response building with the dependency injection system</li> <li>Streaming Responses: Handle large files and real-time data efficiently</li> </ol>"},{"location":"guides/responses/#basic-response-types","title":"Basic Response Types","text":""},{"location":"guides/responses/#json-responses","title":"JSON Responses","text":"<p>JSON responses are the most common for APIs. Serv automatically serializes Python objects to JSON and sets the appropriate content type:</p> <pre><code>from serv.routes import Route, GetRequest, PostRequest\nfrom serv.responses import JsonResponse\nfrom typing import Annotated\n\nclass ApiRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Return JSON using type annotation (recommended)\"\"\"\n        return {\n            \"message\": \"Hello, World!\",\n            \"status\": \"success\",\n            \"data\": {\n                \"users\": [\n                    {\"id\": 1, \"name\": \"John Doe\"},\n                    {\"id\": 2, \"name\": \"Jane Smith\"}\n                ]\n            }\n        }\n\n    async def handle_post(self, request: PostRequest) -&gt; JsonResponse:\n        \"\"\"Return JSON using direct response class\"\"\"\n        data = await request.json()\n\n        # Process the data...\n        result = {\"id\": 123, \"created\": True}\n\n        return JsonResponse(result, status_code=201)\n</code></pre> <p>The type annotation approach (<code>Annotated[dict, JsonResponse]</code>) is recommended because it's cleaner and allows Serv to automatically wrap your return value. The direct response class approach gives you more control over status codes and headers.</p>"},{"location":"guides/responses/#html-responses","title":"HTML Responses","text":"<p>HTML responses are used for web pages and server-rendered content:</p> <pre><code>from serv.responses import HtmlResponse\n\nclass WebRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Return HTML using type annotation\"\"\"\n        name = request.query_params.get(\"name\", \"World\")\n\n        return f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;Welcome&lt;/title&gt;\n            &lt;style&gt;\n                body {{ font-family: Arial, sans-serif; margin: 40px; }}\n                .greeting {{ color: #007bff; font-size: 24px; }}\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;h1 class=\"greeting\"&gt;Hello, {name}!&lt;/h1&gt;\n            &lt;p&gt;Welcome to our Serv application.&lt;/p&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n</code></pre>"},{"location":"guides/responses/#file-downloads","title":"File Downloads","text":"<p>File responses handle binary content and downloads:</p> <pre><code>from serv.responses import FileResponse\nimport os\n\nclass DownloadRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; FileResponse:\n        \"\"\"Serve file downloads\"\"\"\n        filename = request.path_params.get(\"filename\")\n\n        # Validate filename for security\n        if not filename or \"..\" in filename:\n            raise HTTPBadRequestException(\"Invalid filename\")\n\n        file_path = f\"uploads/{filename}\"\n        if not os.path.exists(file_path):\n            raise HTTPNotFoundException(\"File not found\")\n\n        # Read file content\n        with open(file_path, \"rb\") as f:\n            file_content = f.read()\n\n        # Determine content type based on extension\n        content_type = \"application/octet-stream\"\n        if filename.endswith(\".pdf\"):\n            content_type = \"application/pdf\"\n        elif filename.endswith((\".jpg\", \".jpeg\")):\n            content_type = \"image/jpeg\"\n        elif filename.endswith(\".png\"):\n            content_type = \"image/png\"\n\n        return FileResponse(\n            file=file_content,\n            filename=filename,\n            content_type=content_type\n        )\n</code></pre>"},{"location":"guides/responses/#streaming-responses","title":"Streaming Responses","text":"<p>Streaming responses are essential for handling large files, real-time data, or when you want to start sending data before it's fully processed.</p>"},{"location":"guides/responses/#basic-streaming","title":"Basic Streaming","text":"<pre><code>from serv.responses import StreamingResponse\nimport asyncio\nimport json\n\nclass StreamRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; StreamingResponse:\n        \"\"\"Stream data to client\"\"\"\n\n        async def generate_data():\n            \"\"\"Generate streaming data\"\"\"\n            for i in range(100):\n                data = {\"count\": i, \"timestamp\": time.time()}\n                yield f\"data: {json.dumps(data)}\\n\"\n                await asyncio.sleep(0.1)  # Simulate processing time\n\n        return StreamingResponse(\n            generate_data(),\n            media_type=\"text/plain\"\n        )\n</code></pre>"},{"location":"guides/responses/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<p>Server-Sent Events provide real-time updates to web browsers:</p> <pre><code>from serv.responses import ServerSentEventsResponse\nimport time\n\nclass EventStreamRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; ServerSentEventsResponse:\n        \"\"\"Real-time event stream for web browsers\"\"\"\n\n        async def event_stream():\n            \"\"\"Generate SSE events\"\"\"\n            event_id = 0\n\n            while True:\n                event_id += 1\n\n                # Send structured SSE event\n                yield f\"id: {event_id}\\n\"\n                yield f\"event: update\\n\"\n                yield f\"data: {json.dumps({'message': f'Event {event_id}', 'time': time.time()})}\\n\\n\"\n\n                await asyncio.sleep(1)  # Send event every second\n\n                # Stop after 10 events for demo\n                if event_id &gt;= 10:\n                    break\n\n        return ServerSentEventsResponse(event_stream())\n</code></pre> <p>The corresponding HTML client would look like:</p> <pre><code>&lt;script&gt;\nconst eventSource = new EventSource('/events');\neventSource.onmessage = function(event) {\n    const data = JSON.parse(event.data);\n    console.log('Received:', data);\n};\n&lt;/script&gt;\n</code></pre>"},{"location":"guides/responses/#large-file-streaming","title":"Large File Streaming","text":"<p>For large files, streaming prevents memory issues:</p> <pre><code>class LargeFileRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; StreamingResponse:\n        \"\"\"Stream large files efficiently\"\"\"\n        file_path = \"large_file.csv\"\n\n        async def file_streamer():\n            \"\"\"Stream file in chunks\"\"\"\n            with open(file_path, \"rb\") as f:\n                while True:\n                    chunk = f.read(8192)  # 8KB chunks\n                    if not chunk:\n                        break\n                    yield chunk\n\n        return StreamingResponse(\n            file_streamer(),\n            media_type=\"text/csv\",\n            headers={\"Content-Disposition\": \"attachment; filename=data.csv\"}\n        )\n</code></pre>"},{"location":"guides/responses/#advanced-response-patterns","title":"Advanced Response Patterns","text":""},{"location":"guides/responses/#custom-response-classes","title":"Custom Response Classes","text":"<p>Create specialized response types for your application:</p> <pre><code>from serv.responses import Response\nimport xml.etree.ElementTree as ET\n\nclass XmlResponse(Response):\n    \"\"\"Custom XML response\"\"\"\n\n    def __init__(self, data: dict, status_code: int = 200):\n        # Convert dict to XML\n        xml_content = self._dict_to_xml(data)\n\n        super().__init__(\n            status_code=status_code,\n            body=xml_content,\n            headers={\"Content-Type\": \"application/xml\"}\n        )\n\n    def _dict_to_xml(self, data: dict, root_name: str = \"response\") -&gt; str:\n        \"\"\"Convert dictionary to XML string\"\"\"\n        root = ET.Element(root_name)\n\n        def add_element(parent, key, value):\n            element = ET.SubElement(parent, key)\n            if isinstance(value, dict):\n                for k, v in value.items():\n                    add_element(element, k, v)\n            elif isinstance(value, list):\n                for item in value:\n                    add_element(element, \"item\", item)\n            else:\n                element.text = str(value)\n\n        for key, value in data.items():\n            add_element(root, key, value)\n\n        return ET.tostring(root, encoding=\"unicode\")\n\nclass XmlApiRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; XmlResponse:\n        \"\"\"Return XML response\"\"\"\n        data = {\n            \"users\": [\n                {\"id\": \"1\", \"name\": \"John Doe\"},\n                {\"id\": \"2\", \"name\": \"Jane Smith\"}\n            ]\n        }\n\n        return XmlResponse(data)\n</code></pre>"},{"location":"guides/responses/#error-responses","title":"Error Responses","text":"<p>Standardize error responses across your application:</p> <pre><code>class ErrorResponse(JsonResponse):\n    \"\"\"Standardized error response\"\"\"\n\n    def __init__(\n        self, \n        message: str, \n        error_code: str = None, \n        details: dict = None,\n        status_code: int = 400\n    ):\n        error_data = {\n            \"error\": {\n                \"message\": message,\n                \"code\": error_code or \"GENERIC_ERROR\",\n                \"timestamp\": time.time()\n            }\n        }\n\n        if details:\n            error_data[\"error\"][\"details\"] = details\n\n        super().__init__(error_data, status_code)\n\nclass ApiErrorRoute(Route):\n    async def handle_post(self, request: PostRequest) -&gt; JsonResponse:\n        \"\"\"API with standardized error handling\"\"\"\n        try:\n            data = await request.json()\n\n            # Validate input\n            if not data.get(\"email\"):\n                return ErrorResponse(\n                    message=\"Email is required\",\n                    error_code=\"MISSING_EMAIL\",\n                    status_code=400\n                )\n\n            # Process request...\n            result = await self.process_data(data)\n\n            return JsonResponse({\"result\": result})\n\n        except ValueError:\n            return ErrorResponse(\n                message=\"Invalid JSON format\",\n                error_code=\"INVALID_JSON\",\n                status_code=400\n            )\n\n        except Exception as e:\n            return ErrorResponse(\n                message=\"Internal server error\",\n                error_code=\"INTERNAL_ERROR\",\n                details={\"exception\": str(e)},\n                status_code=500\n            )\n</code></pre>"},{"location":"guides/responses/#response-headers-and-status-codes","title":"Response Headers and Status Codes","text":""},{"location":"guides/responses/#setting-custom-headers","title":"Setting Custom Headers","text":"<p>Add custom headers to responses:</p> <pre><code>class HeaderRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; JsonResponse:\n        \"\"\"Response with custom headers\"\"\"\n        data = {\"message\": \"Success\"}\n\n        response = JsonResponse(data)\n        response.headers[\"X-Custom-Header\"] = \"MyValue\"\n        response.headers[\"Cache-Control\"] = \"no-cache\"\n        response.headers[\"X-Rate-Limit\"] = \"100\"\n\n        return response\n</code></pre>"},{"location":"guides/responses/#status-codes","title":"Status Codes","text":"<p>Use appropriate HTTP status codes:</p> <pre><code>class StatusCodeRoute(Route):\n    async def handle_post(self, request: PostRequest) -&gt; JsonResponse:\n        \"\"\"Create resource with 201 status\"\"\"\n        data = await request.json()\n\n        # Create resource...\n        resource_id = 123\n\n        return JsonResponse(\n            {\"id\": resource_id, \"message\": \"Created\"},\n            status_code=201\n        )\n\n    async def handle_delete(self, request: DeleteRequest) -&gt; JsonResponse:\n        \"\"\"Delete resource with 204 status\"\"\"\n        resource_id = request.path_params.get(\"id\")\n\n        # Delete resource...\n\n        return JsonResponse(\n            {\"message\": \"Deleted\"},\n            status_code=204\n        )\n</code></pre>"},{"location":"guides/responses/#best-practices","title":"Best Practices","text":""},{"location":"guides/responses/#1-use-type-annotations","title":"1. Use Type Annotations","text":"<p>Type annotations make your code cleaner and enable automatic response wrapping:</p> <pre><code># Good: Clean and automatic\nasync def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n    return {\"message\": \"Hello\"}\n\n# Avoid: More verbose\nasync def handle_get(self, request: GetRequest) -&gt; JsonResponse:\n    return JsonResponse({\"message\": \"Hello\"})\n</code></pre>"},{"location":"guides/responses/#2-handle-errors-gracefully","title":"2. Handle Errors Gracefully","text":"<p>Always provide meaningful error responses:</p> <pre><code># Good: Specific error handling\nasync def handle_post(self, request: PostRequest):\n    try:\n        data = await request.json()\n    except ValueError:\n        return ErrorResponse(\"Invalid JSON\", \"INVALID_JSON\", status_code=400)\n\n    if not data.get(\"email\"):\n        return ErrorResponse(\"Email required\", \"MISSING_EMAIL\", status_code=400)\n\n# Avoid: Generic error handling\nasync def handle_post(self, request: PostRequest):\n    data = await request.json()  # Could fail\n    # Process without validation\n</code></pre>"},{"location":"guides/responses/#3-use-streaming-for-large-data","title":"3. Use Streaming for Large Data","text":"<p>Stream responses when dealing with large datasets or real-time data:</p> <pre><code># Good: Stream large responses\nasync def handle_get(self, request: GetRequest) -&gt; StreamingResponse:\n    async def generate_csv():\n        yield \"id,name,email\\n\"\n        for user in await self.get_all_users():  # Could be millions\n            yield f\"{user.id},{user.name},{user.email}\\n\"\n\n    return StreamingResponse(generate_csv(), media_type=\"text/csv\")\n\n# Avoid: Loading everything into memory\nasync def handle_get(self, request: GetRequest) -&gt; JsonResponse:\n    users = await self.get_all_users()  # Memory intensive\n    return JsonResponse(users)\n</code></pre>"},{"location":"guides/responses/#4-set-appropriate-content-types","title":"4. Set Appropriate Content Types","text":"<p>Always use the correct content type for your responses:</p> <pre><code># Good: Explicit content types\nreturn StreamingResponse(data, media_type=\"application/json\")\nreturn FileResponse(file, filename=\"data.pdf\", content_type=\"application/pdf\")\n\n# Avoid: Generic content types\nreturn StreamingResponse(data)  # Defaults to text/plain\n</code></pre>"},{"location":"guides/responses/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/responses/#1-plan-your-response-types","title":"1. Plan Your Response Types","text":"<p>Identify what types of responses your application needs: - JSON for APIs - HTML for web pages - Files for downloads - Streaming for large data or real-time updates</p>"},{"location":"guides/responses/#2-create-response-classes","title":"2. Create Response Classes","text":"<p>Use the CLI to create routes and implement appropriate response types:</p> <pre><code>serv create route --name \"api\" --path \"/api/users\" --extension \"api\"\n</code></pre>"},{"location":"guides/responses/#3-implement-error-handling","title":"3. Implement Error Handling","text":"<p>Add proper error responses for validation, authentication, and server errors.</p>"},{"location":"guides/responses/#4-test-response-types","title":"4. Test Response Types","text":"<p>Test different response types and edge cases to ensure proper behavior.</p>"},{"location":"guides/responses/#next-steps","title":"Next Steps","text":"<ul> <li>Error Handling - Learn comprehensive error handling patterns</li> <li>Templates - Use template engines for HTML responses</li> <li>Testing - Test your response handling logic</li> <li>Deployment - Deploy applications with proper response handling </li> </ul>"},{"location":"guides/routing/","title":"Routing","text":"<p>Serv provides a powerful and intuitive routing system built around Route classes that use decorator-based method dispatch. Routes automatically detect and invoke the appropriate handler method based on HTTP method decorators and request parameters, making your application structure clear and maintainable.</p>"},{"location":"guides/routing/#overview","title":"Overview","text":"<p>In Serv, routing follows these principles:</p> <ol> <li>Route Classes: Create classes that inherit from <code>Route</code> with decorated handler methods</li> <li>Decorator-Based Dispatch: Handlers are selected based on @handle decorators and request data</li> <li>Parameter Injection: Automatic extraction of parameters from requests based on type annotations</li> <li>Multiple Handlers: Support multiple handlers per HTTP method with different parameter requirements</li> <li>Extension-Based Organization: Routes are organized within extensions for modularity</li> </ol>"},{"location":"guides/routing/#getting-started","title":"Getting Started","text":""},{"location":"guides/routing/#creating-your-first-route","title":"Creating Your First Route","text":"<p>The easiest way to create a route is using the Serv CLI:</p> <pre><code># Create a new extension for your routes\nserv create extension --name \"Blog API\"\n\n# Create a route within the extension\nserv create route --name \"blog_posts\" --path \"/api/posts\"\n</code></pre> <p>This creates: 1. A extension directory structure 2. A route handler file 3. Updates the extension's <code>extension.yaml</code> with the route configuration</p>"},{"location":"guides/routing/#understanding-the-generated-files","title":"Understanding the Generated Files","text":"<p>After running the commands above, you'll have:</p> <pre><code>extensions/\n\u2514\u2500\u2500 blog_api/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 extension.yaml\n    \u2514\u2500\u2500 route_blog_posts.py\n</code></pre> <p>extension.yaml: <pre><code>name: Blog API\ndescription: A cool Serv extension.\nversion: 0.1.0\nauthor: Your Name\n\nrouters:\n  - name: main_router\n    routes:\n      - path: /api/posts\n        handler: route_blog_posts:BlogPosts\n</code></pre></p> <p>route_blog_posts.py: <pre><code>from typing import Annotated\nfrom serv.routes import Route, GetRequest, PostRequest, handle\nfrom serv.responses import JsonResponse, TextResponse\nfrom serv.injectors import Query, Header\n\nclass BlogPosts(Route):\n    @handle.GET\n    async def get_all_posts(self) -&gt; Annotated[list[dict], JsonResponse]:\n        \"\"\"Handle GET requests to /api/posts\"\"\"\n        posts = await self.fetch_all_posts()\n        return posts\n\n    @handle.GET\n    async def get_posts_by_author(\n        self, \n        author: Annotated[str, Query(\"author\")]\n    ) -&gt; Annotated[list[dict], JsonResponse]:\n        \"\"\"Handle GET requests with author filter\"\"\"\n        posts = await self.fetch_posts_by_author(author)\n        return posts\n\n    @handle.POST\n    async def create_post(\n        self, \n        request: PostRequest,\n        auth_token: Annotated[str, Header(\"Authorization\")]\n    ) -&gt; Annotated[str, TextResponse]:\n        \"\"\"Handle POST requests to create new posts\"\"\"\n        if not self.validate_auth(auth_token):\n            raise HTTPUnauthorizedException(\"Invalid token\")\n\n        data = await request.json()\n        post = await self.save_post(data)\n        return \"Post created successfully\"\n\n    async def fetch_all_posts(self):\n        \"\"\"Get all blog posts\"\"\"\n        return [{\"id\": 1, \"title\": \"Sample Post\", \"content\": \"Sample content\"}]\n\n    async def fetch_posts_by_author(self, author: str):\n        \"\"\"Get posts by specific author\"\"\"\n        return [{\"id\": 1, \"title\": \"Sample Post\", \"author\": author}]\n\n    async def save_post(self, data: dict):\n        \"\"\"Create a new blog post\"\"\"\n        return {\"id\": 2, \"title\": data.get(\"title\"), \"content\": data.get(\"content\")}\n\n    def validate_auth(self, token: str) -&gt; bool:\n        \"\"\"Validate authentication token\"\"\"\n        return token == \"valid-token\"\n</code></pre></p>"},{"location":"guides/routing/#declarative-route-configuration","title":"Declarative Route Configuration","text":""},{"location":"guides/routing/#basic-route-definition","title":"Basic Route Definition","text":"<p>Routes are defined in the <code>routers</code> section of your extension's <code>extension.yaml</code>:</p> <pre><code>routers:\n  - name: api_router\n    routes:\n      - path: /posts\n        handler: handlers:PostList\n      - path: /posts/{id}\n        handler: handlers:PostDetail\n      - path: /users/{user_id}/posts\n        handler: handlers:UserPosts\n</code></pre>"},{"location":"guides/routing/#route-with-http-methods","title":"Route with HTTP Methods","text":"<p>Specify which HTTP methods a route should handle:</p> <pre><code>routers:\n  - name: api_router\n    routes:\n      - path: /posts\n        handler: handlers:PostList\n        methods: [\"GET\", \"POST\"]\n      - path: /posts/{id}\n        handler: handlers:PostDetail\n        methods: [\"GET\", \"PUT\", \"DELETE\"]\n</code></pre>"},{"location":"guides/routing/#mounted-routers","title":"Mounted Routers","text":"<p>Mount routers at specific paths for better organization:</p> <pre><code>routers:\n  - name: api_router\n    mount: /api/v1\n    routes:\n      - path: /posts\n        handler: api:PostList\n      - path: /users\n        handler: api:UserList\n\n  - name: admin_router\n    mount: /admin\n    routes:\n      - path: /dashboard\n        handler: admin:Dashboard\n      - path: /users\n        handler: admin:UserManagement\n</code></pre> <p>This creates routes at: - <code>/api/v1/posts</code> - <code>/api/v1/users</code> - <code>/admin/dashboard</code> - <code>/admin/users</code></p>"},{"location":"guides/routing/#route-classes-and-decorator-based-routing","title":"Route Classes and Decorator-Based Routing","text":""},{"location":"guides/routing/#route-class-structure","title":"Route Class Structure","text":"<p>Route classes inherit from <code>Route</code> and define handler methods decorated with HTTP method decorators:</p> <pre><code>from typing import Annotated\nfrom serv.routes import Route, GetRequest, PostRequest, PutRequest, DeleteRequest, handle\nfrom serv.responses import JsonResponse, TextResponse\nfrom serv.injectors import Query, Header, Cookie\nfrom serv.exceptions import HTTPNotFoundException, HTTPUnauthorizedException\n\nclass UserRoute(Route):\n    @handle.GET\n    async def get_user_by_id(self, user_id: Annotated[str, Query(\"id\")]) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Get user by ID\"\"\"\n        user = await self.get_user(user_id)\n        if not user:\n            raise HTTPNotFoundException(f\"User {user_id} not found\")\n        return user\n\n    @handle.GET\n    async def get_user_profile(\n        self, \n        user_id: Annotated[str, Query(\"id\")],\n        include_private: Annotated[str, Query(\"private\", default=\"false\")]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Get user profile with optional private data\"\"\"\n        user = await self.get_user_profile_data(user_id, include_private == \"true\")\n        return user\n\n    @handle.POST\n    async def create_new_user(\n        self, \n        request: PostRequest,\n        auth_token: Annotated[str, Header(\"Authorization\")]\n    ) -&gt; Annotated[str, TextResponse]:\n        \"\"\"Create new user\"\"\"\n        if not self.validate_auth(auth_token):\n            raise HTTPUnauthorizedException(\"Authentication required\")\n\n        data = await request.json()\n        user = await self.create_user(data)\n        return \"User created successfully\"\n\n    @handle.PUT\n    async def update_user_data(\n        self, \n        request: PutRequest,\n        user_id: Annotated[str, Query(\"id\")],\n        session_id: Annotated[str, Cookie(\"session_id\")]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Update user\"\"\"\n        if not self.validate_session(session_id):\n            raise HTTPUnauthorizedException(\"Invalid session\")\n\n        data = await request.json()\n        user = await self.update_user(user_id, data)\n        return user\n\n    @handle.DELETE\n    async def delete_user_account(\n        self, \n        user_id: Annotated[str, Query(\"id\")],\n        auth_token: Annotated[str, Header(\"Authorization\")]\n    ) -&gt; Annotated[str, TextResponse]:\n        \"\"\"Delete user\"\"\"\n        if not self.validate_admin_auth(auth_token):\n            raise HTTPUnauthorizedException(\"Admin access required\")\n\n        await self.delete_user(user_id)\n        return \"User deleted successfully\"\n</code></pre>"},{"location":"guides/routing/#decorator-based-method-selection","title":"Decorator-Based Method Selection","text":"<p>Serv automatically selects the most appropriate handler based on:</p> <ol> <li>HTTP Method Match: Methods decorated with <code>@handle.GET</code>, <code>@handle.POST</code>, etc.</li> <li>Parameter Availability: Handlers requiring parameters that are available in the request</li> <li>Specificity Score: More specific handlers (more parameters) are preferred</li> </ol> <p>Example with multiple GET handlers:</p> <pre><code>class ProductRoute(Route):\n    async def handle_get(self) -&gt; Annotated[list[dict], JsonResponse]:\n        \"\"\"Fallback: Get all products\"\"\"\n        return await self.get_all_products()\n\n    async def handle_get_by_category(\n        self, \n        category: Annotated[str, Query(\"category\")]\n    ) -&gt; Annotated[list[dict], JsonResponse]:\n        \"\"\"Get products by category\"\"\"\n        return await self.get_products_by_category(category)\n\n    async def handle_get_by_user(\n        self, \n        user_id: Annotated[str, Query(\"user_id\")]\n    ) -&gt; Annotated[list[dict], JsonResponse]:\n        \"\"\"Get products for specific user\"\"\"\n        return await self.get_user_products(user_id)\n\n    async def handle_get_filtered(\n        self,\n        category: Annotated[str, Query(\"category\")],\n        user_id: Annotated[str, Query(\"user_id\")]\n    ) -&gt; Annotated[list[dict], JsonResponse]:\n        \"\"\"Get products filtered by both category and user\"\"\"\n        return await self.get_filtered_products(category, user_id)\n</code></pre> <p>Request routing examples: - <code>GET /products</code> \u2192 <code>handle_get</code> (no parameters) - <code>GET /products?category=electronics</code> \u2192 <code>handle_get_by_category</code> (has category) - <code>GET /products?user_id=123</code> \u2192 <code>handle_get_by_user</code> (has user_id) - <code>GET /products?category=electronics&amp;user_id=123</code> \u2192 <code>handle_get_filtered</code> (most specific)</p>"},{"location":"guides/routing/#parameter-injection","title":"Parameter Injection","text":""},{"location":"guides/routing/#query-parameters","title":"Query Parameters","text":"<p>Inject query parameters using the <code>Query</code> annotation:</p> <pre><code>from serv.injectors import Query\n\nclass SearchRoute(Route):\n    async def handle_get(\n        self,\n        query: Annotated[str, Query(\"q\")],\n        page: Annotated[int, Query(\"page\", default=1)],\n        limit: Annotated[int, Query(\"limit\", default=10)]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Search with pagination\"\"\"\n        results = await self.search(query, page, limit)\n        return {\"results\": results, \"page\": page, \"limit\": limit}\n</code></pre>"},{"location":"guides/routing/#headers","title":"Headers","text":"<p>Inject HTTP headers using the <code>Header</code> annotation:</p> <pre><code>from serv.injectors import Header\n\nclass AuthenticatedRoute(Route):\n    async def handle_get(\n        self,\n        auth_token: Annotated[str, Header(\"Authorization\")],\n        api_key: Annotated[str, Header(\"X-API-Key\", default=None)]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Authenticated endpoint\"\"\"\n        if not auth_token.startswith(\"Bearer \"):\n            raise HTTPUnauthorizedException(\"Invalid authorization header\")\n\n        user = await self.validate_token(auth_token)\n        return {\"user\": user}\n</code></pre>"},{"location":"guides/routing/#cookies","title":"Cookies","text":"<p>Inject cookies using the <code>Cookie</code> annotation:</p> <pre><code>from serv.injectors import Cookie\n\nclass SessionRoute(Route):\n    async def handle_get(\n        self,\n        session_id: Annotated[str, Cookie(\"session_id\")],\n        theme: Annotated[str, Cookie(\"theme\", default=\"light\")]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Session-based endpoint\"\"\"\n        session = await self.get_session(session_id)\n        if not session:\n            raise HTTPUnauthorizedException(\"Invalid session\")\n\n        return {\"session\": session, \"theme\": theme}\n</code></pre>"},{"location":"guides/routing/#path-parameters","title":"Path Parameters","text":"<p>Path parameters from URL patterns are accessible via <code>request.path_params</code>:</p> <pre><code>class UserDetailRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        \"\"\"Get user by path parameter\"\"\"\n        user_id = request.path_params[\"user_id\"]\n        user = await self.get_user(user_id)\n        return user\n</code></pre>"},{"location":"guides/routing/#form-handling","title":"Form Handling","text":""},{"location":"guides/routing/#form-classes","title":"Form Classes","text":"<p>Define form classes using dataclasses for structured form handling:</p> <pre><code>from dataclasses import dataclass\nfrom serv.routes import Form, Route, PostRequest\nfrom serv.responses import HtmlResponse, TextResponse\nfrom typing import Annotated\n\n@dataclass\nclass ContactForm(Form):\n    name: str\n    email: str\n    message: str\n\n@dataclass\nclass UserRegistrationForm(Form):\n    username: str\n    email: str\n    password: str\n    age: int = 18  # Optional with default\n\nclass ContactRoute(Route):\n    async def handle_get(self) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Show contact form\"\"\"\n        return '''\n        &lt;form method=\"post\"&gt;\n            &lt;input name=\"name\" placeholder=\"Name\" required&gt;\n            &lt;input name=\"email\" type=\"email\" placeholder=\"Email\" required&gt;\n            &lt;textarea name=\"message\" placeholder=\"Message\" required&gt;&lt;/textarea&gt;\n            &lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n        &lt;/form&gt;\n        '''\n\n    async def handle_contact_form(self, form: ContactForm) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Handle contact form submission\"\"\"\n        # Process the form data\n        await self.send_email(form.email, form.name, form.message)\n        return f\"&lt;h1&gt;Thank you {form.name}! Your message has been sent.&lt;/h1&gt;\"\n\n    async def handle_registration_form(self, form: UserRegistrationForm) -&gt; Annotated[str, TextResponse]:\n        \"\"\"Handle user registration\"\"\"\n        # Validate and create user\n        user = await self.create_user(form.username, form.email, form.password, form.age)\n        return f\"User {form.username} registered successfully\"\n</code></pre>"},{"location":"guides/routing/#configuration-for-multiple-methods","title":"Configuration for Multiple Methods","text":"<p>Configure multiple handlers for the same path:</p> <pre><code>routers:\n  - name: api_router\n    routes:\n      - path: /posts\n        handler: handlers:PostList\n        methods: [\"GET\"]\n      - path: /posts\n        handler: handlers:CreatePost\n        methods: [\"POST\"]\n      - path: /posts/{id}\n        handler: handlers:PostDetail\n        methods: [\"GET\"]\n      - path: /posts/{id}\n        handler: handlers:UpdatePost\n        methods: [\"PUT\"]\n      - path: /posts/{id}\n        handler: handlers:DeletePost\n        methods: [\"DELETE\"]\n</code></pre>"},{"location":"guides/routing/#response-types","title":"Response Types","text":""},{"location":"guides/routing/#json-responses","title":"JSON Responses","text":"<p>Return structured data easily:</p> <pre><code>from typing import Annotated\nfrom serv.routes import JsonResponse\n\nasync def ApiPosts() -&gt; Annotated[dict, JsonResponse]:\n    return {\n        \"posts\": [\n            {\"id\": 1, \"title\": \"First Post\"},\n            {\"id\": 2, \"title\": \"Second Post\"}\n        ]\n    }\n</code></pre>"},{"location":"guides/routing/#html-templates","title":"HTML Templates","text":"<p>Render HTML templates with Jinja2:</p> <pre><code>from typing import Annotated, Any\nfrom serv.routes import Jinja2Response\n\nasync def BlogHome() -&gt; Annotated[tuple[str, dict[str, Any]], Jinja2Response]:\n    return \"blog/home.html\", {\n        \"title\": \"My Blog\",\n        \"posts\": get_recent_posts()\n    }\n</code></pre>"},{"location":"guides/routing/#plain-text-and-custom-responses","title":"Plain Text and Custom Responses","text":"<pre><code>async def HealthCheck(response: ResponseBuilder = dependency()):\n    response.content_type(\"text/plain\")\n    response.body(\"OK\")\n\nasync def ApiStatus(response: ResponseBuilder = dependency()):\n    response.content_type(\"application/json\")\n    response.set_status(200)\n    response.body('{\"status\": \"healthy\", \"timestamp\": \"2024-01-01T00:00:00Z\"}')\n</code></pre>"},{"location":"guides/routing/#advanced-routing-patterns","title":"Advanced Routing Patterns","text":""},{"location":"guides/routing/#nested-resource-routes","title":"Nested Resource Routes","text":"<p>Create RESTful nested resources:</p> <pre><code>routers:\n  - name: api_router\n    mount: /api/v1\n    routes:\n      # Users\n      - path: /users\n        handler: api:UserList\n        methods: [\"GET\", \"POST\"]\n      - path: /users/{user_id}\n        handler: api:UserDetail\n        methods: [\"GET\", \"PUT\", \"DELETE\"]\n\n      # User Posts (nested resource)\n      - path: /users/{user_id}/posts\n        handler: api:UserPostList\n        methods: [\"GET\", \"POST\"]\n      - path: /users/{user_id}/posts/{post_id}\n        handler: api:UserPostDetail\n        methods: [\"GET\", \"PUT\", \"DELETE\"]\n\n      # Post Comments (deeply nested)\n      - path: /posts/{post_id}/comments\n        handler: api:PostCommentList\n        methods: [\"GET\", \"POST\"]\n      - path: /posts/{post_id}/comments/{comment_id}\n        handler: api:PostCommentDetail\n        methods: [\"GET\", \"PUT\", \"DELETE\"]\n</code></pre>"},{"location":"guides/routing/#multiple-routers-in-one-extension","title":"Multiple Routers in One Extension","text":"<p>Organize complex applications with multiple routers:</p> <pre><code>routers:\n  # Public API\n  - name: public_api\n    mount: /api/v1\n    routes:\n      - path: /posts\n        handler: public_api:PostList\n      - path: /posts/{id}\n        handler: public_api:PostDetail\n\n  # Admin API\n  - name: admin_api\n    mount: /admin/api\n    routes:\n      - path: /posts\n        handler: admin_api:AdminPostList\n      - path: /users\n        handler: admin_api:AdminUserList\n\n  # Web Interface\n  - name: web_interface\n    routes:\n      - path: /\n        handler: web:HomePage\n      - path: /blog\n        handler: web:BlogPage\n      - path: /blog/{slug}\n        handler: web:BlogPost\n</code></pre>"},{"location":"guides/routing/#form-handling_1","title":"Form Handling","text":""},{"location":"guides/routing/#creating-form-routes","title":"Creating Form Routes","text":"<p>Use the CLI to create form-handling routes:</p> <pre><code>serv create route --name \"contact_form\" --path \"/contact\"\n</code></pre>"},{"location":"guides/routing/#form-data-processing","title":"Form Data Processing","text":"<p>Handle form submissions in your route handlers:</p> <pre><code>from serv.routes import PostRequest\n\nasync def ContactForm(request: PostRequest, response: ResponseBuilder = dependency()):\n    \"\"\"Handle contact form submission\"\"\"\n    form_data = await request.form()\n\n    name = form_data.get(\"name\")\n    email = form_data.get(\"email\")\n    message = form_data.get(\"message\")\n\n    # Process the form data\n    send_contact_email(name, email, message)\n\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;Thank you for your message!&lt;/h1&gt;\")\n</code></pre>"},{"location":"guides/routing/#file-upload-handling","title":"File Upload Handling","text":"<p>Handle file uploads in your routes:</p> <pre><code>async def FileUpload(request: PostRequest, response: ResponseBuilder = dependency()):\n    \"\"\"Handle file upload\"\"\"\n    form_data = await request.form()\n\n    uploaded_file = form_data.get(\"file\")\n    if uploaded_file:\n        # Save the file\n        with open(f\"uploads/{uploaded_file.filename}\", \"wb\") as f:\n            f.write(await uploaded_file.read())\n\n        response.body(\"File uploaded successfully\")\n    else:\n        response.set_status(400)\n        response.body(\"No file provided\")\n</code></pre>"},{"location":"guides/routing/#extension-organization","title":"Extension Organization","text":""},{"location":"guides/routing/#feature-based-extensions","title":"Feature-Based Extensions","text":"<p>Organize routes by feature or domain:</p> <pre><code># User management\nserv create extension --name \"User Management\"\nserv create route --name \"user_list\" --path \"/users\" --extension \"user_management\"\nserv create route --name \"user_detail\" --path \"/users/{id}\" --extension \"user_management\"\n\n# Blog functionality\nserv create extension --name \"Blog\"\nserv create route --name \"blog_home\" --path \"/blog\" --extension \"blog\"\nserv create route --name \"blog_post\" --path \"/blog/{slug}\" --extension \"blog\"\n\n# API endpoints\nserv create extension --name \"API\"\nserv create route --name \"api_posts\" --path \"/api/posts\" --extension \"api\"\nserv create route --name \"api_users\" --path \"/api/users\" --extension \"api\"\n</code></pre>"},{"location":"guides/routing/#extension-dependencies","title":"Extension Dependencies","text":"<p>Extensions can depend on other extensions for shared functionality:</p> <pre><code># In blog extension's extension.yaml\nname: Blog\ndescription: Blog functionality\nversion: 1.0.0\ndependencies:\n  - user_management  # Depends on user management for authentication\n\nrouters:\n  - name: blog_router\n    routes:\n      - path: /blog\n        handler: blog:BlogHome\n      - path: /blog/new\n        handler: blog:CreatePost  # May use user auth from user_management\n</code></pre>"},{"location":"guides/routing/#error-handling","title":"Error Handling","text":""},{"location":"guides/routing/#route-level-error-handling","title":"Route-Level Error Handling","text":"<p>Handle errors within your route handlers:</p> <pre><code>from serv.exceptions import HTTPNotFoundException\n\nasync def PostDetail(post_id: str, response: ResponseBuilder = dependency()):\n    post = get_post_by_id(post_id)\n    if not post:\n        raise HTTPNotFoundException(f\"Post {post_id} not found\")\n\n    response.content_type(\"application/json\")\n    response.body(post.to_json())\n</code></pre>"},{"location":"guides/routing/#custom-error-pages","title":"Custom Error Pages","text":"<p>Create custom error handlers:</p> <pre><code>async def NotFoundHandler(response: ResponseBuilder = dependency()):\n    response.set_status(404)\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;Page Not Found&lt;/h1&gt;\")\n\n# Register in your extension's event handler\nclass MyListener(Listener):\n    async def on_app_startup(self, app = dependency()):\n        app.add_error_handler(HTTPNotFoundException, NotFoundHandler)\n</code></pre>"},{"location":"guides/routing/#testing-routes","title":"Testing Routes","text":""},{"location":"guides/routing/#testing-route-handlers","title":"Testing Route Handlers","text":"<p>Test your route handlers in isolation:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\nfrom serv.responses import ResponseBuilder\n\n@pytest.mark.asyncio\nasync def test_post_list():\n    response = Mock(spec=ResponseBuilder)\n\n    await PostList(response)\n\n    response.content_type.assert_called_with(\"application/json\")\n    assert '\"posts\"' in response.body.call_args[0][0]\n</code></pre>"},{"location":"guides/routing/#integration-testing","title":"Integration Testing","text":"<p>Test complete request/response cycles:</p> <pre><code>import pytest\nfrom httpx import AsyncClient\nfrom serv.app import App\n\n@pytest.mark.asyncio\nasync def test_blog_api():\n    app = App(config=\"test_config.yaml\")\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/api/posts\")\n        assert response.status_code == 200\n        assert response.headers[\"content-type\"] == \"application/json\"\n</code></pre>"},{"location":"guides/routing/#best-practices","title":"Best Practices","text":""},{"location":"guides/routing/#1-use-the-cli-for-consistency","title":"1. Use the CLI for Consistency","text":"<p>Always use the CLI to create routes for consistent structure:</p> <pre><code># Good: Use CLI\nserv create route --name \"user_profile\" --path \"/users/{id}\"\n\n# Avoid: Manual file creation (error-prone)\n</code></pre>"},{"location":"guides/routing/#2-organize-by-feature","title":"2. Organize by Feature","text":"<p>Group related routes in feature-specific extensions:</p> <pre><code>extensions/\n\u251c\u2500\u2500 user_management/\n\u2502   \u251c\u2500\u2500 extension.yaml\n\u2502   \u251c\u2500\u2500 route_user_list.py\n\u2502   \u2514\u2500\u2500 route_user_detail.py\n\u251c\u2500\u2500 blog/\n\u2502   \u251c\u2500\u2500 extension.yaml\n\u2502   \u251c\u2500\u2500 route_blog_home.py\n\u2502   \u2514\u2500\u2500 route_blog_post.py\n\u2514\u2500\u2500 api/\n    \u251c\u2500\u2500 extension.yaml\n    \u251c\u2500\u2500 route_api_posts.py\n    \u2514\u2500\u2500 route_api_users.py\n</code></pre>"},{"location":"guides/routing/#3-use-descriptive-handler-names","title":"3. Use Descriptive Handler Names","text":"<p>Make your handlers self-documenting:</p> <pre><code># Good\nasync def UserProfilePage(user_id: str, response: ResponseBuilder = dependency()):\n    pass\n\nasync def CreateBlogPost(request: PostRequest, response: ResponseBuilder = dependency()):\n    pass\n\n# Avoid generic names\nasync def Handler(response: ResponseBuilder = dependency()):\n    pass\n</code></pre>"},{"location":"guides/routing/#4-validate-input","title":"4. Validate Input","text":"<p>Always validate path parameters and form data:</p> <pre><code>import re\n\nasync def UserDetail(user_id: str, response: ResponseBuilder = dependency()):\n    # Validate user_id format\n    if not re.match(r'^\\d+$', user_id):\n        response.set_status(400)\n        response.body(\"Invalid user ID format\")\n        return\n\n    # Continue with valid input\n    user = get_user(int(user_id))\n    response.body(user.to_json())\n</code></pre>"},{"location":"guides/routing/#5-use-type-annotations","title":"5. Use Type Annotations","text":"<p>Always use type hints for better IDE support:</p> <pre><code>from typing import Annotated\nfrom serv.routes import GetRequest, JsonResponse\n\nasync def ApiPosts(request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n    return {\"posts\": get_all_posts()}\n</code></pre>"},{"location":"guides/routing/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/routing/#1-plan-your-routes","title":"1. Plan Your Routes","text":"<p>Start by planning your application's URL structure:</p> <pre><code>/                    # Home page\n/blog                # Blog listing\n/blog/{slug}         # Individual blog post\n/api/posts           # API: List posts\n/api/posts/{id}      # API: Post detail\n/admin/dashboard     # Admin dashboard\n/admin/posts         # Admin: Manage posts\n</code></pre>"},{"location":"guides/routing/#2-create-extensions","title":"2. Create Extensions","text":"<p>Create extensions for each major feature:</p> <pre><code>serv create extension --name \"Blog\"\nserv create extension --name \"API\"\nserv create extension --name \"Admin\"\n</code></pre>"},{"location":"guides/routing/#3-add-routes","title":"3. Add Routes","text":"<p>Add routes to each extension:</p> <pre><code># Blog routes\nserv create route --name \"blog_home\" --path \"/blog\" --extension \"blog\"\nserv create route --name \"blog_post\" --path \"/blog/{slug}\" --extension \"blog\"\n\n# API routes\nserv create route --name \"api_posts\" --path \"/posts\" --router \"api_router\" --extension \"api\"\nserv create route --name \"api_post_detail\" --path \"/posts/{id}\" --router \"api_router\" --extension \"api\"\n\n# Admin routes\nserv create route --name \"admin_dashboard\" --path \"/dashboard\" --router \"admin_router\" --extension \"admin\"\n</code></pre>"},{"location":"guides/routing/#4-enable-extensions","title":"4. Enable Extensions","text":"<p>Enable your extensions in the application:</p> <pre><code>serv extension enable blog\nserv extension enable api\nserv extension enable admin\n</code></pre>"},{"location":"guides/routing/#5-test-and-iterate","title":"5. Test and Iterate","text":"<p>Test your routes and iterate:</p> <pre><code># Start development server\nserv --dev launch\n\n# Run tests\nserv test\n\n# Validate configuration\nserv extension validate --all\n</code></pre>"},{"location":"guides/routing/#next-steps","title":"Next Steps","text":"<ul> <li>Extensions - Learn about extension architecture and event handling</li> <li>Dependency Injection - Master dependency injection patterns</li> <li>Middleware - Add cross-cutting concerns to your routes</li> <li>Forms and Validation - Handle complex form processing </li> </ul>"},{"location":"guides/templates/","title":"Templates","text":"<p>Templates allow you to generate dynamic HTML content by combining static markup with dynamic data. While Serv doesn't include a built-in template engine, it provides excellent integration with popular Python template engines like Jinja2, Mako, and others. This guide covers everything you need to know about using templates in Serv applications.</p>"},{"location":"guides/templates/#overview","title":"Overview","text":"<p>Template features in Serv:</p> <ol> <li>Template Engine Integration: Support for popular template engines</li> <li>Context Management: Pass data to templates efficiently</li> <li>Template Inheritance: Build reusable template hierarchies</li> <li>Custom Filters: Extend template functionality</li> <li>Async Support: Asynchronous template rendering</li> </ol>"},{"location":"guides/templates/#template-engine-setup","title":"Template Engine Setup","text":""},{"location":"guides/templates/#jinja2-integration","title":"Jinja2 Integration","text":"<p>Jinja2 is the most popular template engine for Python web applications:</p> <pre><code>pip install jinja2\n</code></pre> <p>extensions/templates/template_engine.py: <pre><code>import os\nfrom pathlib import Path\nfrom typing import Dict, Any\nfrom jinja2 import Environment, FileSystemLoader, select_autoescape\nfrom bevy import dependency\n\nclass TemplateEngine:\n    \"\"\"Jinja2 template engine wrapper\"\"\"\n\n    def __init__(self, template_dir: str = \"templates\"):\n        self.template_dir = Path(template_dir)\n        self.template_dir.mkdir(exist_ok=True)\n\n        # Configure Jinja2 environment\n        self.env = Environment(\n            loader=FileSystemLoader(str(self.template_dir)),\n            autoescape=select_autoescape(['html', 'xml']),\n            enable_async=True,  # Enable async support\n            trim_blocks=True,\n            lstrip_blocks=True\n        )\n\n        # Add custom filters\n        self.env.filters['currency'] = self.currency_filter\n        self.env.filters['datetime'] = self.datetime_filter\n        self.env.filters['truncate_words'] = self.truncate_words_filter\n\n    async def render(self, template_name: str, context: Dict[str, Any] = None) -&gt; str:\n        \"\"\"Render template with context\"\"\"\n        template = self.env.get_template(template_name)\n        return await template.render_async(context or {})\n\n    def render_string(self, template_string: str, context: Dict[str, Any] = None) -&gt; str:\n        \"\"\"Render template from string\"\"\"\n        template = self.env.from_string(template_string)\n        return template.render(context or {})\n\n    # Custom filters\n    def currency_filter(self, value: float, currency: str = \"USD\") -&gt; str:\n        \"\"\"Format currency\"\"\"\n        symbols = {\"USD\": \"$\", \"EUR\": \"\u20ac\", \"GBP\": \"\u00a3\"}\n        symbol = symbols.get(currency, currency)\n        return f\"{symbol}{value:,.2f}\"\n\n    def datetime_filter(self, value, format: str = \"%Y-%m-%d %H:%M\") -&gt; str:\n        \"\"\"Format datetime\"\"\"\n        if hasattr(value, 'strftime'):\n            return value.strftime(format)\n        return str(value)\n\n    def truncate_words_filter(self, value: str, length: int = 50) -&gt; str:\n        \"\"\"Truncate text to specified word count\"\"\"\n        words = str(value).split()\n        if len(words) &lt;= length:\n            return value\n        return ' '.join(words[:length]) + '...'\n\n# Register as dependency\ndef create_template_engine() -&gt; TemplateEngine:\n    return TemplateEngine()\n</code></pre></p> <p>extensions/templates/extension.py: <pre><code>from bevy import dependency\nfrom serv.extensions import Extension\nfrom .template_engine import TemplateEngine, create_template_engine\n\nclass TemplatesExtension(Extension):\n    \"\"\"Extension for template engine integration\"\"\"\n\n    async def on_startup(self):\n        \"\"\"Register template engine as dependency\"\"\"\n        # Register the template engine\n        dependency.register(TemplateEngine, create_template_engine)\n</code></pre></p> <p>extensions/templates/extension.yaml: <pre><code>name: Templates Extension\nversion: 1.0.0\ndescription: Template engine integration for Serv\ndependencies: []\n</code></pre></p>"},{"location":"guides/templates/#using-templates-in-routes","title":"Using Templates in Routes","text":"<pre><code>from serv.routes import Route, GetRequest\nfrom typing import Annotated\nfrom serv.responses import HtmlResponse\nfrom bevy import dependency\nfrom extensions.templates.template_engine import TemplateEngine\n\nclass HomeRoute(Route):\n    async def handle_get(\n        self, \n        request: GetRequest,\n        template_engine: TemplateEngine = dependency()\n    ) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Render home page template\"\"\"\n\n        context = {\n            \"title\": \"Welcome to Serv\",\n            \"user\": {\n                \"name\": \"John Doe\",\n                \"email\": \"john@example.com\"\n            },\n            \"products\": [\n                {\"id\": 1, \"name\": \"Product 1\", \"price\": 29.99},\n                {\"id\": 2, \"name\": \"Product 2\", \"price\": 49.99},\n                {\"id\": 3, \"name\": \"Product 3\", \"price\": 19.99}\n            ],\n            \"current_year\": 2024\n        }\n\n        return await template_engine.render(\"home.html\", context)\n</code></pre>"},{"location":"guides/templates/#template-structure","title":"Template Structure","text":""},{"location":"guides/templates/#base-template","title":"Base Template","text":"<p>Create a base template for consistent layout:</p> <p>templates/base.html: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;{% block title %}{{ title | default('Serv Application') }}{% endblock %}&lt;/title&gt;\n\n    &lt;!-- CSS --&gt;\n    &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;\n    {% block extra_css %}{% endblock %}\n\n    &lt;style&gt;\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n        }\n        .navbar-brand {\n            font-weight: bold;\n        }\n        .footer {\n            background-color: #f8f9fa;\n            padding: 2rem 0;\n            margin-top: 3rem;\n        }\n        {% block extra_styles %}{% endblock %}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Navigation --&gt;\n    &lt;nav class=\"navbar navbar-expand-lg navbar-dark bg-primary\"&gt;\n        &lt;div class=\"container\"&gt;\n            &lt;a class=\"navbar-brand\" href=\"/\"&gt;\n                {% block brand %}Serv App{% endblock %}\n            &lt;/a&gt;\n\n            &lt;button class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#navbarNav\"&gt;\n                &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt;\n            &lt;/button&gt;\n\n            &lt;div class=\"collapse navbar-collapse\" id=\"navbarNav\"&gt;\n                &lt;ul class=\"navbar-nav me-auto\"&gt;\n                    {% block nav_items %}\n                    &lt;li class=\"nav-item\"&gt;\n                        &lt;a class=\"nav-link\" href=\"/\"&gt;Home&lt;/a&gt;\n                    &lt;/li&gt;\n                    &lt;li class=\"nav-item\"&gt;\n                        &lt;a class=\"nav-link\" href=\"/products\"&gt;Products&lt;/a&gt;\n                    &lt;/li&gt;\n                    &lt;li class=\"nav-item\"&gt;\n                        &lt;a class=\"nav-link\" href=\"/about\"&gt;About&lt;/a&gt;\n                    &lt;/li&gt;\n                    {% endblock %}\n                &lt;/ul&gt;\n\n                &lt;ul class=\"navbar-nav\"&gt;\n                    {% if user %}\n                    &lt;li class=\"nav-item dropdown\"&gt;\n                        &lt;a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"userDropdown\" role=\"button\" data-bs-toggle=\"dropdown\"&gt;\n                            {{ user.name }}\n                        &lt;/a&gt;\n                        &lt;ul class=\"dropdown-menu\"&gt;\n                            &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"/profile\"&gt;Profile&lt;/a&gt;&lt;/li&gt;\n                            &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"/settings\"&gt;Settings&lt;/a&gt;&lt;/li&gt;\n                            &lt;li&gt;&lt;hr class=\"dropdown-divider\"&gt;&lt;/li&gt;\n                            &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"/logout\"&gt;Logout&lt;/a&gt;&lt;/li&gt;\n                        &lt;/ul&gt;\n                    &lt;/li&gt;\n                    {% else %}\n                    &lt;li class=\"nav-item\"&gt;\n                        &lt;a class=\"nav-link\" href=\"/login\"&gt;Login&lt;/a&gt;\n                    &lt;/li&gt;\n                    &lt;li class=\"nav-item\"&gt;\n                        &lt;a class=\"nav-link\" href=\"/register\"&gt;Register&lt;/a&gt;\n                    &lt;/li&gt;\n                    {% endif %}\n                &lt;/ul&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/nav&gt;\n\n    &lt;!-- Flash Messages --&gt;\n    {% if messages %}\n    &lt;div class=\"container mt-3\"&gt;\n        {% for message in messages %}\n        &lt;div class=\"alert alert-{{ message.type }} alert-dismissible fade show\" role=\"alert\"&gt;\n            {{ message.text }}\n            &lt;button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"&gt;&lt;/button&gt;\n        &lt;/div&gt;\n        {% endfor %}\n    &lt;/div&gt;\n    {% endif %}\n\n    &lt;!-- Main Content --&gt;\n    &lt;main class=\"container mt-4\"&gt;\n        {% block content %}\n        &lt;h1&gt;Welcome to Serv&lt;/h1&gt;\n        &lt;p&gt;This is the default content.&lt;/p&gt;\n        {% endblock %}\n    &lt;/main&gt;\n\n    &lt;!-- Footer --&gt;\n    &lt;footer class=\"footer mt-auto\"&gt;\n        &lt;div class=\"container\"&gt;\n            &lt;div class=\"row\"&gt;\n                &lt;div class=\"col-md-6\"&gt;\n                    {% block footer_left %}\n                    &lt;p&gt;&amp;copy; {{ current_year }} Serv Application. All rights reserved.&lt;/p&gt;\n                    {% endblock %}\n                &lt;/div&gt;\n                &lt;div class=\"col-md-6 text-end\"&gt;\n                    {% block footer_right %}\n                    &lt;p&gt;Built with &lt;a href=\"https://getserv.ing\"&gt;Serv&lt;/a&gt;&lt;/p&gt;\n                    {% endblock %}\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/footer&gt;\n\n    &lt;!-- JavaScript --&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js\"&gt;&lt;/script&gt;\n    {% block extra_js %}{% endblock %}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"guides/templates/#page-templates","title":"Page Templates","text":"<p>Create specific page templates that extend the base:</p> <p>templates/home.html: <pre><code>{% extends \"base.html\" %}\n\n{% block title %}{{ title }} - Home{% endblock %}\n\n{% block content %}\n&lt;div class=\"row\"&gt;\n    &lt;div class=\"col-lg-8\"&gt;\n        &lt;div class=\"jumbotron bg-light p-5 rounded\"&gt;\n            &lt;h1 class=\"display-4\"&gt;{{ title }}&lt;/h1&gt;\n            &lt;p class=\"lead\"&gt;Welcome to our amazing Serv application!&lt;/p&gt;\n            {% if user %}\n            &lt;p&gt;Hello, {{ user.name }}! Great to see you again.&lt;/p&gt;\n            {% else %}\n            &lt;p&gt;Please &lt;a href=\"/login\"&gt;login&lt;/a&gt; or &lt;a href=\"/register\"&gt;register&lt;/a&gt; to get started.&lt;/p&gt;\n            {% endif %}\n        &lt;/div&gt;\n\n        &lt;!-- Featured Products --&gt;\n        {% if products %}\n        &lt;h2 class=\"mt-5\"&gt;Featured Products&lt;/h2&gt;\n        &lt;div class=\"row\"&gt;\n            {% for product in products %}\n            &lt;div class=\"col-md-4 mb-4\"&gt;\n                &lt;div class=\"card\"&gt;\n                    &lt;div class=\"card-body\"&gt;\n                        &lt;h5 class=\"card-title\"&gt;{{ product.name }}&lt;/h5&gt;\n                        &lt;p class=\"card-text\"&gt;\n                            &lt;strong&gt;{{ product.price | currency }}&lt;/strong&gt;\n                        &lt;/p&gt;\n                        &lt;a href=\"/products/{{ product.id }}\" class=\"btn btn-primary\"&gt;View Details&lt;/a&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            {% endfor %}\n        &lt;/div&gt;\n        {% endif %}\n    &lt;/div&gt;\n\n    &lt;div class=\"col-lg-4\"&gt;\n        &lt;div class=\"card\"&gt;\n            &lt;div class=\"card-header\"&gt;\n                &lt;h5&gt;Quick Stats&lt;/h5&gt;\n            &lt;/div&gt;\n            &lt;div class=\"card-body\"&gt;\n                &lt;ul class=\"list-unstyled\"&gt;\n                    &lt;li&gt;&lt;strong&gt;Products:&lt;/strong&gt; {{ products | length }}&lt;/li&gt;\n                    &lt;li&gt;&lt;strong&gt;Current Year:&lt;/strong&gt; {{ current_year }}&lt;/li&gt;\n                    {% if user %}\n                    &lt;li&gt;&lt;strong&gt;User:&lt;/strong&gt; {{ user.email }}&lt;/li&gt;\n                    {% endif %}\n                &lt;/ul&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n{% endblock %}\n</code></pre></p> <p>templates/products/list.html: <pre><code>{% extends \"base.html\" %}\n\n{% block title %}Products{% endblock %}\n\n{% block content %}\n&lt;div class=\"d-flex justify-content-between align-items-center mb-4\"&gt;\n    &lt;h1&gt;Products&lt;/h1&gt;\n    &lt;a href=\"/products/new\" class=\"btn btn-success\"&gt;Add Product&lt;/a&gt;\n&lt;/div&gt;\n\n&lt;!-- Search and Filter --&gt;\n&lt;div class=\"row mb-4\"&gt;\n    &lt;div class=\"col-md-6\"&gt;\n        &lt;form method=\"get\" action=\"/products\"&gt;\n            &lt;div class=\"input-group\"&gt;\n                &lt;input type=\"text\" class=\"form-control\" name=\"search\" \n                       placeholder=\"Search products...\" value=\"{{ search_query }}\"&gt;\n                &lt;button class=\"btn btn-outline-secondary\" type=\"submit\"&gt;Search&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n    &lt;/div&gt;\n    &lt;div class=\"col-md-6\"&gt;\n        &lt;form method=\"get\" action=\"/products\"&gt;\n            &lt;select name=\"category\" class=\"form-select\" onchange=\"this.form.submit()\"&gt;\n                &lt;option value=\"\"&gt;All Categories&lt;/option&gt;\n                {% for category in categories %}\n                &lt;option value=\"{{ category.id }}\" \n                        {% if category.id == selected_category %}selected{% endif %}&gt;\n                    {{ category.name }}\n                &lt;/option&gt;\n                {% endfor %}\n            &lt;/select&gt;\n        &lt;/form&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!-- Products Grid --&gt;\n{% if products %}\n&lt;div class=\"row\"&gt;\n    {% for product in products %}\n    &lt;div class=\"col-lg-4 col-md-6 mb-4\"&gt;\n        &lt;div class=\"card h-100\"&gt;\n            {% if product.image %}\n            &lt;img src=\"{{ product.image }}\" class=\"card-img-top\" alt=\"{{ product.name }}\" style=\"height: 200px; object-fit: cover;\"&gt;\n            {% endif %}\n\n            &lt;div class=\"card-body d-flex flex-column\"&gt;\n                &lt;h5 class=\"card-title\"&gt;{{ product.name }}&lt;/h5&gt;\n                &lt;p class=\"card-text\"&gt;{{ product.description | truncate_words(20) }}&lt;/p&gt;\n\n                &lt;div class=\"mt-auto\"&gt;\n                    &lt;div class=\"d-flex justify-content-between align-items-center\"&gt;\n                        &lt;span class=\"h5 text-primary\"&gt;{{ product.price | currency }}&lt;/span&gt;\n                        {% if product.in_stock %}\n                        &lt;span class=\"badge bg-success\"&gt;In Stock&lt;/span&gt;\n                        {% else %}\n                        &lt;span class=\"badge bg-danger\"&gt;Out of Stock&lt;/span&gt;\n                        {% endif %}\n                    &lt;/div&gt;\n\n                    &lt;div class=\"mt-2\"&gt;\n                        &lt;a href=\"/products/{{ product.id }}\" class=\"btn btn-primary btn-sm\"&gt;View&lt;/a&gt;\n                        &lt;a href=\"/products/{{ product.id }}/edit\" class=\"btn btn-outline-secondary btn-sm\"&gt;Edit&lt;/a&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    {% endfor %}\n&lt;/div&gt;\n\n&lt;!-- Pagination --&gt;\n{% if pagination %}\n&lt;nav aria-label=\"Product pagination\"&gt;\n    &lt;ul class=\"pagination justify-content-center\"&gt;\n        {% if pagination.has_prev %}\n        &lt;li class=\"page-item\"&gt;\n            &lt;a class=\"page-link\" href=\"?page={{ pagination.prev_num }}\"&gt;Previous&lt;/a&gt;\n        &lt;/li&gt;\n        {% endif %}\n\n        {% for page_num in pagination.iter_pages() %}\n        {% if page_num %}\n        &lt;li class=\"page-item {% if page_num == pagination.page %}active{% endif %}\"&gt;\n            &lt;a class=\"page-link\" href=\"?page={{ page_num }}\"&gt;{{ page_num }}&lt;/a&gt;\n        &lt;/li&gt;\n        {% else %}\n        &lt;li class=\"page-item disabled\"&gt;\n            &lt;span class=\"page-link\"&gt;...&lt;/span&gt;\n        &lt;/li&gt;\n        {% endif %}\n        {% endfor %}\n\n        {% if pagination.has_next %}\n        &lt;li class=\"page-item\"&gt;\n            &lt;a class=\"page-link\" href=\"?page={{ pagination.next_num }}\"&gt;Next&lt;/a&gt;\n        &lt;/li&gt;\n        {% endif %}\n    &lt;/ul&gt;\n&lt;/nav&gt;\n{% endif %}\n\n{% else %}\n&lt;div class=\"text-center py-5\"&gt;\n    &lt;h3&gt;No products found&lt;/h3&gt;\n    &lt;p class=\"text-muted\"&gt;Try adjusting your search or filter criteria.&lt;/p&gt;\n    &lt;a href=\"/products/new\" class=\"btn btn-primary\"&gt;Add First Product&lt;/a&gt;\n&lt;/div&gt;\n{% endif %}\n{% endblock %}\n</code></pre></p>"},{"location":"guides/templates/#form-templates","title":"Form Templates","text":""},{"location":"guides/templates/#form-rendering","title":"Form Rendering","text":"<p>Create reusable form templates:</p> <p>templates/forms/base_form.html: <pre><code>{% macro render_field(field, label=None, help_text=None, required=False) %}\n&lt;div class=\"mb-3\"&gt;\n    {% if label %}\n    &lt;label for=\"{{ field.name }}\" class=\"form-label\"&gt;\n        {{ label }}\n        {% if required %}&lt;span class=\"text-danger\"&gt;*&lt;/span&gt;{% endif %}\n    &lt;/label&gt;\n    {% endif %}\n\n    {% if field.type == 'textarea' %}\n    &lt;textarea class=\"form-control {% if field.errors %}is-invalid{% endif %}\" \n              id=\"{{ field.name }}\" name=\"{{ field.name }}\" \n              {% if required %}required{% endif %}\n              {% if field.placeholder %}placeholder=\"{{ field.placeholder }}\"{% endif %}\n              rows=\"{{ field.rows | default(4) }}\"&gt;{{ field.value | default('') }}&lt;/textarea&gt;\n    {% elif field.type == 'select' %}\n    &lt;select class=\"form-select {% if field.errors %}is-invalid{% endif %}\" \n            id=\"{{ field.name }}\" name=\"{{ field.name }}\" \n            {% if required %}required{% endif %}&gt;\n        {% if field.placeholder %}\n        &lt;option value=\"\"&gt;{{ field.placeholder }}&lt;/option&gt;\n        {% endif %}\n        {% for option in field.options %}\n        &lt;option value=\"{{ option.value }}\" \n                {% if option.value == field.value %}selected{% endif %}&gt;\n            {{ option.label }}\n        &lt;/option&gt;\n        {% endfor %}\n    &lt;/select&gt;\n    {% elif field.type == 'checkbox' %}\n    &lt;div class=\"form-check\"&gt;\n        &lt;input class=\"form-check-input {% if field.errors %}is-invalid{% endif %}\" \n               type=\"checkbox\" id=\"{{ field.name }}\" name=\"{{ field.name }}\" \n               value=\"true\" {% if field.value %}checked{% endif %}&gt;\n        &lt;label class=\"form-check-label\" for=\"{{ field.name }}\"&gt;\n            {{ label or field.label }}\n        &lt;/label&gt;\n    &lt;/div&gt;\n    {% else %}\n    &lt;input type=\"{{ field.type | default('text') }}\" \n           class=\"form-control {% if field.errors %}is-invalid{% endif %}\" \n           id=\"{{ field.name }}\" name=\"{{ field.name }}\" \n           value=\"{{ field.value | default('') }}\"\n           {% if required %}required{% endif %}\n           {% if field.placeholder %}placeholder=\"{{ field.placeholder }}\"{% endif %}&gt;\n    {% endif %}\n\n    {% if help_text %}\n    &lt;div class=\"form-text\"&gt;{{ help_text }}&lt;/div&gt;\n    {% endif %}\n\n    {% if field.errors %}\n    &lt;div class=\"invalid-feedback\"&gt;\n        {% for error in field.errors %}\n        {{ error }}{% if not loop.last %}&lt;br&gt;{% endif %}\n        {% endfor %}\n    &lt;/div&gt;\n    {% endif %}\n&lt;/div&gt;\n{% endmacro %}\n\n{% macro render_form_errors(errors) %}\n{% if errors %}\n&lt;div class=\"alert alert-danger\"&gt;\n    &lt;h6&gt;Please correct the following errors:&lt;/h6&gt;\n    &lt;ul class=\"mb-0\"&gt;\n        {% for error in errors %}\n        &lt;li&gt;{{ error }}&lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/div&gt;\n{% endif %}\n{% endmacro %}\n</code></pre></p> <p>templates/products/form.html: <pre><code>{% extends \"base.html\" %}\n{% from \"forms/base_form.html\" import render_field, render_form_errors %}\n\n{% block title %}\n{% if product.id %}Edit Product{% else %}New Product{% endif %}\n{% endblock %}\n\n{% block content %}\n&lt;div class=\"row justify-content-center\"&gt;\n    &lt;div class=\"col-lg-8\"&gt;\n        &lt;div class=\"card\"&gt;\n            &lt;div class=\"card-header\"&gt;\n                &lt;h4 class=\"mb-0\"&gt;\n                    {% if product.id %}\n                    Edit Product: {{ product.name }}\n                    {% else %}\n                    Add New Product\n                    {% endif %}\n                &lt;/h4&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"card-body\"&gt;\n                {{ render_form_errors(form_errors) }}\n\n                &lt;form method=\"post\" enctype=\"multipart/form-data\"&gt;\n                    {{ render_field(form.name, \"Product Name\", required=True) }}\n\n                    {{ render_field(form.description, \"Description\", \n                                  help_text=\"Provide a detailed description of the product\") }}\n\n                    &lt;div class=\"row\"&gt;\n                        &lt;div class=\"col-md-6\"&gt;\n                            {{ render_field(form.price, \"Price\", required=True) }}\n                        &lt;/div&gt;\n                        &lt;div class=\"col-md-6\"&gt;\n                            {{ render_field(form.category, \"Category\", required=True) }}\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n\n                    &lt;div class=\"row\"&gt;\n                        &lt;div class=\"col-md-6\"&gt;\n                            {{ render_field(form.stock_quantity, \"Stock Quantity\", required=True) }}\n                        &lt;/div&gt;\n                        &lt;div class=\"col-md-6\"&gt;\n                            {{ render_field(form.sku, \"SKU\", \n                                          help_text=\"Stock Keeping Unit (optional)\") }}\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n\n                    {{ render_field(form.image, \"Product Image\", \n                                  help_text=\"Upload an image for the product\") }}\n\n                    {{ render_field(form.featured, \"Featured Product\") }}\n\n                    {{ render_field(form.active, \"Active\") }}\n\n                    &lt;div class=\"d-flex justify-content-between\"&gt;\n                        &lt;a href=\"/products\" class=\"btn btn-secondary\"&gt;Cancel&lt;/a&gt;\n                        &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;\n                            {% if product.id %}Update Product{% else %}Create Product{% endif %}\n                        &lt;/button&gt;\n                    &lt;/div&gt;\n                &lt;/form&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n{% endblock %}\n</code></pre></p>"},{"location":"guides/templates/#advanced-template-features","title":"Advanced Template Features","text":""},{"location":"guides/templates/#custom-template-tags","title":"Custom Template Tags","text":"<p>Create custom template functions:</p> <pre><code># In template_engine.py\nclass TemplateEngine:\n    def __init__(self, template_dir: str = \"templates\"):\n        # ... existing code ...\n\n        # Add custom global functions\n        self.env.globals['url_for'] = self.url_for\n        self.env.globals['csrf_token'] = self.csrf_token\n        self.env.globals['static'] = self.static_url\n        self.env.globals['current_user'] = self.get_current_user\n\n    def url_for(self, endpoint: str, **kwargs) -&gt; str:\n        \"\"\"Generate URL for endpoint\"\"\"\n        # Implement URL generation logic\n        base_urls = {\n            'home': '/',\n            'products': '/products',\n            'product_detail': '/products/{id}',\n            'login': '/login',\n            'logout': '/logout'\n        }\n\n        url = base_urls.get(endpoint, '/')\n\n        # Replace path parameters\n        for key, value in kwargs.items():\n            url = url.replace(f'{{{key}}}', str(value))\n\n        return url\n\n    def csrf_token(self) -&gt; str:\n        \"\"\"Generate CSRF token\"\"\"\n        # Implement CSRF token generation\n        import secrets\n        return secrets.token_urlsafe(32)\n\n    def static_url(self, filename: str) -&gt; str:\n        \"\"\"Generate static file URL\"\"\"\n        return f\"/static/{filename}\"\n\n    def get_current_user(self):\n        \"\"\"Get current user from context\"\"\"\n        # This would typically come from request context\n        return None\n</code></pre>"},{"location":"guides/templates/#template-caching","title":"Template Caching","text":"<p>Implement template caching for better performance:</p> <pre><code>import asyncio\nfrom functools import lru_cache\nfrom typing import Dict, Any, Optional\n\nclass CachedTemplateEngine(TemplateEngine):\n    \"\"\"Template engine with caching support\"\"\"\n\n    def __init__(self, template_dir: str = \"templates\", cache_size: int = 128):\n        super().__init__(template_dir)\n        self.cache_size = cache_size\n        self._cache: Dict[str, str] = {}\n        self._cache_enabled = True\n\n    async def render(self, template_name: str, context: Dict[str, Any] = None) -&gt; str:\n        \"\"\"Render template with caching\"\"\"\n        context = context or {}\n\n        # Create cache key\n        cache_key = self._create_cache_key(template_name, context)\n\n        # Check cache\n        if self._cache_enabled and cache_key in self._cache:\n            return self._cache[cache_key]\n\n        # Render template\n        result = await super().render(template_name, context)\n\n        # Store in cache\n        if self._cache_enabled:\n            if len(self._cache) &gt;= self.cache_size:\n                # Remove oldest entry\n                oldest_key = next(iter(self._cache))\n                del self._cache[oldest_key]\n\n            self._cache[cache_key] = result\n\n        return result\n\n    def _create_cache_key(self, template_name: str, context: Dict[str, Any]) -&gt; str:\n        \"\"\"Create cache key from template name and context\"\"\"\n        import hashlib\n        import json\n\n        # Create a hash of the context (excluding non-serializable objects)\n        serializable_context = {}\n        for key, value in context.items():\n            try:\n                json.dumps(value)\n                serializable_context[key] = value\n            except (TypeError, ValueError):\n                # Skip non-serializable values\n                pass\n\n        context_hash = hashlib.md5(\n            json.dumps(serializable_context, sort_keys=True).encode()\n        ).hexdigest()\n\n        return f\"{template_name}:{context_hash}\"\n\n    def clear_cache(self):\n        \"\"\"Clear template cache\"\"\"\n        self._cache.clear()\n\n    def disable_cache(self):\n        \"\"\"Disable template caching\"\"\"\n        self._cache_enabled = False\n\n    def enable_cache(self):\n        \"\"\"Enable template caching\"\"\"\n        self._cache_enabled = True\n</code></pre>"},{"location":"guides/templates/#template-context-processors","title":"Template Context Processors","text":"<p>Add global context to all templates:</p> <pre><code>class TemplateContextProcessor:\n    \"\"\"Add global context to templates\"\"\"\n\n    def __init__(self):\n        self.global_context = {}\n\n    def add_global_context(self, **kwargs):\n        \"\"\"Add global context variables\"\"\"\n        self.global_context.update(kwargs)\n\n    def process_context(self, context: Dict[str, Any], request=None) -&gt; Dict[str, Any]:\n        \"\"\"Process template context\"\"\"\n        # Start with global context\n        processed_context = self.global_context.copy()\n\n        # Add request-specific context\n        if request:\n            processed_context.update({\n                'request': request,\n                'current_url': str(request.url),\n                'current_path': request.url.path,\n                'user_agent': request.headers.get('user-agent', ''),\n            })\n\n        # Add provided context (overrides global)\n        processed_context.update(context)\n\n        return processed_context\n\nclass EnhancedTemplateEngine(CachedTemplateEngine):\n    \"\"\"Template engine with context processing\"\"\"\n\n    def __init__(self, template_dir: str = \"templates\", cache_size: int = 128):\n        super().__init__(template_dir, cache_size)\n        self.context_processor = TemplateContextProcessor()\n\n        # Add default global context\n        self.context_processor.add_global_context(\n            app_name=\"Serv Application\",\n            version=\"1.0.0\",\n            current_year=2024\n        )\n\n    async def render(self, template_name: str, context: Dict[str, Any] = None, request=None) -&gt; str:\n        \"\"\"Render template with context processing\"\"\"\n        context = context or {}\n\n        # Process context\n        processed_context = self.context_processor.process_context(context, request)\n\n        return await super().render(template_name, processed_context)\n</code></pre>"},{"location":"guides/templates/#template-organization","title":"Template Organization","text":""},{"location":"guides/templates/#directory-structure","title":"Directory Structure","text":"<p>Organize templates logically:</p> <pre><code>templates/\n\u251c\u2500\u2500 base.html                 # Base template\n\u251c\u2500\u2500 layouts/\n\u2502   \u251c\u2500\u2500 admin.html           # Admin layout\n\u2502   \u251c\u2500\u2500 auth.html            # Authentication layout\n\u2502   \u2514\u2500\u2500 minimal.html         # Minimal layout\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 navbar.html          # Navigation component\n\u2502   \u251c\u2500\u2500 footer.html          # Footer component\n\u2502   \u251c\u2500\u2500 pagination.html      # Pagination component\n\u2502   \u2514\u2500\u2500 flash_messages.html  # Flash messages\n\u251c\u2500\u2500 forms/\n\u2502   \u251c\u2500\u2500 base_form.html       # Form macros\n\u2502   \u251c\u2500\u2500 login.html           # Login form\n\u2502   \u2514\u2500\u2500 register.html        # Registration form\n\u251c\u2500\u2500 products/\n\u2502   \u251c\u2500\u2500 list.html            # Product list\n\u2502   \u251c\u2500\u2500 detail.html          # Product detail\n\u2502   \u2514\u2500\u2500 form.html            # Product form\n\u251c\u2500\u2500 users/\n\u2502   \u251c\u2500\u2500 profile.html         # User profile\n\u2502   \u2514\u2500\u2500 settings.html        # User settings\n\u2514\u2500\u2500 errors/\n    \u251c\u2500\u2500 404.html             # Not found page\n    \u251c\u2500\u2500 500.html             # Server error page\n    \u2514\u2500\u2500 generic.html         # Generic error page\n</code></pre>"},{"location":"guides/templates/#component-templates","title":"Component Templates","text":"<p>Create reusable components:</p> <p>templates/components/pagination.html: <pre><code>{% macro render_pagination(pagination, endpoint='products', **kwargs) %}\n{% if pagination.pages &gt; 1 %}\n&lt;nav aria-label=\"Page navigation\"&gt;\n    &lt;ul class=\"pagination justify-content-center\"&gt;\n        &lt;!-- Previous page --&gt;\n        {% if pagination.has_prev %}\n        &lt;li class=\"page-item\"&gt;\n            &lt;a class=\"page-link\" href=\"{{ url_for(endpoint, page=pagination.prev_num, **kwargs) }}\"&gt;\n                &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt;\n                &lt;span class=\"sr-only\"&gt;Previous&lt;/span&gt;\n            &lt;/a&gt;\n        &lt;/li&gt;\n        {% else %}\n        &lt;li class=\"page-item disabled\"&gt;\n            &lt;span class=\"page-link\"&gt;\n                &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt;\n            &lt;/span&gt;\n        &lt;/li&gt;\n        {% endif %}\n\n        &lt;!-- Page numbers --&gt;\n        {% for page_num in pagination.iter_pages(left_edge=1, right_edge=1, left_current=1, right_current=2) %}\n        {% if page_num %}\n        {% if page_num != pagination.page %}\n        &lt;li class=\"page-item\"&gt;\n            &lt;a class=\"page-link\" href=\"{{ url_for(endpoint, page=page_num, **kwargs) }}\"&gt;{{ page_num }}&lt;/a&gt;\n        &lt;/li&gt;\n        {% else %}\n        &lt;li class=\"page-item active\"&gt;\n            &lt;span class=\"page-link\"&gt;{{ page_num }}&lt;/span&gt;\n        &lt;/li&gt;\n        {% endif %}\n        {% else %}\n        &lt;li class=\"page-item disabled\"&gt;\n            &lt;span class=\"page-link\"&gt;...&lt;/span&gt;\n        &lt;/li&gt;\n        {% endif %}\n        {% endfor %}\n\n        &lt;!-- Next page --&gt;\n        {% if pagination.has_next %}\n        &lt;li class=\"page-item\"&gt;\n            &lt;a class=\"page-link\" href=\"{{ url_for(endpoint, page=pagination.next_num, **kwargs) }}\"&gt;\n                &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt;\n                &lt;span class=\"sr-only\"&gt;Next&lt;/span&gt;\n            &lt;/a&gt;\n        &lt;/li&gt;\n        {% else %}\n        &lt;li class=\"page-item disabled\"&gt;\n            &lt;span class=\"page-link\"&gt;\n                &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt;\n            &lt;/span&gt;\n        &lt;/li&gt;\n        {% endif %}\n    &lt;/ul&gt;\n&lt;/nav&gt;\n{% endif %}\n{% endmacro %}\n</code></pre></p> <p>templates/components/flash_messages.html: <pre><code>{% macro render_flash_messages(messages) %}\n{% if messages %}\n&lt;div class=\"flash-messages\"&gt;\n    {% for message in messages %}\n    &lt;div class=\"alert alert-{{ message.category }} alert-dismissible fade show\" role=\"alert\"&gt;\n        {% if message.category == 'error' %}\n        &lt;i class=\"fas fa-exclamation-triangle me-2\"&gt;&lt;/i&gt;\n        {% elif message.category == 'success' %}\n        &lt;i class=\"fas fa-check-circle me-2\"&gt;&lt;/i&gt;\n        {% elif message.category == 'warning' %}\n        &lt;i class=\"fas fa-exclamation-circle me-2\"&gt;&lt;/i&gt;\n        {% elif message.category == 'info' %}\n        &lt;i class=\"fas fa-info-circle me-2\"&gt;&lt;/i&gt;\n        {% endif %}\n\n        {{ message.message }}\n\n        &lt;button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Close\"&gt;&lt;/button&gt;\n    &lt;/div&gt;\n    {% endfor %}\n&lt;/div&gt;\n{% endif %}\n{% endmacro %}\n</code></pre></p>"},{"location":"guides/templates/#template-route-integration","title":"Template Route Integration","text":""},{"location":"guides/templates/#complete-route-example","title":"Complete Route Example","text":"<pre><code>from serv.routes import Route, GetRequest, PostRequest\nfrom typing import Annotated\nfrom serv.responses import HtmlResponse, RedirectResponse\nfrom serv.exceptions import HTTPNotFoundException\nfrom bevy import dependency\nfrom extensions.templates.template_engine import EnhancedTemplateEngine\n\nclass ProductRoute(Route):\n    async def handle_get(\n        self, \n        request: GetRequest,\n        template_engine: EnhancedTemplateEngine = dependency()\n    ) -&gt; Annotated[str, HtmlResponse]:\n        \"\"\"Display product list or detail\"\"\"\n\n        # Check if this is a detail view\n        product_id = request.path_params.get('product_id')\n\n        if product_id:\n            return await self.show_product_detail(request, template_engine, product_id)\n        else:\n            return await self.show_product_list(request, template_engine)\n\n    async def show_product_list(self, request, template_engine):\n        \"\"\"Show product list\"\"\"\n        # Get query parameters\n        search = request.query_params.get('search', '')\n        category = request.query_params.get('category', '')\n        page = int(request.query_params.get('page', '1'))\n\n        # Fetch products (mock data)\n        products = await self.get_products(search, category, page)\n        categories = await self.get_categories()\n        pagination = await self.get_pagination(page, total_products=100)\n\n        context = {\n            'title': 'Products',\n            'products': products,\n            'categories': categories,\n            'pagination': pagination,\n            'search_query': search,\n            'selected_category': category\n        }\n\n        return await template_engine.render('products/list.html', context, request)\n\n    async def show_product_detail(self, request, template_engine, product_id):\n        \"\"\"Show product detail\"\"\"\n        product = await self.get_product(product_id)\n\n        if not product:\n            raise HTTPNotFoundException(f\"Product {product_id} not found\")\n\n        related_products = await self.get_related_products(product['category'])\n\n        context = {\n            'title': f\"{product['name']} - Product Detail\",\n            'product': product,\n            'related_products': related_products\n        }\n\n        return await template_engine.render('products/detail.html', context, request)\n\n    async def handle_post(\n        self, \n        request: PostRequest,\n        template_engine: EnhancedTemplateEngine = dependency()\n    ) -&gt; RedirectResponse:\n        \"\"\"Handle product creation/update\"\"\"\n\n        form_data = await request.form()\n\n        # Validate and process form\n        if await self.validate_product_form(form_data):\n            product = await self.save_product(form_data)\n            return RedirectResponse(f\"/products/{product['id']}\")\n        else:\n            # Re-render form with errors\n            context = {\n                'title': 'Product Form',\n                'form_data': form_data,\n                'form_errors': await self.get_form_errors(form_data)\n            }\n\n            html_content = await template_engine.render('products/form.html', context, request)\n            return HtmlResponse(html_content, status_code=400)\n\n    # Mock data methods\n    async def get_products(self, search, category, page):\n        \"\"\"Get products with filtering and pagination\"\"\"\n        return [\n            {\n                'id': i,\n                'name': f'Product {i}',\n                'description': f'Description for product {i}',\n                'price': 29.99 + i,\n                'category': 'Electronics',\n                'in_stock': True,\n                'image': f'/static/images/product{i}.jpg'\n            }\n            for i in range(1, 13)\n        ]\n\n    async def get_categories(self):\n        \"\"\"Get product categories\"\"\"\n        return [\n            {'id': 1, 'name': 'Electronics'},\n            {'id': 2, 'name': 'Clothing'},\n            {'id': 3, 'name': 'Books'},\n            {'id': 4, 'name': 'Home &amp; Garden'}\n        ]\n\n    async def get_pagination(self, page, total_products):\n        \"\"\"Get pagination info\"\"\"\n        per_page = 12\n        total_pages = (total_products + per_page - 1) // per_page\n\n        return {\n            'page': page,\n            'pages': total_pages,\n            'per_page': per_page,\n            'total': total_products,\n            'has_prev': page &gt; 1,\n            'has_next': page &lt; total_pages,\n            'prev_num': page - 1 if page &gt; 1 else None,\n            'next_num': page + 1 if page &lt; total_pages else None,\n            'iter_pages': lambda **kwargs: range(1, total_pages + 1)\n        }\n\n    async def get_product(self, product_id):\n        \"\"\"Get single product\"\"\"\n        return {\n            'id': product_id,\n            'name': f'Product {product_id}',\n            'description': 'Detailed product description...',\n            'price': 99.99,\n            'category': 'Electronics',\n            'in_stock': True,\n            'images': ['/static/images/product1.jpg', '/static/images/product2.jpg']\n        }\n\n    async def get_related_products(self, category):\n        \"\"\"Get related products\"\"\"\n        return [\n            {'id': i, 'name': f'Related Product {i}', 'price': 19.99 + i}\n            for i in range(1, 4)\n        ]\n</code></pre>"},{"location":"guides/templates/#best-practices","title":"Best Practices","text":""},{"location":"guides/templates/#1-template-organization","title":"1. Template Organization","text":"<pre><code># Good: Organized template structure\ntemplates/\n\u251c\u2500\u2500 base.html\n\u251c\u2500\u2500 layouts/\n\u251c\u2500\u2500 components/\n\u251c\u2500\u2500 pages/\n\u2514\u2500\u2500 forms/\n\n# Avoid: Flat structure\ntemplates/\n\u251c\u2500\u2500 template1.html\n\u251c\u2500\u2500 template2.html\n\u251c\u2500\u2500 template3.html\n</code></pre>"},{"location":"guides/templates/#2-context-management","title":"2. Context Management","text":"<pre><code># Good: Clear context structure\ncontext = {\n    'title': 'Page Title',\n    'user': current_user,\n    'data': {\n        'products': products,\n        'categories': categories\n    },\n    'meta': {\n        'page': page,\n        'total': total\n    }\n}\n\n# Avoid: Flat context\ncontext = {\n    'title': 'Page Title',\n    'user': current_user,\n    'products': products,\n    'categories': categories,\n    'page': page,\n    'total': total\n}\n</code></pre>"},{"location":"guides/templates/#3-template-inheritance","title":"3. Template Inheritance","text":"<pre><code>&lt;!-- Good: Use template inheritance --&gt;\n{% extends \"base.html\" %}\n{% block content %}\n&lt;!-- Page-specific content --&gt;\n{% endblock %}\n\n&lt;!-- Avoid: Duplicating layout code --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;!-- Repeated layout code --&gt;\n</code></pre>"},{"location":"guides/templates/#4-security","title":"4. Security","text":"<pre><code>&lt;!-- Good: Auto-escape user content --&gt;\n&lt;p&gt;{{ user.bio }}&lt;/p&gt;\n\n&lt;!-- Dangerous: Raw content without escaping --&gt;\n&lt;p&gt;{{ user.bio | safe }}&lt;/p&gt;  &lt;!-- Only if you trust the content --&gt;\n</code></pre>"},{"location":"guides/templates/#5-performance","title":"5. Performance","text":"<pre><code># Good: Cache templates in production\ntemplate_engine = CachedTemplateEngine(cache_size=256)\n\n# Good: Minimize context data\ncontext = {\n    'products': products[:10],  # Limit data\n    'user': {'name': user.name, 'id': user.id}  # Only needed fields\n}\n\n# Avoid: Large context objects\ncontext = {\n    'products': all_products,  # Too much data\n    'user': user  # Entire user object\n}\n</code></pre>"},{"location":"guides/templates/#development-workflow","title":"Development Workflow","text":""},{"location":"guides/templates/#1-set-up-template-engine","title":"1. Set Up Template Engine","text":"<p>Configure your preferred template engine with Serv.</p>"},{"location":"guides/templates/#2-create-base-templates","title":"2. Create Base Templates","text":"<p>Design your base layout and common components.</p>"},{"location":"guides/templates/#3-build-page-templates","title":"3. Build Page Templates","text":"<p>Create specific templates for each page type.</p>"},{"location":"guides/templates/#4-add-template-context","title":"4. Add Template Context","text":"<p>Ensure templates receive the data they need.</p>"},{"location":"guides/templates/#5-test-template-rendering","title":"5. Test Template Rendering","text":"<p>Test templates with various data scenarios.</p>"},{"location":"guides/templates/#next-steps","title":"Next Steps","text":"<ul> <li>Static Files - Serve CSS, JavaScript, and images</li> <li>Forms and File Uploads - Handle form submissions</li> <li>Authentication - Add user authentication</li> <li>Testing - Test your template rendering </li> </ul>"},{"location":"guides/testing/","title":"Testing","text":"<p>Testing is essential for building reliable web applications. Serv provides comprehensive testing support through pytest integration, test fixtures, and testing utilities. This guide covers how to effectively test Serv applications at all levels.</p>"},{"location":"guides/testing/#overview","title":"Overview","text":"<p>Serv's testing approach:</p> <ol> <li>Pytest Integration: Built on pytest with async support</li> <li>Test Fixtures: Pre-configured fixtures for common testing scenarios</li> <li>HTTP Client Testing: HTTPX AsyncClient for end-to-end testing</li> <li>Extension Testing: Isolated testing of extensions and components</li> <li>Mocking Support: Easy mocking of dependencies and external services</li> </ol>"},{"location":"guides/testing/#testing-architecture","title":"Testing Architecture","text":""},{"location":"guides/testing/#test-types","title":"Test Types","text":"<p>Serv supports multiple levels of testing:</p> <ul> <li>Unit Tests: Test individual functions and classes</li> <li>Integration Tests: Test component interactions</li> <li>End-to-End Tests: Test complete request/response cycles</li> <li>Extension Tests: Test extension functionality in isolation</li> <li>Middleware Tests: Test middleware behavior</li> </ul>"},{"location":"guides/testing/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Global test fixtures\n\u251c\u2500\u2500 unit/                    # Unit tests\n\u2502   \u251c\u2500\u2500 test_models.py\n\u2502   \u251c\u2500\u2500 test_utils.py\n\u2502   \u2514\u2500\u2500 test_validators.py\n\u251c\u2500\u2500 integration/             # Integration tests\n\u2502   \u251c\u2500\u2500 test_database.py\n\u2502   \u251c\u2500\u2500 test_auth_flow.py\n\u2502   \u2514\u2500\u2500 test_api_endpoints.py\n\u251c\u2500\u2500 e2e/                     # End-to-end tests\n\u2502   \u251c\u2500\u2500 conftest.py\n\u2502   \u251c\u2500\u2500 test_user_journey.py\n\u2502   \u2514\u2500\u2500 test_complete_flows.py\n\u2514\u2500\u2500 extensions/                 # Extension-specific tests\n    \u251c\u2500\u2500 test_auth_extension.py\n    \u251c\u2500\u2500 test_blog_extension.py\n    \u2514\u2500\u2500 test_api_extension.py\n</code></pre>"},{"location":"guides/testing/#setting-up-testing","title":"Setting Up Testing","text":""},{"location":"guides/testing/#install-testing-dependencies","title":"Install Testing Dependencies","text":"<pre><code>pip install pytest pytest-asyncio httpx\n</code></pre>"},{"location":"guides/testing/#basic-test-configuration","title":"Basic Test Configuration","text":"<p>pytest.ini: <pre><code>[tool:pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\nasyncio_mode = auto\naddopts = \n    -v\n    --tb=short\n    --strict-markers\n    --disable-warnings\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    e2e: End-to-end tests\n    slow: Slow running tests\n</code></pre></p>"},{"location":"guides/testing/#global-test-fixtures","title":"Global Test Fixtures","text":"<p>tests/conftest.py: <pre><code>import asyncio\nimport pytest\nimport pytest_asyncio\nfrom httpx import ASGITransport, AsyncClient\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator, Callable, Any\nfrom unittest.mock import patch\n\nfrom serv.app import App\nfrom serv.extensions import Extension\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create an instance of the default event loop for the test session.\"\"\"\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest_asyncio.fixture\nasync def app() -&gt; App:\n    \"\"\"Create a test app instance.\"\"\"\n    return App(dev_mode=True)\n\n\n@pytest_asyncio.fixture\nasync def client(app: App) -&gt; AsyncClient:\n    \"\"\"Basic test client fixture.\"\"\"\n    transport = ASGITransport(app=app)\n    async with AsyncClient(\n        transport=transport, \n        base_url=\"http://testserver\", \n        timeout=5.0\n    ) as c:\n        yield c\n\n\n@asynccontextmanager\nasync def create_test_client(\n    app_factory: Callable[[], App] = None,\n    extensions: list[Extension] = None,\n    config: dict[str, Any] = None,\n    base_url: str = \"http://testserver\",\n    use_lifespan: bool = True,\n    timeout: float = 5.0,\n) -&gt; AsyncGenerator[AsyncClient]:\n    \"\"\"\n    Create a test client for end-to-end testing with a fully configured App.\n\n    Args:\n        app_factory: Optional function that returns a fully configured App instance\n        extensions: Optional list of extensions to add to the app\n        config: Optional configuration to use when creating the app\n        base_url: Base URL to use for requests\n        use_lifespan: Whether to use the app's lifespan context\n        timeout: Request timeout in seconds\n\n    Returns:\n        An AsyncClient configured to communicate with the app\n    \"\"\"\n    # Create the app\n    if app_factory:\n        app = app_factory()\n    else:\n        app = App(dev_mode=True)\n\n        # Add extensions if provided\n        if extensions:\n            for extension in extensions:\n                app.add_extension(extension)\n\n    # Set up the transport\n    transport = ASGITransport(app=app)\n\n    # Use lifespan if requested\n    if use_lifespan:\n        lifespan_mgr = LifespanManager(app)\n        async with lifespan_mgr.lifespan():\n            async with AsyncClient(\n                transport=transport, \n                base_url=base_url, \n                timeout=timeout\n            ) as client:\n                yield client\n    else:\n        async with AsyncClient(\n            transport=transport, \n            base_url=base_url, \n            timeout=timeout\n        ) as client:\n            yield client\n\n\n@pytest_asyncio.fixture\nasync def app_test_client():\n    \"\"\"\n    Fixture that returns the create_test_client function.\n\n    Usage:\n        @pytest.mark.asyncio\n        async def test_custom_app(app_test_client):\n            async with app_test_client(extensions=[MyExtension()]) as client:\n                response = await client.get(\"/my-endpoint\")\n                assert response.status_code == 200\n    \"\"\"\n    return create_test_client\n\n\nclass LifespanManager:\n    \"\"\"Manage application lifespan for testing.\"\"\"\n\n    def __init__(self, app: App):\n        self.app = app\n        self.receive_queue = asyncio.Queue()\n        self.send_queue = asyncio.Queue()\n        self.lifespan_task = None\n\n    async def receive(self):\n        return await self.receive_queue.get()\n\n    async def send(self, message):\n        await self.send_queue.put(message)\n\n    async def startup(self):\n        self.lifespan_task = asyncio.create_task(\n            self.app.handle_lifespan({\"type\": \"lifespan\"}, self.receive, self.send)\n        )\n        await self.receive_queue.put({\"type\": \"lifespan.startup\"})\n        startup_complete = await self.send_queue.get()\n        if startup_complete[\"type\"] != \"lifespan.startup.complete\":\n            raise RuntimeError(f\"Unexpected response: {startup_complete}\")\n\n    async def shutdown(self):\n        if not self.lifespan_task:\n            raise RuntimeError(\"Cannot shutdown: lifespan task not started.\")\n        await self.receive_queue.put({\"type\": \"lifespan.shutdown\"})\n        shutdown_complete = await self.send_queue.get()\n        if shutdown_complete[\"type\"] != \"lifespan.shutdown.complete\":\n            raise RuntimeError(f\"Unexpected response: {shutdown_complete}\")\n        self.lifespan_task.cancel()\n        try:\n            await self.lifespan_task\n        except asyncio.CancelledError:\n            pass\n\n    @asynccontextmanager\n    async def lifespan(self):\n        await self.startup()\n        try:\n            yield\n        finally:\n            await self.shutdown()\n</code></pre></p>"},{"location":"guides/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"guides/testing/#testing-models-and-data-classes","title":"Testing Models and Data Classes","text":"<p>tests/unit/test_models.py: <pre><code>import pytest\nfrom datetime import datetime\nfrom extensions.blog.models import BlogPost, BlogStorage\n\ndef test_blog_post_creation():\n    \"\"\"Test BlogPost data class creation.\"\"\"\n    post = BlogPost(\n        id=1,\n        title=\"Test Post\",\n        content=\"This is a test post\",\n        author=\"Test Author\",\n        created_at=datetime.now()\n    )\n\n    assert post.id == 1\n    assert post.title == \"Test Post\"\n    assert post.content == \"This is a test post\"\n    assert post.author == \"Test Author\"\n    assert isinstance(post.created_at, datetime)\n\ndef test_blog_storage_operations():\n    \"\"\"Test BlogStorage operations.\"\"\"\n    storage = BlogStorage()\n\n    # Test adding a post\n    post = storage.add_post(\n        title=\"New Post\",\n        content=\"New content\",\n        author=\"Author\"\n    )\n\n    assert post.id is not None\n    assert post.title == \"New Post\"\n    assert len(storage.get_all_posts()) == 3  # Including sample data\n\n    # Test getting post by ID\n    retrieved_post = storage.get_post_by_id(post.id)\n    assert retrieved_post is not None\n    assert retrieved_post.title == \"New Post\"\n\n    # Test getting non-existent post\n    non_existent = storage.get_post_by_id(999)\n    assert non_existent is None\n\ndef test_blog_post_string_conversion():\n    \"\"\"Test BlogPost __post_init__ method.\"\"\"\n    # Test with string datetime\n    post = BlogPost(\n        id=1,\n        title=\"Test\",\n        content=\"Content\",\n        author=\"Author\",\n        created_at=\"2023-01-01T12:00:00\"\n    )\n\n    assert isinstance(post.created_at, datetime)\n    assert post.created_at.year == 2023\n</code></pre></p>"},{"location":"guides/testing/#testing-utility-functions","title":"Testing Utility Functions","text":"<p>tests/unit/test_utils.py: <pre><code>import pytest\nfrom extensions.auth.utils import hash_password, verify_password, validate_email\n\ndef test_password_hashing():\n    \"\"\"Test password hashing and verification.\"\"\"\n    password = \"test_password_123\"\n\n    # Test hashing\n    hashed = hash_password(password)\n    assert hashed != password\n    assert len(hashed) &gt; 0\n\n    # Test verification\n    assert verify_password(password, hashed)\n    assert not verify_password(\"wrong_password\", hashed)\n\ndef test_email_validation():\n    \"\"\"Test email validation function.\"\"\"\n    # Valid emails\n    assert validate_email(\"user@example.com\")\n    assert validate_email(\"test.email+tag@domain.co.uk\")\n    assert validate_email(\"user123@test-domain.org\")\n\n    # Invalid emails\n    assert not validate_email(\"invalid-email\")\n    assert not validate_email(\"@domain.com\")\n    assert not validate_email(\"user@\")\n    assert not validate_email(\"\")\n    assert not validate_email(None)\n\n@pytest.mark.parametrize(\"email,expected\", [\n    (\"valid@example.com\", True),\n    (\"another.valid@test.org\", True),\n    (\"invalid-email\", False),\n    (\"@invalid.com\", False),\n    (\"user@\", False),\n    (\"\", False),\n])\ndef test_email_validation_parametrized(email, expected):\n    \"\"\"Test email validation with multiple cases.\"\"\"\n    assert validate_email(email) == expected\n</code></pre></p>"},{"location":"guides/testing/#testing-form-validation","title":"Testing Form Validation","text":"<p>tests/unit/test_validators.py: <pre><code>import pytest\nfrom dataclasses import dataclass\nfrom extensions.auth.validators import validate_registration_form, ValidationError\n\n@dataclass\nclass MockRegistrationForm:\n    username: str\n    email: str\n    password: str\n    confirm_password: str\n\ndef test_valid_registration_form():\n    \"\"\"Test validation of valid registration form.\"\"\"\n    form = MockRegistrationForm(\n        username=\"testuser\",\n        email=\"test@example.com\",\n        password=\"password123\",\n        confirm_password=\"password123\"\n    )\n\n    # Should not raise any exception\n    validate_registration_form(form)\n\ndef test_invalid_username():\n    \"\"\"Test validation with invalid username.\"\"\"\n    form = MockRegistrationForm(\n        username=\"ab\",  # Too short\n        email=\"test@example.com\",\n        password=\"password123\",\n        confirm_password=\"password123\"\n    )\n\n    with pytest.raises(ValidationError) as exc_info:\n        validate_registration_form(form)\n\n    assert \"username\" in str(exc_info.value).lower()\n\ndef test_password_mismatch():\n    \"\"\"Test validation with password mismatch.\"\"\"\n    form = MockRegistrationForm(\n        username=\"testuser\",\n        email=\"test@example.com\",\n        password=\"password123\",\n        confirm_password=\"different_password\"\n    )\n\n    with pytest.raises(ValidationError) as exc_info:\n        validate_registration_form(form)\n\n    assert \"password\" in str(exc_info.value).lower()\n\ndef test_multiple_validation_errors():\n    \"\"\"Test validation with multiple errors.\"\"\"\n    form = MockRegistrationForm(\n        username=\"\",  # Empty username\n        email=\"invalid-email\",  # Invalid email\n        password=\"123\",  # Too short\n        confirm_password=\"456\"  # Mismatch\n    )\n\n    with pytest.raises(ValidationError) as exc_info:\n        validate_registration_form(form)\n\n    error_message = str(exc_info.value)\n    assert \"username\" in error_message.lower()\n    assert \"email\" in error_message.lower()\n    assert \"password\" in error_message.lower()\n</code></pre></p>"},{"location":"guides/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"guides/testing/#testing-route-handlers","title":"Testing Route Handlers","text":"<p>tests/integration/test_routes.py: <pre><code>import pytest\nfrom httpx import AsyncClient\nfrom serv.app import App\nfrom extensions.blog.blog_extension import BlogExtension\n\n@pytest.mark.asyncio\nasync def test_blog_homepage():\n    \"\"\"Test blog homepage route.\"\"\"\n    app = App(dev_mode=True)\n    app.add_extension(BlogExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/\")\n\n        assert response.status_code == 200\n        assert \"text/html\" in response.headers[\"content-type\"]\n        assert \"blog\" in response.text.lower()\n\n@pytest.mark.asyncio\nasync def test_blog_post_detail():\n    \"\"\"Test individual blog post route.\"\"\"\n    app = App(dev_mode=True)\n    app.add_extension(BlogExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test valid post ID\n        response = await client.get(\"/post/1\")\n        assert response.status_code == 200\n\n        # Test invalid post ID\n        response = await client.get(\"/post/999\")\n        assert response.status_code == 404\n\n        # Test non-numeric post ID\n        response = await client.get(\"/post/invalid\")\n        assert response.status_code == 400\n\n@pytest.mark.asyncio\nasync def test_api_posts_endpoint():\n    \"\"\"Test API posts endpoint.\"\"\"\n    app = App(dev_mode=True)\n    app.add_extension(BlogExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/api/posts\")\n\n        assert response.status_code == 200\n        assert response.headers[\"content-type\"] == \"application/json\"\n\n        data = response.json()\n        assert isinstance(data, list)\n        assert len(data) &gt; 0\n\n        # Check post structure\n        post = data[0]\n        assert \"id\" in post\n        assert \"title\" in post\n        assert \"content\" in post\n        assert \"author\" in post\n        assert \"created_at\" in post\n</code></pre></p>"},{"location":"guides/testing/#testing-form-handling","title":"Testing Form Handling","text":"<p>tests/integration/test_forms.py: <pre><code>import pytest\nfrom httpx import AsyncClient\nfrom serv.app import App\nfrom extensions.blog.blog_extension import BlogExtension\n\n@pytest.mark.asyncio\nasync def test_create_post_form():\n    \"\"\"Test blog post creation form.\"\"\"\n    app = App(dev_mode=True)\n    app.add_extension(BlogExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test GET request (show form)\n        response = await client.get(\"/admin\")\n        assert response.status_code == 200\n        assert \"form\" in response.text.lower()\n\n        # Test POST request (submit form)\n        form_data = {\n            \"title\": \"Test Post\",\n            \"content\": \"This is a test post content\",\n            \"author\": \"Test Author\"\n        }\n\n        response = await client.post(\"/admin\", data=form_data)\n        assert response.status_code == 200\n\n        # Verify post was created by checking the homepage\n        homepage_response = await client.get(\"/\")\n        assert \"Test Post\" in homepage_response.text\n\n@pytest.mark.asyncio\nasync def test_form_validation():\n    \"\"\"Test form validation errors.\"\"\"\n    app = App(dev_mode=True)\n    app.add_extension(BlogExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test with missing required fields\n        form_data = {\n            \"title\": \"\",  # Empty title\n            \"content\": \"Content\",\n            \"author\": \"Author\"\n        }\n\n        response = await client.post(\"/admin\", data=form_data)\n        assert response.status_code == 400\n        assert \"error\" in response.text.lower()\n\n@pytest.mark.asyncio\nasync def test_file_upload():\n    \"\"\"Test file upload handling.\"\"\"\n    app = App(dev_mode=True)\n    app.add_extension(BlogExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Create a test file\n        files = {\n            \"image\": (\"test.jpg\", b\"fake image data\", \"image/jpeg\")\n        }\n\n        form_data = {\n            \"title\": \"Post with Image\",\n            \"content\": \"Content with image\",\n            \"author\": \"Author\"\n        }\n\n        response = await client.post(\"/admin\", data=form_data, files=files)\n        assert response.status_code == 200\n</code></pre></p>"},{"location":"guides/testing/#testing-authentication-flow","title":"Testing Authentication Flow","text":"<p>tests/integration/test_auth_flow.py: <pre><code>import pytest\nfrom httpx import AsyncClient\nfrom serv.app import App\nfrom extensions.auth.auth_extension import AuthExtension\n\n@pytest.mark.asyncio\nasync def test_login_flow():\n    \"\"\"Test complete login flow.\"\"\"\n    app = App(dev_mode=True)\n    app.add_extension(AuthExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test login page\n        response = await client.get(\"/login\")\n        assert response.status_code == 200\n        assert \"login\" in response.text.lower()\n\n        # Test login with valid credentials\n        login_data = {\n            \"username\": \"admin\",\n            \"password\": \"admin123\"\n        }\n\n        response = await client.post(\"/login\", data=login_data)\n        assert response.status_code == 302  # Redirect after login\n\n        # Check that session cookie was set\n        assert \"session_id\" in response.cookies\n\n        # Test accessing protected route\n        response = await client.get(\"/dashboard\")\n        assert response.status_code == 200\n        assert \"dashboard\" in response.text.lower()\n\n@pytest.mark.asyncio\nasync def test_login_with_invalid_credentials():\n    \"\"\"Test login with invalid credentials.\"\"\"\n    app = App(dev_mode=True)\n    app.add_extension(AuthExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        login_data = {\n            \"username\": \"admin\",\n            \"password\": \"wrong_password\"\n        }\n\n        response = await client.post(\"/login\", data=login_data)\n        assert response.status_code == 400\n        assert \"invalid\" in response.text.lower()\n\n@pytest.mark.asyncio\nasync def test_logout_flow():\n    \"\"\"Test logout flow.\"\"\"\n    app = App(dev_mode=True)\n    app.add_extension(AuthExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Login first\n        login_data = {\n            \"username\": \"admin\",\n            \"password\": \"admin123\"\n        }\n        await client.post(\"/login\", data=login_data)\n\n        # Test logout\n        response = await client.post(\"/logout\")\n        assert response.status_code == 302  # Redirect after logout\n\n        # Check that session cookie was cleared\n        assert response.cookies.get(\"session_id\") == \"\"\n\n        # Test that protected route is no longer accessible\n        response = await client.get(\"/dashboard\")\n        assert response.status_code == 302  # Redirect to login\n\n@pytest.mark.asyncio\nasync def test_registration_flow():\n    \"\"\"Test user registration flow.\"\"\"\n    app = App(dev_mode=True)\n    app.add_extension(AuthExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test registration page\n        response = await client.get(\"/register\")\n        assert response.status_code == 200\n        assert \"register\" in response.text.lower()\n\n        # Test registration with valid data\n        registration_data = {\n            \"username\": \"newuser\",\n            \"email\": \"newuser@example.com\",\n            \"password\": \"password123\",\n            \"confirm_password\": \"password123\"\n        }\n\n        response = await client.post(\"/register\", data=registration_data)\n        assert response.status_code == 302  # Redirect after registration\n\n        # Check that user is automatically logged in\n        assert \"session_id\" in response.cookies\n\n        # Test accessing dashboard\n        response = await client.get(\"/dashboard\")\n        assert response.status_code == 200\n        assert \"newuser\" in response.text\n</code></pre></p>"},{"location":"guides/testing/#end-to-end-testing","title":"End-to-End Testing","text":""},{"location":"guides/testing/#testing-complete-user-journeys","title":"Testing Complete User Journeys","text":"<p>tests/e2e/test_user_journey.py: <pre><code>import pytest\nfrom httpx import AsyncClient\nfrom tests.conftest import create_test_client\nfrom extensions.blog.blog_extension import BlogExtension\nfrom extensions.auth.auth_extension import AuthExtension\n\n@pytest.mark.asyncio\nasync def test_complete_blog_user_journey():\n    \"\"\"Test complete user journey from registration to posting.\"\"\"\n\n    def create_blog_app():\n        app = App(dev_mode=True)\n        app.add_extension(AuthExtension())\n        app.add_extension(BlogExtension())\n        return app\n\n    async with create_test_client(app_factory=create_blog_app) as client:\n        # 1. Visit homepage\n        response = await client.get(\"/\")\n        assert response.status_code == 200\n\n        # 2. Register new user\n        registration_data = {\n            \"username\": \"blogger\",\n            \"email\": \"blogger@example.com\",\n            \"password\": \"password123\",\n            \"confirm_password\": \"password123\"\n        }\n\n        response = await client.post(\"/register\", data=registration_data)\n        assert response.status_code == 302\n\n        # 3. Access dashboard\n        response = await client.get(\"/dashboard\")\n        assert response.status_code == 200\n        assert \"blogger\" in response.text\n\n        # 4. Create a new blog post\n        post_data = {\n            \"title\": \"My First Post\",\n            \"content\": \"This is my first blog post!\",\n            \"author\": \"blogger\"\n        }\n\n        response = await client.post(\"/admin\", data=post_data)\n        assert response.status_code == 200\n\n        # 5. View the post on homepage\n        response = await client.get(\"/\")\n        assert \"My First Post\" in response.text\n\n        # 6. View individual post\n        response = await client.get(\"/post/3\")  # Assuming it's the 3rd post\n        assert response.status_code == 200\n        assert \"My First Post\" in response.text\n        assert \"This is my first blog post!\" in response.text\n\n        # 7. Logout\n        response = await client.post(\"/logout\")\n        assert response.status_code == 302\n\n        # 8. Verify logout worked\n        response = await client.get(\"/dashboard\")\n        assert response.status_code == 302  # Redirect to login\n\n@pytest.mark.asyncio\nasync def test_api_user_journey():\n    \"\"\"Test API user journey with authentication.\"\"\"\n\n    def create_api_app():\n        app = App(dev_mode=True)\n        app.add_extension(AuthExtension())\n        app.add_extension(BlogExtension())\n        return app\n\n    async with create_test_client(app_factory=create_api_app) as client:\n        # 1. Try API without authentication\n        response = await client.get(\"/api/posts\")\n        assert response.status_code == 401\n\n        # 2. Login to get session\n        login_data = {\n            \"username\": \"admin\",\n            \"password\": \"admin123\"\n        }\n        await client.post(\"/login\", data=login_data)\n\n        # 3. Access API with session\n        response = await client.get(\"/api/posts\")\n        assert response.status_code == 200\n\n        posts = response.json()\n        assert isinstance(posts, list)\n        assert len(posts) &gt; 0\n\n        # 4. Create post via API\n        post_data = {\n            \"title\": \"API Created Post\",\n            \"content\": \"Created via API\",\n            \"author\": \"admin\"\n        }\n\n        response = await client.post(\"/api/posts\", json=post_data)\n        assert response.status_code == 201\n\n        created_post = response.json()\n        assert created_post[\"title\"] == \"API Created Post\"\n\n        # 5. Verify post appears in list\n        response = await client.get(\"/api/posts\")\n        posts = response.json()\n\n        api_post = next(\n            (p for p in posts if p[\"title\"] == \"API Created Post\"), \n            None\n        )\n        assert api_post is not None\n</code></pre></p>"},{"location":"guides/testing/#testing-error-scenarios","title":"Testing Error Scenarios","text":"<p>tests/e2e/test_error_scenarios.py: <pre><code>import pytest\nfrom httpx import AsyncClient\nfrom tests.conftest import create_test_client\nfrom extensions.blog.blog_extension import BlogExtension\n\n@pytest.mark.asyncio\nasync def test_404_handling():\n    \"\"\"Test 404 error handling.\"\"\"\n    async with create_test_client(extensions=[BlogExtension()]) as client:\n        response = await client.get(\"/nonexistent-page\")\n        assert response.status_code == 404\n        assert \"not found\" in response.text.lower()\n\n@pytest.mark.asyncio\nasync def test_500_error_handling():\n    \"\"\"Test 500 error handling.\"\"\"\n    # Create a extension that raises an error\n    class ErrorExtension(Extension):\n        async def on_app_request_begin(self, router):\n            router.add_route(\"/error\", self.error_handler)\n\n        async def error_handler(self, response):\n            raise Exception(\"Test error\")\n\n    async with create_test_client(extensions=[ErrorExtension()]) as client:\n        response = await client.get(\"/error\")\n        assert response.status_code == 500\n\n@pytest.mark.asyncio\nasync def test_malformed_request_handling():\n    \"\"\"Test handling of malformed requests.\"\"\"\n    async with create_test_client(extensions=[BlogExtension()]) as client:\n        # Test with invalid JSON\n        response = await client.post(\n            \"/api/posts\",\n            data=\"invalid json\",\n            headers={\"content-type\": \"application/json\"}\n        )\n        assert response.status_code == 400\n\n@pytest.mark.asyncio\nasync def test_large_request_handling():\n    \"\"\"Test handling of large requests.\"\"\"\n    async with create_test_client(extensions=[BlogExtension()]) as client:\n        # Create a very large payload\n        large_content = \"x\" * (10 * 1024 * 1024)  # 10MB\n\n        response = await client.post(\n            \"/admin\",\n            data={\n                \"title\": \"Large Post\",\n                \"content\": large_content,\n                \"author\": \"Test\"\n            }\n        )\n\n        # Should handle gracefully (either accept or reject with proper error)\n        assert response.status_code in [200, 413, 400]\n</code></pre></p>"},{"location":"guides/testing/#extension-testing","title":"Extension Testing","text":""},{"location":"guides/testing/#testing-extension-functionality","title":"Testing Extension Functionality","text":"<p>tests/extensions/test_blog_extension.py: <pre><code>import pytest\nfrom serv.app import App\nfrom extensions.blog.blog_extension import BlogExtension\nfrom extensions.blog.models import BlogStorage\n\n@pytest.mark.asyncio\nasync def test_blog_extension_initialization():\n    \"\"\"Test blog extension initialization.\"\"\"\n    extension = BlogExtension()\n\n    assert hasattr(extension, 'storage')\n    assert isinstance(extension.storage, BlogStorage)\n    assert len(extension.storage.get_all_posts()) &gt; 0  # Has sample data\n\n@pytest.mark.asyncio\nasync def test_blog_extension_routes():\n    \"\"\"Test that blog extension registers routes correctly.\"\"\"\n    app = App(dev_mode=True)\n    extension = BlogExtension()\n    app.add_extension(extension)\n\n    # Test that routes are registered\n    # This would require access to app's router, which might need\n    # additional testing utilities\n\n@pytest.mark.asyncio\nasync def test_blog_extension_with_custom_storage():\n    \"\"\"Test blog extension with custom storage.\"\"\"\n    custom_storage = BlogStorage()\n    custom_storage.add_post(\"Custom Post\", \"Custom content\", \"Custom Author\")\n\n    extension = BlogExtension()\n    extension.storage = custom_storage\n\n    posts = extension.storage.get_all_posts()\n    custom_post = next(\n        (p for p in posts if p.title == \"Custom Post\"), \n        None\n    )\n    assert custom_post is not None\n    assert custom_post.content == \"Custom content\"\n\nclass TestBlogExtensionIntegration:\n    \"\"\"Integration tests for blog extension.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_extension_with_app(self, app_test_client):\n        \"\"\"Test blog extension integrated with app.\"\"\"\n        extension = BlogExtension()\n\n        async with app_test_client(extensions=[extension]) as client:\n            # Test homepage\n            response = await client.get(\"/\")\n            assert response.status_code == 200\n\n            # Test API endpoint\n            response = await client.get(\"/api/posts\")\n            assert response.status_code == 200\n\n            posts = response.json()\n            assert len(posts) &gt; 0\n\n    @pytest.mark.asyncio\n    async def test_extension_post_creation(self, app_test_client):\n        \"\"\"Test post creation through extension.\"\"\"\n        extension = BlogExtension()\n\n        async with app_test_client(extensions=[extension]) as client:\n            # Create a post\n            post_data = {\n                \"title\": \"Integration Test Post\",\n                \"content\": \"Created during integration test\",\n                \"author\": \"Test Suite\"\n            }\n\n            response = await client.post(\"/admin\", data=post_data)\n            assert response.status_code == 200\n\n            # Verify post was created\n            response = await client.get(\"/api/posts\")\n            posts = response.json()\n\n            test_post = next(\n                (p for p in posts if p[\"title\"] == \"Integration Test Post\"),\n                None\n            )\n            assert test_post is not None\n</code></pre></p>"},{"location":"guides/testing/#testing-extension-dependencies","title":"Testing Extension Dependencies","text":"<p>tests/extensions/test_extension_dependencies.py: <pre><code>import pytest\nfrom serv.app import App\nfrom extensions.auth.auth_extension import AuthExtension\nfrom extensions.blog.blog_extension import BlogExtension\n\n@pytest.mark.asyncio\nasync def test_extensions_work_together():\n    \"\"\"Test that multiple extensions work together correctly.\"\"\"\n    app = App(dev_mode=True)\n\n    # Add extensions in order\n    auth_extension = AuthExtension()\n    blog_extension = BlogExtension()\n\n    app.add_extension(auth_extension)\n    app.add_extension(blog_extension)\n\n    # Test that both extensions are active\n    # This would require testing the actual functionality\n\n@pytest.mark.asyncio\nasync def test_extension_middleware_interaction():\n    \"\"\"Test extension middleware interactions.\"\"\"\n    app = App(dev_mode=True)\n\n    # Add auth extension (provides auth middleware)\n    auth_extension = AuthExtension()\n    app.add_extension(auth_extension)\n\n    # Add blog extension (uses auth middleware)\n    blog_extension = BlogExtension()\n    app.add_extension(blog_extension)\n\n    # Test that auth middleware protects blog routes\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Test protected route without auth\n        response = await client.get(\"/admin\")\n        assert response.status_code == 302  # Redirect to login\n\n        # Login and test again\n        login_data = {\n            \"username\": \"admin\",\n            \"password\": \"admin123\"\n        }\n        await client.post(\"/login\", data=login_data)\n\n        response = await client.get(\"/admin\")\n        assert response.status_code == 200\n</code></pre></p>"},{"location":"guides/testing/#middleware-testing","title":"Middleware Testing","text":""},{"location":"guides/testing/#testing-middleware-behavior","title":"Testing Middleware Behavior","text":"<p>tests/test_middleware.py: <pre><code>import pytest\nfrom typing import AsyncIterator\nfrom httpx import AsyncClient\nfrom serv.app import App\nfrom serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import dependency\n\nasync def test_middleware(\n    request: Request = dependency(),\n    response: ResponseBuilder = dependency()\n) -&gt; AsyncIterator[None]:\n    \"\"\"Test middleware that adds headers.\"\"\"\n    # Before request processing\n    response.add_header(\"X-Test-Before\", \"active\")\n\n    yield  # Process request\n\n    # After request processing\n    response.add_header(\"X-Test-After\", \"active\")\n\n@pytest.mark.asyncio\nasync def test_middleware_adds_headers():\n    \"\"\"Test that middleware adds headers correctly.\"\"\"\n    app = App(dev_mode=True)\n    app.add_middleware(test_middleware)\n\n    # Add a simple route\n    class SimpleExtension(Extension):\n        async def on_app_request_begin(self, router):\n            router.add_route(\"/test\", self.handler)\n\n        async def handler(self, response: ResponseBuilder = dependency()):\n            response.body(\"OK\")\n\n    app.add_extension(SimpleExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/test\")\n\n        assert response.status_code == 200\n        assert response.text == \"OK\"\n        assert response.headers.get(\"X-Test-Before\") == \"active\"\n        assert response.headers.get(\"X-Test-After\") == \"active\"\n\n@pytest.mark.asyncio\nasync def test_middleware_error_handling():\n    \"\"\"Test middleware error handling.\"\"\"\n\n    async def error_middleware(\n        request: Request = dependency(),\n        response: ResponseBuilder = dependency()\n    ) -&gt; AsyncIterator[None]:\n        try:\n            yield\n        except Exception as e:\n            response.set_status(500)\n            response.body(f\"Middleware caught error: {str(e)}\")\n\n    app = App(dev_mode=True)\n    app.add_middleware(error_middleware)\n\n    # Add a route that raises an error\n    class ErrorExtension(Extension):\n        async def on_app_request_begin(self, router):\n            router.add_route(\"/error\", self.error_handler)\n\n        async def error_handler(self, response: ResponseBuilder = dependency()):\n            raise ValueError(\"Test error\")\n\n    app.add_extension(ErrorExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/error\")\n\n        assert response.status_code == 500\n        assert \"Middleware caught error\" in response.text\n\n@pytest.mark.asyncio\nasync def test_middleware_order():\n    \"\"\"Test middleware execution order.\"\"\"\n    execution_order = []\n\n    async def middleware_1(\n        request: Request = dependency(),\n        response: ResponseBuilder = dependency()\n    ) -&gt; AsyncIterator[None]:\n        execution_order.append(\"1-before\")\n        yield\n        execution_order.append(\"1-after\")\n\n    async def middleware_2(\n        request: Request = dependency(),\n        response: ResponseBuilder = dependency()\n    ) -&gt; AsyncIterator[None]:\n        execution_order.append(\"2-before\")\n        yield\n        execution_order.append(\"2-after\")\n\n    app = App(dev_mode=True)\n    app.add_middleware(middleware_1)\n    app.add_middleware(middleware_2)\n\n    # Add a simple route\n    class SimpleExtension(Extension):\n        async def on_app_request_begin(self, router):\n            router.add_route(\"/test\", self.handler)\n\n        async def handler(self, response: ResponseBuilder = dependency()):\n            execution_order.append(\"handler\")\n            response.body(\"OK\")\n\n    app.add_extension(SimpleExtension())\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/test\")\n\n        assert response.status_code == 200\n        # Middleware executes in LIFO order for request phase\n        # and FIFO order for response phase\n        expected_order = [\n            \"2-before\", \"1-before\", \"handler\", \"1-after\", \"2-after\"\n        ]\n        assert execution_order == expected_order\n</code></pre></p>"},{"location":"guides/testing/#mocking-and-test-doubles","title":"Mocking and Test Doubles","text":""},{"location":"guides/testing/#mocking-external-dependencies","title":"Mocking External Dependencies","text":"<p>tests/test_mocking.py: <pre><code>import pytest\nfrom unittest.mock import Mock, patch, AsyncMock\nfrom httpx import AsyncClient\nfrom serv.app import App\nfrom extensions.email.email_extension import EmailExtension\n\n@pytest.mark.asyncio\nasync def test_email_service_mock():\n    \"\"\"Test mocking external email service.\"\"\"\n\n    with patch('extensions.email.email_service.send_email') as mock_send:\n        mock_send.return_value = {\"status\": \"sent\", \"id\": \"12345\"}\n\n        app = App(dev_mode=True)\n        app.add_extension(EmailExtension())\n\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            email_data = {\n                \"to\": \"test@example.com\",\n                \"subject\": \"Test Email\",\n                \"body\": \"This is a test email\"\n            }\n\n            response = await client.post(\"/send-email\", json=email_data)\n\n            assert response.status_code == 200\n            assert mock_send.called\n            assert mock_send.call_args[0][0] == \"test@example.com\"\n\n@pytest.mark.asyncio\nasync def test_database_mock():\n    \"\"\"Test mocking database operations.\"\"\"\n\n    mock_db = Mock()\n    mock_db.fetch_all.return_value = [\n        {\"id\": 1, \"title\": \"Mocked Post\", \"content\": \"Mocked content\"}\n    ]\n\n    with patch('extensions.blog.models.get_database', return_value=mock_db):\n        app = App(dev_mode=True)\n        app.add_extension(BlogExtension())\n\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            response = await client.get(\"/api/posts\")\n\n            assert response.status_code == 200\n            posts = response.json()\n            assert len(posts) == 1\n            assert posts[0][\"title\"] == \"Mocked Post\"\n\n@pytest.mark.asyncio\nasync def test_async_service_mock():\n    \"\"\"Test mocking async services.\"\"\"\n\n    async def mock_async_operation():\n        return {\"result\": \"mocked\"}\n\n    with patch('extensions.api.external_service.fetch_data', new=mock_async_operation):\n        app = App(dev_mode=True)\n        app.add_extension(APIExtension())\n\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            response = await client.get(\"/api/external-data\")\n\n            assert response.status_code == 200\n            data = response.json()\n            assert data[\"result\"] == \"mocked\"\n\nclass TestMockingWithFixtures:\n    \"\"\"Test mocking using pytest fixtures.\"\"\"\n\n    @pytest.fixture\n    def mock_email_service(self):\n        with patch('extensions.email.email_service.EmailService') as mock:\n            mock_instance = Mock()\n            mock_instance.send_email = AsyncMock(return_value={\"status\": \"sent\"})\n            mock.return_value = mock_instance\n            yield mock_instance\n\n    @pytest.mark.asyncio\n    async def test_with_mock_fixture(self, mock_email_service):\n        \"\"\"Test using mock fixture.\"\"\"\n        app = App(dev_mode=True)\n        app.add_extension(EmailExtension())\n\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            response = await client.post(\"/send-email\", json={\n                \"to\": \"test@example.com\",\n                \"subject\": \"Test\",\n                \"body\": \"Test body\"\n            })\n\n            assert response.status_code == 200\n            assert mock_email_service.send_email.called\n</code></pre></p>"},{"location":"guides/testing/#creating-test-doubles","title":"Creating Test Doubles","text":"<p>tests/test_doubles.py: <pre><code>import pytest\nfrom typing import List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n# Test doubles for models\n@dataclass\nclass MockUser:\n    id: int\n    username: str\n    email: str\n    is_active: bool = True\n\nclass MockUserStorage:\n    \"\"\"Test double for user storage.\"\"\"\n\n    def __init__(self):\n        self.users = [\n            MockUser(1, \"admin\", \"admin@example.com\"),\n            MockUser(2, \"user\", \"user@example.com\"),\n        ]\n        self.next_id = 3\n\n    def get_user_by_id(self, user_id: int) -&gt; Optional[MockUser]:\n        return next((u for u in self.users if u.id == user_id), None)\n\n    def get_user_by_username(self, username: str) -&gt; Optional[MockUser]:\n        return next((u for u in self.users if u.username == username), None)\n\n    def create_user(self, username: str, email: str) -&gt; MockUser:\n        user = MockUser(self.next_id, username, email)\n        self.users.append(user)\n        self.next_id += 1\n        return user\n\nclass MockEmailService:\n    \"\"\"Test double for email service.\"\"\"\n\n    def __init__(self):\n        self.sent_emails = []\n\n    async def send_email(self, to: str, subject: str, body: str) -&gt; dict:\n        email = {\n            \"to\": to,\n            \"subject\": subject,\n            \"body\": body,\n            \"sent_at\": datetime.now(),\n            \"id\": f\"mock_{len(self.sent_emails) + 1}\"\n        }\n        self.sent_emails.append(email)\n        return {\"status\": \"sent\", \"id\": email[\"id\"]}\n\n    def get_sent_emails(self) -&gt; List[dict]:\n        return self.sent_emails.copy()\n\n@pytest.mark.asyncio\nasync def test_with_test_doubles():\n    \"\"\"Test using test doubles instead of mocks.\"\"\"\n\n    # Use test doubles\n    user_storage = MockUserStorage()\n    email_service = MockEmailService()\n\n    # Test user creation\n    user = user_storage.create_user(\"newuser\", \"new@example.com\")\n    assert user.username == \"newuser\"\n    assert user.id == 3\n\n    # Test email sending\n    result = await email_service.send_email(\n        \"test@example.com\", \n        \"Welcome\", \n        \"Welcome to our service!\"\n    )\n\n    assert result[\"status\"] == \"sent\"\n    assert len(email_service.get_sent_emails()) == 1\n\n    sent_email = email_service.get_sent_emails()[0]\n    assert sent_email[\"to\"] == \"test@example.com\"\n    assert sent_email[\"subject\"] == \"Welcome\"\n</code></pre></p>"},{"location":"guides/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"guides/testing/#load-testing","title":"Load Testing","text":"<p>tests/performance/test_load.py: <pre><code>import pytest\nimport asyncio\nimport time\nfrom httpx import AsyncClient\nfrom tests.conftest import create_test_client\nfrom extensions.blog.blog_extension import BlogExtension\n\n@pytest.mark.slow\n@pytest.mark.asyncio\nasync def test_concurrent_requests():\n    \"\"\"Test handling of concurrent requests.\"\"\"\n\n    async def make_request(client: AsyncClient, path: str) -&gt; dict:\n        start_time = time.time()\n        response = await client.get(path)\n        end_time = time.time()\n\n        return {\n            \"status_code\": response.status_code,\n            \"response_time\": end_time - start_time,\n            \"path\": path\n        }\n\n    async with create_test_client(extensions=[BlogExtension()]) as client:\n        # Make 50 concurrent requests\n        tasks = []\n        for i in range(50):\n            path = \"/\" if i % 2 == 0 else \"/api/posts\"\n            tasks.append(make_request(client, path))\n\n        results = await asyncio.gather(*tasks)\n\n        # Analyze results\n        successful_requests = [r for r in results if r[\"status_code\"] == 200]\n        assert len(successful_requests) == 50\n\n        # Check response times\n        avg_response_time = sum(r[\"response_time\"] for r in results) / len(results)\n        max_response_time = max(r[\"response_time\"] for r in results)\n\n        print(f\"Average response time: {avg_response_time:.3f}s\")\n        print(f\"Max response time: {max_response_time:.3f}s\")\n\n        # Assert reasonable performance\n        assert avg_response_time &lt; 1.0  # Average under 1 second\n        assert max_response_time &lt; 5.0  # Max under 5 seconds\n\n@pytest.mark.slow\n@pytest.mark.asyncio\nasync def test_memory_usage():\n    \"\"\"Test memory usage under load.\"\"\"\n    import psutil\n    import os\n\n    process = psutil.Process(os.getpid())\n    initial_memory = process.memory_info().rss\n\n    async with create_test_client(extensions=[BlogExtension()]) as client:\n        # Make many requests to test for memory leaks\n        for i in range(100):\n            response = await client.get(\"/\")\n            assert response.status_code == 200\n\n            if i % 10 == 0:\n                current_memory = process.memory_info().rss\n                memory_increase = current_memory - initial_memory\n                print(f\"Request {i}: Memory increase: {memory_increase / 1024 / 1024:.2f} MB\")\n\n    final_memory = process.memory_info().rss\n    total_increase = final_memory - initial_memory\n\n    # Assert memory usage is reasonable (less than 100MB increase)\n    assert total_increase &lt; 100 * 1024 * 1024\n</code></pre></p>"},{"location":"guides/testing/#test-organization-and-best-practices","title":"Test Organization and Best Practices","text":""},{"location":"guides/testing/#test-configuration","title":"Test Configuration","text":"<p>pytest.ini: <pre><code>[tool:pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\nasyncio_mode = auto\naddopts = \n    -v\n    --tb=short\n    --strict-markers\n    --disable-warnings\n    --cov=serv\n    --cov=extensions\n    --cov-report=html\n    --cov-report=term-missing\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    e2e: End-to-end tests\n    slow: Slow running tests\n    auth: Authentication related tests\n    database: Database related tests\n</code></pre></p>"},{"location":"guides/testing/#test-utilities","title":"Test Utilities","text":"<p>tests/utils.py: <pre><code>from typing import Any, Dict, List\nfrom httpx import AsyncClient\nfrom serv.app import App\n\nclass TestDataBuilder:\n    \"\"\"Builder for creating test data.\"\"\"\n\n    @staticmethod\n    def create_user_data(**overrides) -&gt; Dict[str, Any]:\n        \"\"\"Create user test data.\"\"\"\n        default_data = {\n            \"username\": \"testuser\",\n            \"email\": \"test@example.com\",\n            \"password\": \"password123\",\n            \"confirm_password\": \"password123\"\n        }\n        default_data.update(overrides)\n        return default_data\n\n    @staticmethod\n    def create_post_data(**overrides) -&gt; Dict[str, Any]:\n        \"\"\"Create blog post test data.\"\"\"\n        default_data = {\n            \"title\": \"Test Post\",\n            \"content\": \"This is test content\",\n            \"author\": \"Test Author\"\n        }\n        default_data.update(overrides)\n        return default_data\n\nclass APITestHelper:\n    \"\"\"Helper for API testing.\"\"\"\n\n    def __init__(self, client: AsyncClient):\n        self.client = client\n        self.auth_token = None\n\n    async def login(self, username: str = \"admin\", password: str = \"admin123\"):\n        \"\"\"Login and store session.\"\"\"\n        response = await self.client.post(\"/login\", data={\n            \"username\": username,\n            \"password\": password\n        })\n        assert response.status_code == 302\n        return response\n\n    async def logout(self):\n        \"\"\"Logout and clear session.\"\"\"\n        response = await self.client.post(\"/logout\")\n        assert response.status_code == 302\n        return response\n\n    async def create_post(self, **post_data):\n        \"\"\"Create a blog post.\"\"\"\n        data = TestDataBuilder.create_post_data(**post_data)\n        response = await self.client.post(\"/admin\", data=data)\n        return response\n\n    async def get_posts(self):\n        \"\"\"Get all posts via API.\"\"\"\n        response = await self.client.get(\"/api/posts\")\n        assert response.status_code == 200\n        return response.json()\n\ndef assert_valid_post(post: Dict[str, Any]):\n    \"\"\"Assert that a post has valid structure.\"\"\"\n    required_fields = [\"id\", \"title\", \"content\", \"author\", \"created_at\"]\n    for field in required_fields:\n        assert field in post, f\"Post missing required field: {field}\"\n\n    assert isinstance(post[\"id\"], int)\n    assert len(post[\"title\"]) &gt; 0\n    assert len(post[\"content\"]) &gt; 0\n    assert len(post[\"author\"]) &gt; 0\n\ndef assert_valid_user(user: Dict[str, Any]):\n    \"\"\"Assert that a user has valid structure.\"\"\"\n    required_fields = [\"id\", \"username\", \"email\", \"is_active\"]\n    for field in required_fields:\n        assert field in user, f\"User missing required field: {field}\"\n\n    assert isinstance(user[\"id\"], int)\n    assert \"@\" in user[\"email\"]\n    assert isinstance(user[\"is_active\"], bool)\n</code></pre></p>"},{"location":"guides/testing/#test-patterns","title":"Test Patterns","text":"<p>tests/patterns/test_patterns.py: <pre><code>import pytest\nfrom httpx import AsyncClient\nfrom tests.utils import APITestHelper, TestDataBuilder, assert_valid_post\n\nclass TestBlogAPIPatterns:\n    \"\"\"Test patterns for blog API.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_crud_pattern(self, app_test_client):\n        \"\"\"Test CRUD operations pattern.\"\"\"\n        async with app_test_client(extensions=[BlogExtension()]) as client:\n            helper = APITestHelper(client)\n            await helper.login()\n\n            # Create\n            post_data = TestDataBuilder.create_post_data(title=\"CRUD Test Post\")\n            create_response = await helper.create_post(**post_data)\n            assert create_response.status_code == 200\n\n            # Read\n            posts = await helper.get_posts()\n            crud_post = next(\n                (p for p in posts if p[\"title\"] == \"CRUD Test Post\"),\n                None\n            )\n            assert crud_post is not None\n            assert_valid_post(crud_post)\n\n            # Update (if implemented)\n            # update_response = await client.put(f\"/api/posts/{crud_post['id']}\", ...)\n\n            # Delete (if implemented)\n            # delete_response = await client.delete(f\"/api/posts/{crud_post['id']}\")\n\n    @pytest.mark.asyncio\n    async def test_authentication_pattern(self, app_test_client):\n        \"\"\"Test authentication pattern.\"\"\"\n        async with app_test_client(extensions=[AuthExtension(), BlogExtension()]) as client:\n            helper = APITestHelper(client)\n\n            # Test unauthenticated access\n            response = await client.get(\"/dashboard\")\n            assert response.status_code == 302  # Redirect to login\n\n            # Test authentication\n            await helper.login()\n\n            # Test authenticated access\n            response = await client.get(\"/dashboard\")\n            assert response.status_code == 200\n\n            # Test logout\n            await helper.logout()\n\n            # Test access after logout\n            response = await client.get(\"/dashboard\")\n            assert response.status_code == 302  # Redirect to login again\n\n    @pytest.mark.asyncio\n    async def test_error_handling_pattern(self, app_test_client):\n        \"\"\"Test error handling pattern.\"\"\"\n        async with app_test_client(extensions=[BlogExtension()]) as client:\n            # Test 404\n            response = await client.get(\"/nonexistent\")\n            assert response.status_code == 404\n\n            # Test 400 (bad request)\n            response = await client.post(\"/admin\", data={})  # Missing required fields\n            assert response.status_code == 400\n\n            # Test 405 (method not allowed)\n            response = await client.delete(\"/\")  # DELETE not allowed on homepage\n            assert response.status_code == 405\n</code></pre></p>"},{"location":"guides/testing/#best-practices","title":"Best Practices","text":""},{"location":"guides/testing/#1-test-organization","title":"1. Test Organization","text":"<pre><code># Good: Organize tests by functionality\ntests/\n\u251c\u2500\u2500 unit/\n\u2502   \u251c\u2500\u2500 test_models.py\n\u2502   \u251c\u2500\u2500 test_validators.py\n\u2502   \u2514\u2500\u2500 test_utils.py\n\u251c\u2500\u2500 integration/\n\u2502   \u251c\u2500\u2500 test_auth_flow.py\n\u2502   \u251c\u2500\u2500 test_api_endpoints.py\n\u2502   \u2514\u2500\u2500 test_form_handling.py\n\u2514\u2500\u2500 e2e/\n    \u251c\u2500\u2500 test_user_journeys.py\n    \u2514\u2500\u2500 test_complete_flows.py\n\n# Avoid: Mixing test types in single files\n</code></pre>"},{"location":"guides/testing/#2-use-descriptive-test-names","title":"2. Use Descriptive Test Names","text":"<pre><code># Good: Descriptive test names\ndef test_user_registration_with_valid_data_creates_user_and_logs_in():\n    pass\n\ndef test_login_with_invalid_password_returns_400_error():\n    pass\n\n# Avoid: Vague test names\ndef test_user_stuff():\n    pass\n\ndef test_login():\n    pass\n</code></pre>"},{"location":"guides/testing/#3-follow-aaa-pattern","title":"3. Follow AAA Pattern","text":"<pre><code># Good: Arrange, Act, Assert pattern\n@pytest.mark.asyncio\nasync def test_blog_post_creation():\n    # Arrange\n    app = App(dev_mode=True)\n    app.add_extension(BlogExtension())\n    post_data = {\n        \"title\": \"Test Post\",\n        \"content\": \"Test content\",\n        \"author\": \"Test Author\"\n    }\n\n    # Act\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.post(\"/admin\", data=post_data)\n\n    # Assert\n    assert response.status_code == 200\n    assert \"Test Post\" in response.text\n</code></pre>"},{"location":"guides/testing/#4-use-fixtures-for-common-setup","title":"4. Use Fixtures for Common Setup","text":"<pre><code># Good: Use fixtures for repeated setup\n@pytest.fixture\nasync def authenticated_client(app_test_client):\n    async with app_test_client(extensions=[AuthExtension()]) as client:\n        await client.post(\"/login\", data={\n            \"username\": \"admin\",\n            \"password\": \"admin123\"\n        })\n        yield client\n\n@pytest.mark.asyncio\nasync def test_protected_route(authenticated_client):\n    response = await authenticated_client.get(\"/dashboard\")\n    assert response.status_code == 200\n</code></pre>"},{"location":"guides/testing/#5-test-edge-cases","title":"5. Test Edge Cases","text":"<pre><code># Good: Test edge cases and error conditions\n@pytest.mark.asyncio\nasync def test_post_creation_with_empty_title():\n    \"\"\"Test that empty title is rejected.\"\"\"\n    # Test implementation\n\n@pytest.mark.asyncio\nasync def test_post_creation_with_very_long_title():\n    \"\"\"Test that very long titles are handled properly.\"\"\"\n    # Test implementation\n\n@pytest.mark.asyncio\nasync def test_post_creation_with_special_characters():\n    \"\"\"Test that special characters in content are handled.\"\"\"\n    # Test implementation\n</code></pre>"},{"location":"guides/testing/#6-mock-external-dependencies","title":"6. Mock External Dependencies","text":"<pre><code># Good: Mock external services\n@patch('extensions.email.email_service.send_email')\n@pytest.mark.asyncio\nasync def test_user_registration_sends_welcome_email(mock_send_email):\n    mock_send_email.return_value = {\"status\": \"sent\"}\n\n    # Test registration\n    # Verify email was sent\n    assert mock_send_email.called\n\n# Avoid: Testing against real external services in unit tests\n</code></pre>"},{"location":"guides/testing/#running-tests","title":"Running Tests","text":""},{"location":"guides/testing/#using-serv-cli-recommended","title":"Using Serv CLI (Recommended)","text":"<p>Serv provides a built-in test command that integrates with your application:</p> <pre><code># Run all tests\nserv test\n\n# Run only extension tests\nserv test --extensions\n\n# Run only end-to-end tests\nserv test --e2e\n\n# Run with coverage report\nserv test --coverage\n\n# Run specific test file\nserv test tests/test_auth.py\n\n# Verbose output with coverage\nserv test --verbose --coverage\n</code></pre>"},{"location":"guides/testing/#direct-pytest-execution","title":"Direct pytest Execution","text":"<p>You can also run tests directly with pytest:</p> <pre><code># Run all tests\npytest\n\n# Run specific test file\npytest tests/test_auth.py\n\n# Run tests with specific marker\npytest -m unit\npytest -m integration\npytest -m e2e\n\n# Run tests with coverage\npytest --cov=serv --cov=extensions\n\n# Run tests in parallel\npytest -n auto\n</code></pre>"},{"location":"guides/testing/#test-configuration_1","title":"Test Configuration","text":"<pre><code># Run with verbose output\npytest -v\n\n# Run with detailed output on failures\npytest -vvv\n\n# Stop on first failure\npytest -x\n\n# Run only failed tests from last run\npytest --lf\n\n# Run tests matching pattern\npytest -k \"test_auth\"\n</code></pre>"},{"location":"guides/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Deployment - Deploy tested applications</li> <li>Performance - Performance testing and optimization</li> <li>Monitoring - Monitor applications in production </li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>serv<ul> <li>_app</li> <li>_routing</li> <li>additional_context</li> <li>app</li> <li>app_factory</li> <li>bundled<ul> <li>database<ul> <li>ommi<ul> <li>factory</li> </ul> </li> </ul> </li> <li>extensions<ul> <li>welcome<ul> <li>welcome</li> </ul> </li> </ul> </li> </ul> </li> <li>config</li> <li>database<ul> <li>cli</li> <li>exceptions</li> <li>factory</li> <li>lifecycle</li> <li>manager</li> </ul> </li> <li>di</li> <li>exceptions</li> <li>extensions<ul> <li>extensions</li> <li>importer</li> <li>loader</li> <li>middleware</li> <li>router_extension</li> </ul> </li> <li>http<ul> <li>forms</li> <li>requests</li> <li>responses</li> </ul> </li> <li>injectors</li> <li>multipart_parser</li> <li>protocols</li> <li>requests</li> <li>responses</li> <li>routes</li> <li>routing<ul> <li>decorators</li> <li>generation</li> <li>handlers</li> <li>patterns</li> <li>resolvers</li> <li>router</li> </ul> </li> <li>serv</li> <li>test_client</li> <li>websocket</li> </ul> </li> </ul>"},{"location":"reference/serv/","title":"serv","text":""},{"location":"reference/serv/#serv","title":"serv","text":"<p>Serv - A modern Python web framework built for simplicity and extensibility.</p> <p>Serv is an ASGI-based web framework that emphasizes: - Extension-based architecture for extensible functionality - Dependency injection for clean, testable code - Type-safe request/response handling - Automatic route discovery and URL generation - Built-in form handling and validation - Middleware support for cross-cutting concerns - Template rendering with Jinja2 - Event-driven extension system - WebSocket support for real-time communication</p> Quick Start <pre><code>from serv import App\nfrom serv.routes import Route, GetRequest\nfrom serv.responses import TextResponse\nfrom typing import Annotated\n\n# Create the application\napp = App()\n\n# Define a route\nclass HelloRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[str, TextResponse]:\n        name = request.query_params.get(\"name\", \"World\")\n        return f\"Hello, {name}!\"\n\n# Run with: uvicorn main:app --reload\n</code></pre> WebSocket Support <pre><code>from serv import App, WebSocket\nfrom serv.websocket import FrameType\nfrom typing import Annotated\n\napp = App()\n\n# Simple echo WebSocket handler\nasync def websocket_handler(websocket: WebSocket):\n    async for message in websocket:\n        await websocket.send(message)\n\n# Binary WebSocket handler\nasync def binary_handler(ws: Annotated[WebSocket, FrameType.BINARY]):\n    async for message in ws:\n        # message is bytes\n        await ws.send(message)\n</code></pre> Key Components <ul> <li>App: Main application class and ASGI entry point</li> <li>Route: Base class for HTTP route handlers</li> <li>WebSocket: WebSocket connection handler for real-time communication</li> <li>Extension: Base class for extending application functionality</li> <li>Router: URL routing and path matching</li> <li>ResponseBuilder: Fluent response construction</li> <li>Request types: Type-safe request handling (GetRequest, PostRequest, etc.)</li> <li>Response types: Structured response objects (JsonResponse, HtmlResponse, etc.)</li> <li>Forms: Automatic form parsing and validation</li> <li>Exceptions: HTTP-aware exception handling</li> <li>create_test_app_client: Test client factory for end-to-end testing</li> </ul> <p>For detailed documentation and examples, visit: https://serv.dev/docs</p>"},{"location":"reference/serv/#serv.App","title":"App","text":"<pre><code>App(\n    *,\n    config: str = \"./serv.config.yaml\",\n    extension_dir: str = \"./extensions\",\n    dev_mode: bool = False,\n)\n</code></pre> <p>               Bases: <code>EventEmitterProtocol</code>, <code>AppContextProtocol</code></p> <p>The main ASGI application class for Serv web framework.</p> <p>This class serves as the central orchestrator for your web application, handling incoming HTTP requests, managing extensions, middleware, routing, and dependency injection. It implements the ASGI (Asynchronous Server Gateway Interface) specification.</p> <p>The App class provides: - Extension system for extensible functionality - Middleware stack for request/response processing - Dependency injection container - Error handling and custom error pages - Template rendering capabilities - Event emission system for extension communication</p> <p>Examples:</p> <p>Basic application setup:</p> <pre><code>from serv import App\n\n# Create a basic app\napp = App()\n\n# Create app with custom config\napp = App(config=\"./config/production.yaml\")\n\n# Create app with custom extension directory\napp = App(extension_dir=\"./my_extensions\")\n\n# Development mode with enhanced debugging\napp = App(dev_mode=True)\n</code></pre> <p>Using with ASGI servers:</p> <pre><code># For uvicorn\n# uvicorn main:app --reload\n\n# For gunicorn\n# gunicorn main:app -k uvicorn.workers.UvicornWorker\n</code></pre> <p>Advanced configuration:</p> <pre><code>app = App(\n    config=\"./config/production.yaml\",\n    extension_dir=\"./extensions\",\n    dev_mode=False\n)\n\n# Add custom error handler\nasync def custom_404_handler(error):\n    # Handle 404 errors\n    pass\n\napp.add_error_handler(HTTPNotFoundException, custom_404_handler)\n\n# Add middleware\nasync def logging_middleware():\n    # Middleware logic\n    yield\n\napp.add_middleware(logging_middleware)\n</code></pre> <p>Initialize a new Serv application instance.</p> <p>Creates and configures a new ASGI application with the specified settings. This includes setting up the dependency injection container, loading extensions, configuring middleware, and preparing the routing system.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>Path to the YAML configuration file. The config file defines site information, enabled extensions, middleware stack, and other application settings. Defaults to \"./serv.config.yaml\".</p> <code>'./serv.config.yaml'</code> <code>extension_dir</code> <code>str</code> <p>Directory path where extensions are located. Extensions in this directory will be available for loading. Defaults to \"./extensions\".</p> <code>'./extensions'</code> <code>extension_dir</code> <code>str</code> <p>Legacy parameter name for extension_dir (backward compatibility).</p> <code>'./extensions'</code> <code>dev_mode</code> <code>bool</code> <p>Enable development mode features including enhanced error reporting, debug logging, and development-specific behaviors. Should be False in production. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ServConfigError</code> <p>If the configuration file cannot be loaded or contains invalid YAML/configuration structure.</p> <code>ImportError</code> <p>If required dependencies for extensions cannot be imported.</p> <code>ValueError</code> <p>If extension_dir path is invalid or inaccessible.</p> <p>Examples:</p> <p>Basic initialization:</p> <pre><code># Use default settings\napp = App()\n\n# Custom config file\napp = App(config=\"config/production.yaml\")\n\n# Custom extension directory\napp = App(extension_dir=\"src/extensions\")\n\n# Development mode\napp = App(dev_mode=True)\n</code></pre> <p>Production setup:</p> <pre><code>app = App(\n    config=\"/etc/myapp/config.yaml\",\n    extension_dir=\"/opt/myapp/extensions\",\n    dev_mode=False\n)\n</code></pre> <p>Development setup:</p> <pre><code>app = App(\n    config=\"dev.config.yaml\",\n    extension_dir=\"./dev_extensions\",\n    dev_mode=True\n)\n</code></pre> Note <p>The application will automatically load the welcome extension if no other extensions are configured, providing a default landing page for new projects.</p> Source code in <code>serv/_app.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: str = \"./serv.config.yaml\",\n    extension_dir: str = \"./extensions\",\n    dev_mode: bool = False,\n):\n    \"\"\"Initialize a new Serv application instance.\n\n    Creates and configures a new ASGI application with the specified settings.\n    This includes setting up the dependency injection container, loading extensions,\n    configuring middleware, and preparing the routing system.\n\n    Args:\n        config: Path to the YAML configuration file. The config file defines\n            site information, enabled extensions, middleware stack, and other\n            application settings. Defaults to \"./serv.config.yaml\".\n        extension_dir: Directory path where extensions are located. Extensions in this\n            directory will be available for loading. Defaults to \"./extensions\".\n        extension_dir: Legacy parameter name for extension_dir (backward compatibility).\n        dev_mode: Enable development mode features including enhanced error\n            reporting, debug logging, and development-specific behaviors.\n            Should be False in production. Defaults to False.\n\n    Raises:\n        ServConfigError: If the configuration file cannot be loaded or contains\n            invalid YAML/configuration structure.\n        ImportError: If required dependencies for extensions cannot be imported.\n        ValueError: If extension_dir path is invalid or inaccessible.\n\n    Examples:\n        Basic initialization:\n\n        ```python\n        # Use default settings\n        app = App()\n\n        # Custom config file\n        app = App(config=\"config/production.yaml\")\n\n        # Custom extension directory\n        app = App(extension_dir=\"src/extensions\")\n\n        # Development mode\n        app = App(dev_mode=True)\n        ```\n\n        Production setup:\n\n        ```python\n        app = App(\n            config=\"/etc/myapp/config.yaml\",\n            extension_dir=\"/opt/myapp/extensions\",\n            dev_mode=False\n        )\n        ```\n\n        Development setup:\n\n        ```python\n        app = App(\n            config=\"dev.config.yaml\",\n            extension_dir=\"./dev_extensions\",\n            dev_mode=True\n        )\n        ```\n\n    Note:\n        The application will automatically load the welcome extension if no other\n        extensions are configured, providing a default landing page for new projects.\n    \"\"\"\n    self._config = self._load_config(config)\n    self._dev_mode = dev_mode\n    self._registry = get_registry()\n    self._container = self._registry.create_container()\n    self._async_exit_stack = contextlib.AsyncExitStack()\n    self._error_handlers: dict[\n        type[Exception], Callable[[Exception], Awaitable[None]]\n    ] = {}\n    self._middleware = []\n\n    # Handle backward compatibility for extension_dir parameter\n    actual_extension_dir = extension_dir if extension_dir is None else extension_dir\n    self._extension_loader = Importer(actual_extension_dir)\n    self._extensions: dict[Path, list[Listener]] = defaultdict(list)\n\n    # Initialize the extension loader\n    self._extension_loader_instance = ExtensionLoader(self, self._extension_loader)\n\n    self._emit = EventEmitter(self._extensions)\n\n    # Initialize database manager\n    self._database_manager = DatabaseManager(self._config, self._container)\n\n    self._init_container()\n    self._register_default_error_handlers()\n    self._init_extensions(\n        self._config.get(\"extensions\", self._config.get(\"extensions\", []))\n    )\n</code></pre>"},{"location":"reference/serv/#serv.App.dev_mode","title":"dev_mode  <code>property</code> <code>writable</code>","text":"<pre><code>dev_mode: bool\n</code></pre> <p>Get the current development mode setting.</p>"},{"location":"reference/serv/#serv.App.add_error_handler","title":"add_error_handler","text":"<pre><code>add_error_handler(\n    error_type: type[Exception],\n    handler: Callable[[Exception], Awaitable[None]],\n)\n</code></pre> <p>Register a custom error handler for specific exception types.</p> <p>Error handlers allow you to customize how your application responds to different types of errors, providing custom error pages, logging, or recovery mechanisms.</p> <p>Parameters:</p> Name Type Description Default <code>error_type</code> <code>type[Exception]</code> <p>The exception class to handle. The handler will be called for this exception type and any of its subclasses.</p> required <code>handler</code> <code>Callable[[Exception], Awaitable[None]]</code> <p>An async function that will be called when the exception occurs. The handler receives the exception instance and can use dependency injection to access request/response objects.</p> required <p>Examples:</p> <p>Handle 404 errors with a custom page:</p> <pre><code>from serv.exceptions import HTTPNotFoundException\nfrom serv.responses import ResponseBuilder\nfrom bevy import injectable, Inject\n\n@injectable\nasync def custom_404_handler(\n    error: HTTPNotFoundException,\n    response: Inject[ResponseBuilder]\n):\n    response.set_status(404)\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;Page Not Found&lt;/h1&gt;&lt;p&gt;Sorry, that page doesn't exist.&lt;/p&gt;\")\n\napp.add_error_handler(HTTPNotFoundException, custom_404_handler)\n</code></pre> <p>Handle validation errors:</p> <pre><code>class ValidationError(Exception):\n    def __init__(self, message: str, field: str):\n        self.message = message\n        self.field = field\n\n@injectable\nasync def validation_error_handler(\n    error: ValidationError,\n    response: Inject[ResponseBuilder]\n):\n    response.set_status(400)\n    response.content_type(\"application/json\")\n    response.body({\n        \"error\": \"validation_failed\",\n        \"message\": error.message,\n        \"field\": error.field\n    })\n\napp.add_error_handler(ValidationError, validation_error_handler)\n</code></pre> <p>Generic error handler with logging:</p> <pre><code>import logging\n\n@injectable\nasync def generic_error_handler(\n    error: Exception,\n    response: Inject[ResponseBuilder],\n    request: Inject[Request]\n):\n    logging.error(f\"Unhandled error on {request.path}: {error}\")\n    response.set_status(500)\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;Internal Server Error&lt;/h1&gt;\")\n\napp.add_error_handler(Exception, generic_error_handler)\n</code></pre> Source code in <code>serv/_app.py</code> <pre><code>def add_error_handler(\n    self,\n    error_type: type[Exception],\n    handler: Callable[[Exception], Awaitable[None]],\n):\n    \"\"\"Register a custom error handler for specific exception types.\n\n    Error handlers allow you to customize how your application responds to\n    different types of errors, providing custom error pages, logging, or\n    recovery mechanisms.\n\n    Args:\n        error_type: The exception class to handle. The handler will be called\n            for this exception type and any of its subclasses.\n        handler: An async function that will be called when the exception occurs.\n            The handler receives the exception instance and can use dependency\n            injection to access request/response objects.\n\n    Examples:\n        Handle 404 errors with a custom page:\n\n        ```python\n        from serv.exceptions import HTTPNotFoundException\n        from serv.responses import ResponseBuilder\n        from bevy import injectable, Inject\n\n        @injectable\n        async def custom_404_handler(\n            error: HTTPNotFoundException,\n            response: Inject[ResponseBuilder]\n        ):\n            response.set_status(404)\n            response.content_type(\"text/html\")\n            response.body(\"&lt;h1&gt;Page Not Found&lt;/h1&gt;&lt;p&gt;Sorry, that page doesn't exist.&lt;/p&gt;\")\n\n        app.add_error_handler(HTTPNotFoundException, custom_404_handler)\n        ```\n\n        Handle validation errors:\n\n        ```python\n        class ValidationError(Exception):\n            def __init__(self, message: str, field: str):\n                self.message = message\n                self.field = field\n\n        @injectable\n        async def validation_error_handler(\n            error: ValidationError,\n            response: Inject[ResponseBuilder]\n        ):\n            response.set_status(400)\n            response.content_type(\"application/json\")\n            response.body({\n                \"error\": \"validation_failed\",\n                \"message\": error.message,\n                \"field\": error.field\n            })\n\n        app.add_error_handler(ValidationError, validation_error_handler)\n        ```\n\n        Generic error handler with logging:\n\n        ```python\n        import logging\n\n        @injectable\n        async def generic_error_handler(\n            error: Exception,\n            response: Inject[ResponseBuilder],\n            request: Inject[Request]\n        ):\n            logging.error(f\"Unhandled error on {request.path}: {error}\")\n            response.set_status(500)\n            response.content_type(\"text/html\")\n            response.body(\"&lt;h1&gt;Internal Server Error&lt;/h1&gt;\")\n\n        app.add_error_handler(Exception, generic_error_handler)\n        ```\n    \"\"\"\n    self._error_handlers[error_type] = handler\n</code></pre>"},{"location":"reference/serv/#serv.App.add_middleware","title":"add_middleware","text":"<pre><code>add_middleware(\n    middleware: Callable[[], AsyncIterator[None]],\n)\n</code></pre> <p>Add middleware to the application's middleware stack.</p> <p>Middleware functions are executed in the order they are added, wrapping around the request handling process. They can modify requests, responses, add headers, implement authentication, logging, and more.</p> <p>Parameters:</p> Name Type Description Default <code>middleware</code> <code>Callable[[], AsyncIterator[None]]</code> <p>An async generator function that yields control to the next middleware or route handler. The function should yield exactly once.</p> required <p>Examples:</p> <p>Basic logging middleware:</p> <pre><code>import logging\nfrom serv.requests import Request\nfrom bevy import injectable, Inject\n\n@injectable\nasync def logging_middleware(\n    request: Inject[Request]\n):\n    logging.info(f\"Request: {request.method} {request.path}\")\n    start_time = time.time()\n\n    yield  # Pass control to next middleware/handler\n\n    duration = time.time() - start_time\n    logging.info(f\"Response time: {duration:.3f}s\")\n\napp.add_middleware(logging_middleware)\n</code></pre> <p>Authentication middleware:</p> <pre><code>from serv.responses import ResponseBuilder\nfrom serv.requests import Request\nfrom bevy import injectable, Inject\n\n@injectable\nasync def auth_middleware(\n    request: Inject[Request],\n    response: Inject[ResponseBuilder]\n):\n    # Check for authentication\n    auth_header = request.headers.get(\"authorization\")\n    if not auth_header and request.path.startswith(\"/api/\"):\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body({\"error\": \"Authentication required\"})\n        return  # Don't yield, stop processing\n\n    yield  # Continue to next middleware/handler\n\napp.add_middleware(auth_middleware)\n</code></pre> <p>CORS middleware:</p> <pre><code>@injectable\nasync def cors_middleware(\n    request: Inject[Request],\n    response: Inject[ResponseBuilder]\n):\n    # Add CORS headers\n    response.add_header(\"Access-Control-Allow-Origin\", \"*\")\n    response.add_header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n    response.add_header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\n    # Handle preflight requests\n    if request.method == \"OPTIONS\":\n        response.set_status(200)\n        return\n\n    yield  # Continue processing\n\napp.add_middleware(cors_middleware)\n</code></pre> Note <p>Middleware is executed in LIFO (Last In, First Out) order during request processing, and FIFO (First In, First Out) order during response processing.</p> Source code in <code>serv/_app.py</code> <pre><code>def add_middleware(self, middleware: Callable[[], AsyncIterator[None]]):\n    \"\"\"Add middleware to the application's middleware stack.\n\n    Middleware functions are executed in the order they are added, wrapping\n    around the request handling process. They can modify requests, responses,\n    add headers, implement authentication, logging, and more.\n\n    Args:\n        middleware: An async generator function that yields control to the next\n            middleware or route handler. The function should yield exactly once.\n\n    Examples:\n        Basic logging middleware:\n\n        ```python\n        import logging\n        from serv.requests import Request\n        from bevy import injectable, Inject\n\n        @injectable\n        async def logging_middleware(\n            request: Inject[Request]\n        ):\n            logging.info(f\"Request: {request.method} {request.path}\")\n            start_time = time.time()\n\n            yield  # Pass control to next middleware/handler\n\n            duration = time.time() - start_time\n            logging.info(f\"Response time: {duration:.3f}s\")\n\n        app.add_middleware(logging_middleware)\n        ```\n\n        Authentication middleware:\n\n        ```python\n        from serv.responses import ResponseBuilder\n        from serv.requests import Request\n        from bevy import injectable, Inject\n\n        @injectable\n        async def auth_middleware(\n            request: Inject[Request],\n            response: Inject[ResponseBuilder]\n        ):\n            # Check for authentication\n            auth_header = request.headers.get(\"authorization\")\n            if not auth_header and request.path.startswith(\"/api/\"):\n                response.set_status(401)\n                response.content_type(\"application/json\")\n                response.body({\"error\": \"Authentication required\"})\n                return  # Don't yield, stop processing\n\n            yield  # Continue to next middleware/handler\n\n        app.add_middleware(auth_middleware)\n        ```\n\n        CORS middleware:\n\n        ```python\n        @injectable\n        async def cors_middleware(\n            request: Inject[Request],\n            response: Inject[ResponseBuilder]\n        ):\n            # Add CORS headers\n            response.add_header(\"Access-Control-Allow-Origin\", \"*\")\n            response.add_header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n            response.add_header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\n            # Handle preflight requests\n            if request.method == \"OPTIONS\":\n                response.set_status(200)\n                return\n\n            yield  # Continue processing\n\n        app.add_middleware(cors_middleware)\n        ```\n\n    Note:\n        Middleware is executed in LIFO (Last In, First Out) order during request\n        processing, and FIFO (First In, First Out) order during response processing.\n    \"\"\"\n    self._middleware.append(middleware)\n</code></pre>"},{"location":"reference/serv/#serv.App.emit","title":"emit  <code>async</code>","text":"<pre><code>emit(\n    event: str, *, container: Inject[Container], **kwargs\n) -&gt; None\n</code></pre> <p>Async emit method for EventEmitterProtocol compliance.</p> Source code in <code>serv/_app.py</code> <pre><code>@injectable\nasync def emit(self, event: str, *, container: Inject[Container], **kwargs) -&gt; None:\n    \"\"\"Async emit method for EventEmitterProtocol compliance.\"\"\"\n    await self._emit.emit(event, container=container, **kwargs)\n</code></pre>"},{"location":"reference/serv/#serv.App.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(callback: Callable[[], Awaitable[None]])\n</code></pre> <p>Add a callback to be called when the application is shutting down.</p> Source code in <code>serv/_app.py</code> <pre><code>def on_shutdown(self, callback: Callable[[], Awaitable[None]]):\n    \"\"\"Add a callback to be called when the application is shutting down.\"\"\"\n    self._async_exit_stack.push_async_callback(callback)\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket","title":"WebSocket","text":"<pre><code>WebSocket(\n    scope, receive, send, frame_type: FrameType = TEXT\n)\n</code></pre> <p>WebSocket connection handler for managing bidirectional communication.</p> <p>The WebSocket class provides async iteration over incoming messages and methods for sending messages back to the client. It handles frame types, connection state, and proper WebSocket protocol compliance.</p> <p>Examples:</p> <p>Basic echo handler:</p> <pre><code>async def echo_handler(websocket: WebSocket):\n    async for message in websocket:\n        await websocket.send(message)\n</code></pre> <p>JSON message handling:</p> <pre><code>async def json_handler(websocket: WebSocket):\n    async for message in websocket:\n        try:\n            data = json.loads(message)\n            response = {\"echo\": data, \"timestamp\": time.time()}\n            await websocket.send_json(response)\n        except json.JSONDecodeError:\n            await websocket.send_json({\"error\": \"Invalid JSON\"})\n</code></pre> <p>Binary message handling:</p> <pre><code>from typing import Annotated\nfrom serv.websocket import FrameType\n\nasync def binary_handler(ws: Annotated[WebSocket, FrameType.BINARY]):\n    async for message in ws:\n        # message is bytes\n        processed = process_binary_data(message)\n        await ws.send(processed)\n</code></pre> <p>Initialize WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <p>ASGI scope dict for WebSocket connection</p> required <code>receive</code> <p>ASGI receive callable for incoming messages</p> required <code>send</code> <p>ASGI send callable for outgoing messages</p> required <code>frame_type</code> <code>FrameType</code> <p>Preferred frame type for messages (TEXT or BINARY)</p> <code>TEXT</code> Source code in <code>serv/websocket.py</code> <pre><code>def __init__(self, scope, receive, send, frame_type: FrameType = FrameType.TEXT):\n    \"\"\"Initialize WebSocket connection.\n\n    Args:\n        scope: ASGI scope dict for WebSocket connection\n        receive: ASGI receive callable for incoming messages\n        send: ASGI send callable for outgoing messages\n        frame_type: Preferred frame type for messages (TEXT or BINARY)\n    \"\"\"\n    if scope[\"type\"] != \"websocket\":\n        raise ValueError(\"WebSocket requires 'websocket' scope type\")\n\n    self.scope = scope\n    self._receive = receive\n    self._send = send\n    self.frame_type = frame_type\n    self.state = WebSocketState.CONNECTING\n    self._closed = False\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.client","title":"client  <code>property</code>","text":"<pre><code>client\n</code></pre> <p>Client connection information.</p>"},{"location":"reference/serv/#serv.WebSocket.headers","title":"headers  <code>property</code>","text":"<pre><code>headers: dict[str, str]\n</code></pre> <p>The WebSocket request headers.</p>"},{"location":"reference/serv/#serv.WebSocket.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>True if WebSocket connection is active.</p>"},{"location":"reference/serv/#serv.WebSocket.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>The WebSocket request path.</p>"},{"location":"reference/serv/#serv.WebSocket.query_string","title":"query_string  <code>property</code>","text":"<pre><code>query_string: str\n</code></pre> <p>The WebSocket request query string.</p>"},{"location":"reference/serv/#serv.WebSocket.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry - automatically accept connection.</p> Source code in <code>serv/websocket.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry - automatically accept connection.\"\"\"\n    await self.accept()\n    return self\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit - automatically close connection.</p> Source code in <code>serv/websocket.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit - automatically close connection.\"\"\"\n    await self.close()\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; AsyncIterator[str | bytes]\n</code></pre> <p>Enable async iteration over WebSocket messages.</p> <p>Yields:</p> Type Description <code>AsyncIterator[str | bytes]</code> <p>Messages received from the WebSocket connection</p> <p>Examples:</p> <pre><code>async def handler(websocket: WebSocket):\n    async for message in websocket:\n        print(f\"Received: {message}\")\n        await websocket.send(f\"Echo: {message}\")\n</code></pre> Source code in <code>serv/websocket.py</code> <pre><code>def __aiter__(self) -&gt; AsyncIterator[str | bytes]:\n    \"\"\"Enable async iteration over WebSocket messages.\n\n    Yields:\n        Messages received from the WebSocket connection\n\n    Examples:\n        ```python\n        async def handler(websocket: WebSocket):\n            async for message in websocket:\n                print(f\"Received: {message}\")\n                await websocket.send(f\"Echo: {message}\")\n        ```\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.__anext__","title":"__anext__  <code>async</code>","text":"<pre><code>__anext__() -&gt; str | bytes\n</code></pre> <p>Get the next message from the WebSocket connection.</p> <p>Returns:</p> Type Description <code>str | bytes</code> <p>The next received message</p> <p>Raises:</p> Type Description <code>StopAsyncIteration</code> <p>When the connection is closed</p> <code>WebSocketConnectionError</code> <p>If there's a connection error</p> Source code in <code>serv/websocket.py</code> <pre><code>async def __anext__(self) -&gt; str | bytes:\n    \"\"\"Get the next message from the WebSocket connection.\n\n    Returns:\n        The next received message\n\n    Raises:\n        StopAsyncIteration: When the connection is closed\n        WebSocketConnectionError: If there's a connection error\n    \"\"\"\n    try:\n        return await self.receive()\n    except WebSocketConnectionError:\n        # Convert connection errors to StopAsyncIteration for proper async iteration\n        raise StopAsyncIteration from None\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.accept","title":"accept  <code>async</code>","text":"<pre><code>accept(subprotocol: str | None = None) -&gt; None\n</code></pre> <p>Accept the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>subprotocol</code> <code>str | None</code> <p>Optional WebSocket subprotocol to accept</p> <code>None</code> <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection cannot be accepted</p> Source code in <code>serv/websocket.py</code> <pre><code>async def accept(self, subprotocol: str | None = None) -&gt; None:\n    \"\"\"Accept the WebSocket connection.\n\n    Args:\n        subprotocol: Optional WebSocket subprotocol to accept\n\n    Raises:\n        WebSocketConnectionError: If connection cannot be accepted\n    \"\"\"\n    if self.state != WebSocketState.CONNECTING:\n        raise WebSocketConnectionError(\"WebSocket connection already established\")\n\n    # Consume the initial websocket.connect message\n    try:\n        connect_message = await self._receive()\n        if connect_message[\"type\"] != \"websocket.connect\":\n            raise WebSocketConnectionError(\n                f\"Expected websocket.connect, got {connect_message['type']}\"\n            )\n    except Exception as e:\n        self.state = WebSocketState.DISCONNECTED\n        raise WebSocketConnectionError(\n            f\"Failed to receive connection message: {e}\"\n        ) from e\n\n    try:\n        accept_message = {\"type\": \"websocket.accept\"}\n        if subprotocol:\n            accept_message[\"subprotocol\"] = subprotocol\n\n        await self._send(accept_message)\n        self.state = WebSocketState.CONNECTED\n\n    except Exception as e:\n        self.state = WebSocketState.DISCONNECTED\n        raise WebSocketConnectionError(\n            f\"Failed to accept WebSocket connection: {e}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.close","title":"close  <code>async</code>","text":"<pre><code>close(code: int = 1000, reason: str = '') -&gt; None\n</code></pre> <p>Close the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>WebSocket close code (default: 1000 for normal closure)</p> <code>1000</code> <code>reason</code> <code>str</code> <p>Optional reason for closing</p> <code>''</code> Source code in <code>serv/websocket.py</code> <pre><code>async def close(self, code: int = 1000, reason: str = \"\") -&gt; None:\n    \"\"\"Close the WebSocket connection.\n\n    Args:\n        code: WebSocket close code (default: 1000 for normal closure)\n        reason: Optional reason for closing\n    \"\"\"\n    if self._closed:\n        return\n\n    try:\n        await self._send(\n            {\"type\": \"websocket.close\", \"code\": code, \"reason\": reason}\n        )\n    except Exception as e:\n        logger.warning(f\"Error sending WebSocket close message: {e}\")\n    finally:\n        self._closed = True\n        self.state = WebSocketState.DISCONNECTED\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.receive","title":"receive  <code>async</code>","text":"<pre><code>receive() -&gt; str | bytes\n</code></pre> <p>Receive a single message from the WebSocket connection.</p> <p>Returns:</p> Type Description <code>str | bytes</code> <p>The received message as str (text) or bytes (binary)</p> <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection is lost or receives disconnect</p> Source code in <code>serv/websocket.py</code> <pre><code>async def receive(self) -&gt; str | bytes:\n    \"\"\"Receive a single message from the WebSocket connection.\n\n    Returns:\n        The received message as str (text) or bytes (binary)\n\n    Raises:\n        WebSocketConnectionError: If connection is lost or receives disconnect\n    \"\"\"\n    if not self.is_connected:\n        raise WebSocketConnectionError(\"WebSocket connection is not active\")\n\n    try:\n        message = await self._receive()\n\n        if message[\"type\"] == \"websocket.receive\":\n            if \"text\" in message:\n                return message[\"text\"]\n            elif \"bytes\" in message:\n                return message[\"bytes\"]\n            else:\n                raise WebSocketConnectionError(\"Received empty WebSocket message\")\n\n        elif message[\"type\"] == \"websocket.disconnect\":\n            code = message.get(\"code\", 1000)\n            reason = message.get(\"reason\", \"\")\n            self._closed = True\n            self.state = WebSocketState.DISCONNECTED\n            raise WebSocketConnectionError(\n                f\"WebSocket disconnected: {code} {reason}\"\n            )\n\n        else:\n            raise WebSocketConnectionError(\n                f\"Unexpected WebSocket message type: {message['type']}\"\n            )\n\n    except Exception as e:\n        if not isinstance(e, WebSocketConnectionError):\n            self._closed = True\n            self.state = WebSocketState.DISCONNECTED\n            raise WebSocketConnectionError(\n                f\"Error receiving WebSocket message: {e}\"\n            ) from e\n        raise\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.receive_bytes","title":"receive_bytes  <code>async</code>","text":"<pre><code>receive_bytes() -&gt; bytes\n</code></pre> <p>Receive a binary message from the WebSocket connection.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The received binary message</p> <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection is lost</p> <code>TypeError</code> <p>If received message is not binary</p> Source code in <code>serv/websocket.py</code> <pre><code>async def receive_bytes(self) -&gt; bytes:\n    \"\"\"Receive a binary message from the WebSocket connection.\n\n    Returns:\n        The received binary message\n\n    Raises:\n        WebSocketConnectionError: If connection is lost\n        TypeError: If received message is not binary\n    \"\"\"\n    message = await self.receive()\n    if not isinstance(message, bytes):\n        raise TypeError(f\"Expected binary message, got {type(message)}\")\n    return message\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.receive_json","title":"receive_json  <code>async</code>","text":"<pre><code>receive_json() -&gt; Any\n</code></pre> <p>Receive and parse a JSON message from the WebSocket connection.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The parsed JSON data</p> <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection is lost</p> <code>JSONDecodeError</code> <p>If message is not valid JSON</p> Source code in <code>serv/websocket.py</code> <pre><code>async def receive_json(self) -&gt; Any:\n    \"\"\"Receive and parse a JSON message from the WebSocket connection.\n\n    Returns:\n        The parsed JSON data\n\n    Raises:\n        WebSocketConnectionError: If connection is lost\n        json.JSONDecodeError: If message is not valid JSON\n    \"\"\"\n    text = await self.receive_text()\n    return json.loads(text)\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.receive_text","title":"receive_text  <code>async</code>","text":"<pre><code>receive_text() -&gt; str\n</code></pre> <p>Receive a text message from the WebSocket connection.</p> <p>Returns:</p> Type Description <code>str</code> <p>The received text message</p> <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection is lost</p> <code>TypeError</code> <p>If received message is not text</p> Source code in <code>serv/websocket.py</code> <pre><code>async def receive_text(self) -&gt; str:\n    \"\"\"Receive a text message from the WebSocket connection.\n\n    Returns:\n        The received text message\n\n    Raises:\n        WebSocketConnectionError: If connection is lost\n        TypeError: If received message is not text\n    \"\"\"\n    message = await self.receive()\n    if not isinstance(message, str):\n        raise TypeError(f\"Expected text message, got {type(message)}\")\n    return message\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.send","title":"send  <code>async</code>","text":"<pre><code>send(data: str | bytes) -&gt; None\n</code></pre> <p>Send a message over the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | bytes</code> <p>Message data to send (str for text, bytes for binary)</p> required <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection is not active</p> <code>TypeError</code> <p>If data type doesn't match expected frame type</p> Source code in <code>serv/websocket.py</code> <pre><code>async def send(self, data: str | bytes) -&gt; None:\n    \"\"\"Send a message over the WebSocket connection.\n\n    Args:\n        data: Message data to send (str for text, bytes for binary)\n\n    Raises:\n        WebSocketConnectionError: If connection is not active\n        TypeError: If data type doesn't match expected frame type\n    \"\"\"\n    if not self.is_connected:\n        raise WebSocketConnectionError(\"WebSocket connection is not active\")\n\n    # Determine message type based on data type and frame preference\n    if isinstance(data, str):\n        message_type = \"websocket.send\"\n        message = {\"type\": message_type, \"text\": data}\n    elif isinstance(data, bytes):\n        message_type = \"websocket.send\"\n        message = {\"type\": message_type, \"bytes\": data}\n    else:\n        raise TypeError(f\"WebSocket data must be str or bytes, got {type(data)}\")\n\n    try:\n        await self._send(message)\n        logger.debug(f\"Sent WebSocket message: {len(data)} chars/bytes\")\n    except Exception as e:\n        raise WebSocketConnectionError(\n            f\"Failed to send WebSocket message: {e}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.send_bytes","title":"send_bytes  <code>async</code>","text":"<pre><code>send_bytes(data: bytes) -&gt; None\n</code></pre> <p>Send a binary message over the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Binary data to send</p> required Source code in <code>serv/websocket.py</code> <pre><code>async def send_bytes(self, data: bytes) -&gt; None:\n    \"\"\"Send a binary message over the WebSocket connection.\n\n    Args:\n        data: Binary data to send\n    \"\"\"\n    await self.send(data)\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.send_json","title":"send_json  <code>async</code>","text":"<pre><code>send_json(data: Any) -&gt; None\n</code></pre> <p>Send a JSON message over the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to serialize as JSON and send</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If data is not JSON serializable</p> Source code in <code>serv/websocket.py</code> <pre><code>async def send_json(self, data: Any) -&gt; None:\n    \"\"\"Send a JSON message over the WebSocket connection.\n\n    Args:\n        data: Data to serialize as JSON and send\n\n    Raises:\n        TypeError: If data is not JSON serializable\n    \"\"\"\n    try:\n        json_str = json.dumps(data)\n        await self.send_text(json_str)\n    except (TypeError, ValueError) as e:\n        raise TypeError(f\"Data is not JSON serializable: {e}\") from e\n</code></pre>"},{"location":"reference/serv/#serv.WebSocket.send_text","title":"send_text  <code>async</code>","text":"<pre><code>send_text(data: str) -&gt; None\n</code></pre> <p>Send a text message over the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Text message to send</p> required Source code in <code>serv/websocket.py</code> <pre><code>async def send_text(self, data: str) -&gt; None:\n    \"\"\"Send a text message over the WebSocket connection.\n\n    Args:\n        data: Text message to send\n    \"\"\"\n    await self.send(data)\n</code></pre>"},{"location":"reference/serv/#serv.create_test_app_client","title":"create_test_app_client  <code>async</code>","text":"<pre><code>create_test_app_client(\n    config_path: Path | str,\n    *,\n    app_module_str: str | None = None,\n    extension_dirs: str | None = None,\n    dev: bool = False,\n    host: str = \"127.0.0.1\",\n    port: int = 8000,\n    reload: bool = False,\n    no_reload: bool = False,\n    workers: int = 1,\n    factory: bool = False,\n    dry_run: bool = False,\n    base_url: str = \"http://testserver\",\n    use_lifespan: bool = True,\n    timeout: float = 5.0,\n) -&gt; AsyncGenerator[AsyncClient]\n</code></pre> <p>Create a test client that wraps a Serv app in an httpx AsyncClient.</p> <p>This function creates an App instance using the same configuration options as the CLI's 'serv launch' command, then wraps it in an httpx AsyncClient for testing without needing to start a server.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path | str</code> <p>Path to the config file to use (equivalent to --config)</p> required <code>app_module_str</code> <code>str | None</code> <p>Custom application class in format \"module.path:ClassName\" (equivalent to --app)</p> <code>None</code> <code>extension_dirs</code> <code>str | None</code> <p>Directory to search for extensions (equivalent to --extension-dirs)</p> <code>None</code> <code>dev</code> <code>bool</code> <p>Enable development mode (equivalent to --dev)</p> <code>False</code> <code>host</code> <code>str</code> <p>Host binding (equivalent to --host, used only for dry_run info)</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>Port binding (equivalent to --port, used only for dry_run info)</p> <code>8000</code> <code>reload</code> <code>bool</code> <p>Enable auto-reload (equivalent to --reload, used only for dry_run info)</p> <code>False</code> <code>no_reload</code> <code>bool</code> <p>Disable auto-reload (equivalent to --no-reload, used only for dry_run info)</p> <code>False</code> <code>workers</code> <code>int</code> <p>Number of workers (equivalent to --workers, used only for dry_run info)</p> <code>1</code> <code>factory</code> <code>bool</code> <p>Treat app_module_str as factory (equivalent to --factory, used only for dry_run info)</p> <code>False</code> <code>dry_run</code> <code>bool</code> <p>If True, just create app but don't return client (equivalent to --dry-run)</p> <code>False</code> <code>base_url</code> <code>str</code> <p>Base URL for test requests</p> <code>'http://testserver'</code> <code>use_lifespan</code> <code>bool</code> <p>Whether to handle app lifespan events</p> <code>True</code> <code>timeout</code> <code>float</code> <p>Request timeout in seconds</p> <code>5.0</code> <p>Returns:</p> Type Description <code>AsyncGenerator[AsyncClient]</code> <p>An AsyncClient configured to communicate with the app</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If app creation fails</p> <p>Examples:</p> <p>Basic usage: <pre><code>from pathlib import Path\nfrom serv import create_test_app_client\n\nasync with create_test_app_client(Path(\"serv.config.yaml\")) as client:\n    response = await client.get(\"/\")\n    assert response.status_code == 200\n</code></pre></p> <p>With development mode: <pre><code>async with create_test_app_client(\n    Path(\"serv.config.yaml\"),\n    dev=True\n) as client:\n    response = await client.get(\"/debug\")\n    assert response.status_code == 200\n</code></pre></p> <p>With custom extension directory: <pre><code>async with create_test_app_client(\n    Path(\"serv.config.yaml\"),\n    extension_dirs=\"./custom_extensions\"\n) as client:\n    response = await client.get(\"/custom-endpoint\")\n    assert response.status_code == 200\n</code></pre></p> <p>Testing a specific endpoint: <pre><code>async def test_api_endpoint():\n    async with create_test_app_client(Path(\"test.config.yaml\")) as client:\n        # Test POST request\n        response = await client.post(\"/api/users\", json={\"name\": \"Test User\"})\n        assert response.status_code == 201\n\n        # Test GET request\n        response = await client.get(\"/api/users/1\")\n        assert response.status_code == 200\n        user = response.json()\n        assert user[\"name\"] == \"Test User\"\n</code></pre></p> Source code in <code>serv/test_client.py</code> <pre><code>@asynccontextmanager\nasync def create_test_app_client(\n    config_path: Path | str,\n    *,\n    app_module_str: str | None = None,\n    extension_dirs: str | None = None,\n    dev: bool = False,\n    host: str = \"127.0.0.1\",\n    port: int = 8000,\n    reload: bool = False,\n    no_reload: bool = False,\n    workers: int = 1,\n    factory: bool = False,\n    dry_run: bool = False,\n    base_url: str = \"http://testserver\",\n    use_lifespan: bool = True,\n    timeout: float = 5.0,\n) -&gt; AsyncGenerator[AsyncClient]:\n    \"\"\"\n    Create a test client that wraps a Serv app in an httpx AsyncClient.\n\n    This function creates an App instance using the same configuration options\n    as the CLI's 'serv launch' command, then wraps it in an httpx AsyncClient\n    for testing without needing to start a server.\n\n    Args:\n        config_path: Path to the config file to use (equivalent to --config)\n        app_module_str: Custom application class in format \"module.path:ClassName\" (equivalent to --app)\n        extension_dirs: Directory to search for extensions (equivalent to --extension-dirs)\n        dev: Enable development mode (equivalent to --dev)\n        host: Host binding (equivalent to --host, used only for dry_run info)\n        port: Port binding (equivalent to --port, used only for dry_run info)\n        reload: Enable auto-reload (equivalent to --reload, used only for dry_run info)\n        no_reload: Disable auto-reload (equivalent to --no-reload, used only for dry_run info)\n        workers: Number of workers (equivalent to --workers, used only for dry_run info)\n        factory: Treat app_module_str as factory (equivalent to --factory, used only for dry_run info)\n        dry_run: If True, just create app but don't return client (equivalent to --dry-run)\n        base_url: Base URL for test requests\n        use_lifespan: Whether to handle app lifespan events\n        timeout: Request timeout in seconds\n\n    Returns:\n        An AsyncClient configured to communicate with the app\n\n    Raises:\n        Exception: If app creation fails\n\n    Examples:\n        Basic usage:\n        ```python\n        from pathlib import Path\n        from serv import create_test_app_client\n\n        async with create_test_app_client(Path(\"serv.config.yaml\")) as client:\n            response = await client.get(\"/\")\n            assert response.status_code == 200\n        ```\n\n        With development mode:\n        ```python\n        async with create_test_app_client(\n            Path(\"serv.config.yaml\"),\n            dev=True\n        ) as client:\n            response = await client.get(\"/debug\")\n            assert response.status_code == 200\n        ```\n\n        With custom extension directory:\n        ```python\n        async with create_test_app_client(\n            Path(\"serv.config.yaml\"),\n            extension_dirs=\"./custom_extensions\"\n        ) as client:\n            response = await client.get(\"/custom-endpoint\")\n            assert response.status_code == 200\n        ```\n\n        Testing a specific endpoint:\n        ```python\n        async def test_api_endpoint():\n            async with create_test_app_client(Path(\"test.config.yaml\")) as client:\n                # Test POST request\n                response = await client.post(\"/api/users\", json={\"name\": \"Test User\"})\n                assert response.status_code == 201\n\n                # Test GET request\n                response = await client.get(\"/api/users/1\")\n                assert response.status_code == 200\n                user = response.json()\n                assert user[\"name\"] == \"Test User\"\n        ```\n    \"\"\"\n    if not Path(config_path).exists():\n        raise FileNotFoundError(f\"Config file not found: {config_path}\")\n\n    # Convert Path to string if needed\n    config_str = str(config_path) if isinstance(config_path, Path) else config_path\n\n    # Create the app using the same logic as the CLI\n    app = create_app(\n        app_module_str=app_module_str,\n        config=config_str,\n        extension_dirs=extension_dirs,\n        dev=dev,\n    )\n\n    # Handle dry run mode\n    if dry_run:\n        print(\"=== Dry Run Mode ===\")\n        print(\"Application loaded successfully. Server would start with:\")\n        print(f\"  Host: {host}\")\n        print(f\"  Port: {port}\")\n        print(f\"  Dev Mode: {dev}\")\n        if dev:\n            reload_enabled = not no_reload\n            print(f\"  Reload: {reload_enabled}\")\n        else:\n            print(f\"  Reload: {reload}\")\n        print(f\"  Workers: {workers}\")\n        # For dry run, we don't yield a client\n        yield None\n        return\n\n    # Set up the transport for the client\n    transport = ASGITransport(app=app)\n\n    # Use the app's lifespan if requested\n    if use_lifespan:\n        lifespan_mgr = LifespanManager(app)\n        async with lifespan_mgr.lifespan():\n            async with AsyncClient(\n                transport=transport, base_url=base_url, timeout=timeout\n            ) as client:\n                yield client\n    else:\n        async with AsyncClient(\n            transport=transport, base_url=base_url, timeout=timeout\n        ) as client:\n            yield client\n</code></pre>"},{"location":"reference/serv/_app/","title":"_app","text":""},{"location":"reference/serv/_app/#serv._app","title":"serv._app","text":""},{"location":"reference/serv/_app/#serv._app.App","title":"App","text":"<pre><code>App(\n    *,\n    config: str = \"./serv.config.yaml\",\n    extension_dir: str = \"./extensions\",\n    dev_mode: bool = False,\n)\n</code></pre> <p>               Bases: <code>EventEmitterProtocol</code>, <code>AppContextProtocol</code></p> <p>The main ASGI application class for Serv web framework.</p> <p>This class serves as the central orchestrator for your web application, handling incoming HTTP requests, managing extensions, middleware, routing, and dependency injection. It implements the ASGI (Asynchronous Server Gateway Interface) specification.</p> <p>The App class provides: - Extension system for extensible functionality - Middleware stack for request/response processing - Dependency injection container - Error handling and custom error pages - Template rendering capabilities - Event emission system for extension communication</p> <p>Examples:</p> <p>Basic application setup:</p> <pre><code>from serv import App\n\n# Create a basic app\napp = App()\n\n# Create app with custom config\napp = App(config=\"./config/production.yaml\")\n\n# Create app with custom extension directory\napp = App(extension_dir=\"./my_extensions\")\n\n# Development mode with enhanced debugging\napp = App(dev_mode=True)\n</code></pre> <p>Using with ASGI servers:</p> <pre><code># For uvicorn\n# uvicorn main:app --reload\n\n# For gunicorn\n# gunicorn main:app -k uvicorn.workers.UvicornWorker\n</code></pre> <p>Advanced configuration:</p> <pre><code>app = App(\n    config=\"./config/production.yaml\",\n    extension_dir=\"./extensions\",\n    dev_mode=False\n)\n\n# Add custom error handler\nasync def custom_404_handler(error):\n    # Handle 404 errors\n    pass\n\napp.add_error_handler(HTTPNotFoundException, custom_404_handler)\n\n# Add middleware\nasync def logging_middleware():\n    # Middleware logic\n    yield\n\napp.add_middleware(logging_middleware)\n</code></pre> <p>Initialize a new Serv application instance.</p> <p>Creates and configures a new ASGI application with the specified settings. This includes setting up the dependency injection container, loading extensions, configuring middleware, and preparing the routing system.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>Path to the YAML configuration file. The config file defines site information, enabled extensions, middleware stack, and other application settings. Defaults to \"./serv.config.yaml\".</p> <code>'./serv.config.yaml'</code> <code>extension_dir</code> <code>str</code> <p>Directory path where extensions are located. Extensions in this directory will be available for loading. Defaults to \"./extensions\".</p> <code>'./extensions'</code> <code>extension_dir</code> <code>str</code> <p>Legacy parameter name for extension_dir (backward compatibility).</p> <code>'./extensions'</code> <code>dev_mode</code> <code>bool</code> <p>Enable development mode features including enhanced error reporting, debug logging, and development-specific behaviors. Should be False in production. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ServConfigError</code> <p>If the configuration file cannot be loaded or contains invalid YAML/configuration structure.</p> <code>ImportError</code> <p>If required dependencies for extensions cannot be imported.</p> <code>ValueError</code> <p>If extension_dir path is invalid or inaccessible.</p> <p>Examples:</p> <p>Basic initialization:</p> <pre><code># Use default settings\napp = App()\n\n# Custom config file\napp = App(config=\"config/production.yaml\")\n\n# Custom extension directory\napp = App(extension_dir=\"src/extensions\")\n\n# Development mode\napp = App(dev_mode=True)\n</code></pre> <p>Production setup:</p> <pre><code>app = App(\n    config=\"/etc/myapp/config.yaml\",\n    extension_dir=\"/opt/myapp/extensions\",\n    dev_mode=False\n)\n</code></pre> <p>Development setup:</p> <pre><code>app = App(\n    config=\"dev.config.yaml\",\n    extension_dir=\"./dev_extensions\",\n    dev_mode=True\n)\n</code></pre> Note <p>The application will automatically load the welcome extension if no other extensions are configured, providing a default landing page for new projects.</p> Source code in <code>serv/_app.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: str = \"./serv.config.yaml\",\n    extension_dir: str = \"./extensions\",\n    dev_mode: bool = False,\n):\n    \"\"\"Initialize a new Serv application instance.\n\n    Creates and configures a new ASGI application with the specified settings.\n    This includes setting up the dependency injection container, loading extensions,\n    configuring middleware, and preparing the routing system.\n\n    Args:\n        config: Path to the YAML configuration file. The config file defines\n            site information, enabled extensions, middleware stack, and other\n            application settings. Defaults to \"./serv.config.yaml\".\n        extension_dir: Directory path where extensions are located. Extensions in this\n            directory will be available for loading. Defaults to \"./extensions\".\n        extension_dir: Legacy parameter name for extension_dir (backward compatibility).\n        dev_mode: Enable development mode features including enhanced error\n            reporting, debug logging, and development-specific behaviors.\n            Should be False in production. Defaults to False.\n\n    Raises:\n        ServConfigError: If the configuration file cannot be loaded or contains\n            invalid YAML/configuration structure.\n        ImportError: If required dependencies for extensions cannot be imported.\n        ValueError: If extension_dir path is invalid or inaccessible.\n\n    Examples:\n        Basic initialization:\n\n        ```python\n        # Use default settings\n        app = App()\n\n        # Custom config file\n        app = App(config=\"config/production.yaml\")\n\n        # Custom extension directory\n        app = App(extension_dir=\"src/extensions\")\n\n        # Development mode\n        app = App(dev_mode=True)\n        ```\n\n        Production setup:\n\n        ```python\n        app = App(\n            config=\"/etc/myapp/config.yaml\",\n            extension_dir=\"/opt/myapp/extensions\",\n            dev_mode=False\n        )\n        ```\n\n        Development setup:\n\n        ```python\n        app = App(\n            config=\"dev.config.yaml\",\n            extension_dir=\"./dev_extensions\",\n            dev_mode=True\n        )\n        ```\n\n    Note:\n        The application will automatically load the welcome extension if no other\n        extensions are configured, providing a default landing page for new projects.\n    \"\"\"\n    self._config = self._load_config(config)\n    self._dev_mode = dev_mode\n    self._registry = get_registry()\n    self._container = self._registry.create_container()\n    self._async_exit_stack = contextlib.AsyncExitStack()\n    self._error_handlers: dict[\n        type[Exception], Callable[[Exception], Awaitable[None]]\n    ] = {}\n    self._middleware = []\n\n    # Handle backward compatibility for extension_dir parameter\n    actual_extension_dir = extension_dir if extension_dir is None else extension_dir\n    self._extension_loader = Importer(actual_extension_dir)\n    self._extensions: dict[Path, list[Listener]] = defaultdict(list)\n\n    # Initialize the extension loader\n    self._extension_loader_instance = ExtensionLoader(self, self._extension_loader)\n\n    self._emit = EventEmitter(self._extensions)\n\n    # Initialize database manager\n    self._database_manager = DatabaseManager(self._config, self._container)\n\n    self._init_container()\n    self._register_default_error_handlers()\n    self._init_extensions(\n        self._config.get(\"extensions\", self._config.get(\"extensions\", []))\n    )\n</code></pre>"},{"location":"reference/serv/_app/#serv._app.App.dev_mode","title":"dev_mode  <code>property</code> <code>writable</code>","text":"<pre><code>dev_mode: bool\n</code></pre> <p>Get the current development mode setting.</p>"},{"location":"reference/serv/_app/#serv._app.App.add_error_handler","title":"add_error_handler","text":"<pre><code>add_error_handler(\n    error_type: type[Exception],\n    handler: Callable[[Exception], Awaitable[None]],\n)\n</code></pre> <p>Register a custom error handler for specific exception types.</p> <p>Error handlers allow you to customize how your application responds to different types of errors, providing custom error pages, logging, or recovery mechanisms.</p> <p>Parameters:</p> Name Type Description Default <code>error_type</code> <code>type[Exception]</code> <p>The exception class to handle. The handler will be called for this exception type and any of its subclasses.</p> required <code>handler</code> <code>Callable[[Exception], Awaitable[None]]</code> <p>An async function that will be called when the exception occurs. The handler receives the exception instance and can use dependency injection to access request/response objects.</p> required <p>Examples:</p> <p>Handle 404 errors with a custom page:</p> <pre><code>from serv.exceptions import HTTPNotFoundException\nfrom serv.responses import ResponseBuilder\nfrom bevy import injectable, Inject\n\n@injectable\nasync def custom_404_handler(\n    error: HTTPNotFoundException,\n    response: Inject[ResponseBuilder]\n):\n    response.set_status(404)\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;Page Not Found&lt;/h1&gt;&lt;p&gt;Sorry, that page doesn't exist.&lt;/p&gt;\")\n\napp.add_error_handler(HTTPNotFoundException, custom_404_handler)\n</code></pre> <p>Handle validation errors:</p> <pre><code>class ValidationError(Exception):\n    def __init__(self, message: str, field: str):\n        self.message = message\n        self.field = field\n\n@injectable\nasync def validation_error_handler(\n    error: ValidationError,\n    response: Inject[ResponseBuilder]\n):\n    response.set_status(400)\n    response.content_type(\"application/json\")\n    response.body({\n        \"error\": \"validation_failed\",\n        \"message\": error.message,\n        \"field\": error.field\n    })\n\napp.add_error_handler(ValidationError, validation_error_handler)\n</code></pre> <p>Generic error handler with logging:</p> <pre><code>import logging\n\n@injectable\nasync def generic_error_handler(\n    error: Exception,\n    response: Inject[ResponseBuilder],\n    request: Inject[Request]\n):\n    logging.error(f\"Unhandled error on {request.path}: {error}\")\n    response.set_status(500)\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;Internal Server Error&lt;/h1&gt;\")\n\napp.add_error_handler(Exception, generic_error_handler)\n</code></pre> Source code in <code>serv/_app.py</code> <pre><code>def add_error_handler(\n    self,\n    error_type: type[Exception],\n    handler: Callable[[Exception], Awaitable[None]],\n):\n    \"\"\"Register a custom error handler for specific exception types.\n\n    Error handlers allow you to customize how your application responds to\n    different types of errors, providing custom error pages, logging, or\n    recovery mechanisms.\n\n    Args:\n        error_type: The exception class to handle. The handler will be called\n            for this exception type and any of its subclasses.\n        handler: An async function that will be called when the exception occurs.\n            The handler receives the exception instance and can use dependency\n            injection to access request/response objects.\n\n    Examples:\n        Handle 404 errors with a custom page:\n\n        ```python\n        from serv.exceptions import HTTPNotFoundException\n        from serv.responses import ResponseBuilder\n        from bevy import injectable, Inject\n\n        @injectable\n        async def custom_404_handler(\n            error: HTTPNotFoundException,\n            response: Inject[ResponseBuilder]\n        ):\n            response.set_status(404)\n            response.content_type(\"text/html\")\n            response.body(\"&lt;h1&gt;Page Not Found&lt;/h1&gt;&lt;p&gt;Sorry, that page doesn't exist.&lt;/p&gt;\")\n\n        app.add_error_handler(HTTPNotFoundException, custom_404_handler)\n        ```\n\n        Handle validation errors:\n\n        ```python\n        class ValidationError(Exception):\n            def __init__(self, message: str, field: str):\n                self.message = message\n                self.field = field\n\n        @injectable\n        async def validation_error_handler(\n            error: ValidationError,\n            response: Inject[ResponseBuilder]\n        ):\n            response.set_status(400)\n            response.content_type(\"application/json\")\n            response.body({\n                \"error\": \"validation_failed\",\n                \"message\": error.message,\n                \"field\": error.field\n            })\n\n        app.add_error_handler(ValidationError, validation_error_handler)\n        ```\n\n        Generic error handler with logging:\n\n        ```python\n        import logging\n\n        @injectable\n        async def generic_error_handler(\n            error: Exception,\n            response: Inject[ResponseBuilder],\n            request: Inject[Request]\n        ):\n            logging.error(f\"Unhandled error on {request.path}: {error}\")\n            response.set_status(500)\n            response.content_type(\"text/html\")\n            response.body(\"&lt;h1&gt;Internal Server Error&lt;/h1&gt;\")\n\n        app.add_error_handler(Exception, generic_error_handler)\n        ```\n    \"\"\"\n    self._error_handlers[error_type] = handler\n</code></pre>"},{"location":"reference/serv/_app/#serv._app.App.add_middleware","title":"add_middleware","text":"<pre><code>add_middleware(\n    middleware: Callable[[], AsyncIterator[None]],\n)\n</code></pre> <p>Add middleware to the application's middleware stack.</p> <p>Middleware functions are executed in the order they are added, wrapping around the request handling process. They can modify requests, responses, add headers, implement authentication, logging, and more.</p> <p>Parameters:</p> Name Type Description Default <code>middleware</code> <code>Callable[[], AsyncIterator[None]]</code> <p>An async generator function that yields control to the next middleware or route handler. The function should yield exactly once.</p> required <p>Examples:</p> <p>Basic logging middleware:</p> <pre><code>import logging\nfrom serv.requests import Request\nfrom bevy import injectable, Inject\n\n@injectable\nasync def logging_middleware(\n    request: Inject[Request]\n):\n    logging.info(f\"Request: {request.method} {request.path}\")\n    start_time = time.time()\n\n    yield  # Pass control to next middleware/handler\n\n    duration = time.time() - start_time\n    logging.info(f\"Response time: {duration:.3f}s\")\n\napp.add_middleware(logging_middleware)\n</code></pre> <p>Authentication middleware:</p> <pre><code>from serv.responses import ResponseBuilder\nfrom serv.requests import Request\nfrom bevy import injectable, Inject\n\n@injectable\nasync def auth_middleware(\n    request: Inject[Request],\n    response: Inject[ResponseBuilder]\n):\n    # Check for authentication\n    auth_header = request.headers.get(\"authorization\")\n    if not auth_header and request.path.startswith(\"/api/\"):\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body({\"error\": \"Authentication required\"})\n        return  # Don't yield, stop processing\n\n    yield  # Continue to next middleware/handler\n\napp.add_middleware(auth_middleware)\n</code></pre> <p>CORS middleware:</p> <pre><code>@injectable\nasync def cors_middleware(\n    request: Inject[Request],\n    response: Inject[ResponseBuilder]\n):\n    # Add CORS headers\n    response.add_header(\"Access-Control-Allow-Origin\", \"*\")\n    response.add_header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n    response.add_header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\n    # Handle preflight requests\n    if request.method == \"OPTIONS\":\n        response.set_status(200)\n        return\n\n    yield  # Continue processing\n\napp.add_middleware(cors_middleware)\n</code></pre> Note <p>Middleware is executed in LIFO (Last In, First Out) order during request processing, and FIFO (First In, First Out) order during response processing.</p> Source code in <code>serv/_app.py</code> <pre><code>def add_middleware(self, middleware: Callable[[], AsyncIterator[None]]):\n    \"\"\"Add middleware to the application's middleware stack.\n\n    Middleware functions are executed in the order they are added, wrapping\n    around the request handling process. They can modify requests, responses,\n    add headers, implement authentication, logging, and more.\n\n    Args:\n        middleware: An async generator function that yields control to the next\n            middleware or route handler. The function should yield exactly once.\n\n    Examples:\n        Basic logging middleware:\n\n        ```python\n        import logging\n        from serv.requests import Request\n        from bevy import injectable, Inject\n\n        @injectable\n        async def logging_middleware(\n            request: Inject[Request]\n        ):\n            logging.info(f\"Request: {request.method} {request.path}\")\n            start_time = time.time()\n\n            yield  # Pass control to next middleware/handler\n\n            duration = time.time() - start_time\n            logging.info(f\"Response time: {duration:.3f}s\")\n\n        app.add_middleware(logging_middleware)\n        ```\n\n        Authentication middleware:\n\n        ```python\n        from serv.responses import ResponseBuilder\n        from serv.requests import Request\n        from bevy import injectable, Inject\n\n        @injectable\n        async def auth_middleware(\n            request: Inject[Request],\n            response: Inject[ResponseBuilder]\n        ):\n            # Check for authentication\n            auth_header = request.headers.get(\"authorization\")\n            if not auth_header and request.path.startswith(\"/api/\"):\n                response.set_status(401)\n                response.content_type(\"application/json\")\n                response.body({\"error\": \"Authentication required\"})\n                return  # Don't yield, stop processing\n\n            yield  # Continue to next middleware/handler\n\n        app.add_middleware(auth_middleware)\n        ```\n\n        CORS middleware:\n\n        ```python\n        @injectable\n        async def cors_middleware(\n            request: Inject[Request],\n            response: Inject[ResponseBuilder]\n        ):\n            # Add CORS headers\n            response.add_header(\"Access-Control-Allow-Origin\", \"*\")\n            response.add_header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n            response.add_header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\n            # Handle preflight requests\n            if request.method == \"OPTIONS\":\n                response.set_status(200)\n                return\n\n            yield  # Continue processing\n\n        app.add_middleware(cors_middleware)\n        ```\n\n    Note:\n        Middleware is executed in LIFO (Last In, First Out) order during request\n        processing, and FIFO (First In, First Out) order during response processing.\n    \"\"\"\n    self._middleware.append(middleware)\n</code></pre>"},{"location":"reference/serv/_app/#serv._app.App.emit","title":"emit  <code>async</code>","text":"<pre><code>emit(\n    event: str, *, container: Inject[Container], **kwargs\n) -&gt; None\n</code></pre> <p>Async emit method for EventEmitterProtocol compliance.</p> Source code in <code>serv/_app.py</code> <pre><code>@injectable\nasync def emit(self, event: str, *, container: Inject[Container], **kwargs) -&gt; None:\n    \"\"\"Async emit method for EventEmitterProtocol compliance.\"\"\"\n    await self._emit.emit(event, container=container, **kwargs)\n</code></pre>"},{"location":"reference/serv/_app/#serv._app.App.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(callback: Callable[[], Awaitable[None]])\n</code></pre> <p>Add a callback to be called when the application is shutting down.</p> Source code in <code>serv/_app.py</code> <pre><code>def on_shutdown(self, callback: Callable[[], Awaitable[None]]):\n    \"\"\"Add a callback to be called when the application is shutting down.\"\"\"\n    self._async_exit_stack.push_async_callback(callback)\n</code></pre>"},{"location":"reference/serv/_app/#serv._app.EventEmitter","title":"EventEmitter","text":"<pre><code>EventEmitter(extensions: dict[Path, list[Listener]])\n</code></pre> <p>Event emission system for extension communication.</p> <p>The EventEmitter manages the broadcasting of events to all registered listeners in the application. It provides both synchronous and asynchronous event emission capabilities, allowing listeners to respond to application lifecycle events and custom events.</p> <p>Examples:</p> <p>Basic event emission:</p> <pre><code># Emit an event to all listeners\nawait app.emit(\"user_created\", user_id=123, email=\"user@example.com\")\n\n# Emit from within a route handler\ntask = app.emit(\"order_processed\", order_id=456)\n</code></pre> <p>Listener responding to events:</p> <pre><code>class NotificationListener(Listener):\n    async def on_user_created(self, user_id: int, email: str):\n        await self.send_welcome_email(email)\n\n    async def on_order_processed(self, order_id: int):\n        await self.update_inventory(order_id)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>dict[Path, list[Listener]]</code> <p>Dictionary mapping extension paths to lists of listener instances.</p> required Source code in <code>serv/_app.py</code> <pre><code>def __init__(self, extensions: dict[Path, list[Listener]]):\n    self.extensions = extensions\n</code></pre>"},{"location":"reference/serv/_routing/","title":"_routing","text":""},{"location":"reference/serv/_routing/#serv._routing","title":"serv._routing","text":"<p>Legacy routing exports for backward compatibility.</p> <p>All routing functionality has been moved to serv.routing.router. This module provides re-exports for backward compatibility.</p>"},{"location":"reference/serv/_routing/#serv._routing.HTTPNotFoundException","title":"HTTPNotFoundException","text":"<pre><code>HTTPNotFoundException(message: str | None = None, *args)\n</code></pre> <p>               Bases: <code>ServException</code></p> <p>Raised when a requested route or resource is not found (HTTP 404).</p> <p>This exception is automatically raised by the router when no matching route is found for the requested path. It can also be raised manually in route handlers when a specific resource is not found.</p> <p>Examples:</p> <p>Automatic usage by router:</p> <pre><code># GET /nonexistent-path -&gt; HTTPNotFoundException\n</code></pre> <p>Manual usage in route handlers:</p> <pre><code>from serv.routes import Route, GetRequest\nfrom serv.exceptions import HTTPNotFoundException\n\nclass UserRoute(Route):\n    async def handle_get(self, request: GetRequest):\n        user_id = request.path_params.get(\"id\")\n        user = await self.get_user(user_id)\n        if not user:\n            raise HTTPNotFoundException(f\"User {user_id} not found\")\n        return user\n</code></pre> Source code in <code>serv/exceptions.py</code> <pre><code>def __init__(self, message: str | None = None, *args):\n    super().__init__(message, *args)  # Pass message to parent Exception\n    # Set self.message: use provided message, or if None, try to use the first arg (if any)\n    # or fall back to a default string representation of the class name.\n    if message is not None:\n        self.message = message\n    elif args and args[0]:  # If message is None but other args are present\n        self.message = str(args[0])\n    else:  # Fallback if no message-like argument is provided\n        self.message = self.__class__.__name__\n</code></pre>"},{"location":"reference/serv/_routing/#serv._routing.Router","title":"Router","text":"<pre><code>Router(settings: dict[str, Any] = None)\n</code></pre> <p>               Bases: <code>RouterProtocol</code></p> <p>HTTP request router for mapping URLs to handlers.</p> <p>The Router class is responsible for matching incoming HTTP requests to the appropriate handler functions or Route classes. It supports path parameters, HTTP method filtering, route mounting, and URL generation.</p> <p>Features: - Path parameter extraction (e.g., <code>/users/{id}</code>) - HTTP method-specific routing - Route mounting and sub-routers - URL generation with <code>url_for()</code> - Route settings and metadata - Flexible handler types (functions, Route classes) - WebSocket route support</p> <p>Examples:</p> <p>Basic router setup:</p> <pre><code>from serv.routing.router import Router\n\nrouter = Router()\n\n# Add function-based routes\nasync def get_users():\n    return {\"users\": []}\n\nrouter.add_route(\"/users\", get_users, [\"GET\"])\n\n# Add Route class\nclass UserRoute:\n    async def handle_get(self, request):\n        return {\"user\": \"data\"}\n\nrouter.add_route(\"/users/{id}\", UserRoute)\n\n# Add WebSocket handler\nasync def websocket_handler(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\nrouter.add_websocket(\"/ws\", websocket_handler)\n</code></pre> <p>Router with settings:</p> <pre><code>router = Router(settings={\n    \"auth_required\": True,\n    \"rate_limit\": 100\n})\n</code></pre> <p>Mounting sub-routers:</p> <pre><code>api_router = Router()\napi_router.add_route(\"/users\", users_handler)\napi_router.add_route(\"/posts\", posts_handler)\n\nmain_router = Router()\nmain_router.mount(\"/api/v1\", api_router)\n# Now /api/v1/users and /api/v1/posts are available\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of router-level settings that will be available to all routes handled by this router.</p> <code>None</code> Source code in <code>serv/routing/router.py</code> <pre><code>def __init__(self, settings: dict[str, Any] = None):\n    # Stores tuples of (path_pattern, methods, handler_callable, settings)\n    self._routes: list[\n        tuple[str, frozenset[str] | None, Callable, dict[str, Any]]\n    ] = []\n    # Stores WebSocket routes as tuples of (path_pattern, handler_callable, settings)\n    self._websocket_routes: list[tuple[str, Callable, dict[str, Any]]] = []\n    # Stores mapping of (route_class -&gt; path_pattern) for url_for lookups\n    self._route_class_paths: dict[type[routes.Route], list[str]] = {}\n    # Stores mapping of route path patterns to settings\n    self._route_settings: dict[str, dict[str, Any]] = {}\n    # Stores tuples of (mount_path, router_instance)\n    self._mounted_routers: list[tuple[str, Router]] = []\n    self._sub_routers: list[Router] = []\n    # Router-level settings\n    self._settings: dict[str, Any] = settings or {}\n</code></pre>"},{"location":"reference/serv/_routing/#serv._routing.Router.add_route","title":"add_route","text":"<pre><code>add_route(\n    path: str,\n    handler: type[Route],\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre><pre><code>add_route(\n    path: str,\n    handler: Callable[..., Awaitable[Any]],\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre> <pre><code>add_route(\n    path: str,\n    handler: Callable[..., Awaitable[Any]] | type[Route],\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n    container: Container = None,\n)\n</code></pre> <p>Adds a route to this router.</p> <p>This method can handle both direct route handlers and Route objects. For Route objects, it will automatically register all method and form handlers defined in the route.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern for the route.</p> required <code>handler</code> <code>Callable[..., Awaitable[Any]] | type[Route]</code> <p>Either a Route object or an async handler function.</p> required <code>methods</code> <code>Sequence[str] | None</code> <p>A list of HTTP methods (e.g., ['GET', 'POST']). Only used when handler is a function.     If None, allows all methods.</p> <code>None</code> <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of settings to be added to the container when handling this route.</p> <code>None</code> <code>container</code> <code>Container</code> <p>Optional container instance to use for dependency injection. If not provided, uses the global container.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; router.add_route(\"/users\", user_handler, [\"GET\", \"POST\"])\n&gt;&gt;&gt; router.add_route(\"/items\", ItemRoute, settings={\"db_table\": \"items\"})\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def add_route(\n    self,\n    path: str,\n    handler: \"Callable[..., Awaitable[Any]] | type[routes.Route]\",\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n    container: Container = None,\n):\n    \"\"\"Adds a route to this router.\n\n    This method can handle both direct route handlers and Route objects. For Route objects,\n    it will automatically register all method and form handlers defined in the route.\n\n    Args:\n        path: The path pattern for the route.\n        handler: Either a Route object or an async handler function.\n        methods: A list of HTTP methods (e.g., ['GET', 'POST']). Only used when handler is a function.\n                If None, allows all methods.\n        settings: Optional dictionary of settings to be added to the container when handling this route.\n        container: Optional container instance to use for dependency injection. If not provided, uses the global container.\n\n    Examples:\n        &gt;&gt;&gt; router.add_route(\"/users\", user_handler, [\"GET\", \"POST\"])\n        &gt;&gt;&gt; router.add_route(\"/items\", ItemRoute, settings={\"db_table\": \"items\"})\n    \"\"\"\n    match handler:\n        case type() as route if hasattr(route, \"__method_handlers__\") and hasattr(\n            route, \"__form_handlers__\"\n        ):\n            # Keep track of which paths are mapped to which Route classes\n            if route not in self._route_class_paths:\n                self._route_class_paths[route] = []\n            self._route_class_paths[route].append(path)\n\n            # Initialize the Route class directly to avoid container.call issues\n            # We'll still use a container branch to handle RouteSettings\n            if container is None:\n                # Create a new container from scratch if none was provided\n                from bevy import get_registry\n\n                container = get_registry().create_container()\n\n            with container.branch() as branch_container:\n                branch_container.add(RouteSettings, RouteSettings(**settings or {}))\n                # Create route instance directly instead of using container.call\n                try:\n                    route_instance = route()\n                except Exception as e:\n                    import logging\n\n                    logging.getLogger(__name__).error(\n                        f\"Error initializing route {route}: {e}\"\n                    )\n                    raise\n\n            methods = (\n                route.__method_handlers__.keys() | route.__form_handlers__.keys()\n            )\n            # Store these settings for the actual path\n            self._route_settings[path] = settings or {}\n            self.add_route(\n                path, route_instance.__call__, list(methods), settings=settings\n            )\n\n        case _:\n            normalized_methods = (\n                frozenset(m.upper() for m in methods) if methods else None\n            )\n            self._routes.append((path, normalized_methods, handler, settings or {}))\n</code></pre>"},{"location":"reference/serv/_routing/#serv._routing.Router.add_router","title":"add_router","text":"<pre><code>add_router(router: Router)\n</code></pre> <p>Adds a sub-router. Sub-routers are checked before the current router's own routes. Later added sub-routers are checked first (LIFO order for matching).</p> Source code in <code>serv/routing/router.py</code> <pre><code>def add_router(self, router: \"Router\"):\n    \"\"\"Adds a sub-router. Sub-routers are checked before the current router's own routes.\n    Later added sub-routers are checked first (LIFO order for matching).\"\"\"\n    self._sub_routers.append(router)\n</code></pre>"},{"location":"reference/serv/_routing/#serv._routing.Router.add_websocket","title":"add_websocket","text":"<pre><code>add_websocket(\n    path: str,\n    handler: Callable[..., Awaitable[Any]],\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre> <p>Adds a WebSocket route to this router.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern for the WebSocket route.</p> required <code>handler</code> <code>Callable[..., Awaitable[Any]]</code> <p>An async WebSocket handler function that accepts a WebSocket parameter.</p> required <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of settings to be added to the container when handling this route.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def echo_handler(websocket):\n...     async for message in websocket:\n...         await websocket.send(message)\n&gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler)\n</code></pre> <pre><code>&gt;&gt;&gt; # With settings\n&gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler, settings={\"auth_required\": True})\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def add_websocket(\n    self,\n    path: str,\n    handler: \"Callable[..., Awaitable[Any]]\",\n    *,\n    settings: dict[str, Any] = None,\n):\n    \"\"\"Adds a WebSocket route to this router.\n\n    Args:\n        path: The path pattern for the WebSocket route.\n        handler: An async WebSocket handler function that accepts a WebSocket parameter.\n        settings: Optional dictionary of settings to be added to the container when handling this route.\n\n    Examples:\n        &gt;&gt;&gt; async def echo_handler(websocket):\n        ...     async for message in websocket:\n        ...         await websocket.send(message)\n        &gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler)\n\n        &gt;&gt;&gt; # With settings\n        &gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler, settings={\"auth_required\": True})\n    \"\"\"\n    self._websocket_routes.append((path, handler, settings or {}))\n</code></pre>"},{"location":"reference/serv/_routing/#serv._routing.Router.mount","title":"mount","text":"<pre><code>mount(path: str, router: Router)\n</code></pre> <p>Mounts a router at a specific path.</p> <p>Unlike add_router which adds a router with full request path access, mount prefixes all routes in the mounted router with the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path prefix where the router should be mounted.  Should start with a '/' and not end with one.</p> required <code>router</code> <code>Router</code> <p>The router instance to mount at the specified path.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; api_router = Router()\n&gt;&gt;&gt; api_router.add_route(\"/users\", users_handler)\n&gt;&gt;&gt; main_router.mount(\"/api\", api_router)\n# Now \"/api/users\" will be handled by users_handler\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def mount(self, path: str, router: \"Router\"):\n    \"\"\"Mounts a router at a specific path.\n\n    Unlike add_router which adds a router with full request path access,\n    mount prefixes all routes in the mounted router with the given path.\n\n    Args:\n        path: The path prefix where the router should be mounted.\n             Should start with a '/' and not end with one.\n        router: The router instance to mount at the specified path.\n\n    Examples:\n        &gt;&gt;&gt; api_router = Router()\n        &gt;&gt;&gt; api_router.add_route(\"/users\", users_handler)\n        &gt;&gt;&gt; main_router.mount(\"/api\", api_router)\n        # Now \"/api/users\" will be handled by users_handler\n    \"\"\"\n    if not path.startswith(\"/\"):\n        path = \"/\" + path\n    if path.endswith(\"/\"):\n        path = path[:-1]\n\n    self._mounted_routers.append((path, router))\n</code></pre>"},{"location":"reference/serv/_routing/#serv._routing.Router.resolve_route","title":"resolve_route","text":"<pre><code>resolve_route(\n    request_path: str, request_method: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Recursively finds a handler for the given path and method.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The path of the incoming request.</p> required <code>request_method</code> <code>str</code> <p>The HTTP method of the incoming request.</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>None if no route matches the path (results in a 404).</p> <p>Raises:</p> Type Description <code>HTTPMethodNotAllowedException</code> <p>If one or more routes match the path but not the method,                            and no route matches both path and method.</p> Source code in <code>serv/routing/router.py</code> <pre><code>def resolve_route(\n    self, request_path: str, request_method: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Recursively finds a handler for the given path and method.\n\n    Args:\n        request_path: The path of the incoming request.\n        request_method: The HTTP method of the incoming request.\n\n    Returns:\n        A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.\n        None if no route matches the path (results in a 404).\n\n    Raises:\n        HTTPMethodNotAllowedException: If one or more routes match the path but not the method,\n                                       and no route matches both path and method.\n    \"\"\"\n    from serv.routing.resolvers import resolve_http_route\n\n    return resolve_http_route(\n        request_path,\n        request_method,\n        self._mounted_routers,\n        self._sub_routers,\n        self._routes,\n        self._settings,\n        self._match_path\n    )\n</code></pre>"},{"location":"reference/serv/_routing/#serv._routing.Router.resolve_websocket","title":"resolve_websocket","text":"<pre><code>resolve_websocket(\n    request_path: str,\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Resolve a WebSocket route for the given path.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The WebSocket request path to match against registered routes.</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_params, route_settings) if a matching</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>WebSocket route is found, None otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler, params, settings = router.resolve_websocket(\"/ws/user/123\")\n&gt;&gt;&gt; if handler:\n...     # Handle WebSocket connection\n...     await handler(websocket, **params)\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def resolve_websocket(\n    self, request_path: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Resolve a WebSocket route for the given path.\n\n    Args:\n        request_path: The WebSocket request path to match against registered routes.\n\n    Returns:\n        A tuple of (handler_callable, path_params, route_settings) if a matching\n        WebSocket route is found, None otherwise.\n\n    Examples:\n        &gt;&gt;&gt; handler, params, settings = router.resolve_websocket(\"/ws/user/123\")\n        &gt;&gt;&gt; if handler:\n        ...     # Handle WebSocket connection\n        ...     await handler(websocket, **params)\n    \"\"\"\n    from serv.routing.resolvers import resolve_websocket_route\n\n    return resolve_websocket_route(\n        request_path,\n        self._mounted_routers,\n        self._sub_routers,\n        self._websocket_routes,\n        self._settings,\n        self._match_path\n    )\n</code></pre>"},{"location":"reference/serv/_routing/#serv._routing.Router.url_for","title":"url_for","text":"<pre><code>url_for(handler: Callable | type[Route], **kwargs) -&gt; str\n</code></pre> <p>Builds a URL for a registered route handler with the given path parameters.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable | type[Route]</code> <p>The route handler function or Route class for which to build a URL.</p> required <code>**kwargs</code> <p>Path parameters to substitute in the URL pattern.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A URL string with path parameters filled in.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the handler is not found in any router, or if required path        parameters are missing from kwargs.</p> Source code in <code>serv/routing/router.py</code> <pre><code>def url_for(self, handler: Callable | type[\"routes.Route\"], **kwargs) -&gt; str:\n    \"\"\"Builds a URL for a registered route handler with the given path parameters.\n\n    Args:\n        handler: The route handler function or Route class for which to build a URL.\n        **kwargs: Path parameters to substitute in the URL pattern.\n\n    Returns:\n        A URL string with path parameters filled in.\n\n    Raises:\n        ValueError: If the handler is not found in any router, or if required path\n                   parameters are missing from kwargs.\n    \"\"\"\n    # Import generation functions to avoid circular dependency\n    from serv.routing.generation import url_for_route_class, url_for_function_handler\n\n    # Import routes at runtime to avoid circular dependency\n    import serv.routes as routes\n\n    # First check if handler is a Route class\n    if isinstance(handler, type) and issubclass(handler, routes.Route):\n        return url_for_route_class(\n            self._route_class_paths,\n            self._mounted_routers,\n            self._sub_routers,\n            handler,\n            **kwargs\n        )\n\n    # Handle methods on Route instances (less common case)\n    elif hasattr(handler, \"__self__\"):\n        if isinstance(handler.__self__, routes.Route):\n            route_instance = handler.__self__\n            handler = route_instance.__call__\n            path = self._find_handler_path(handler)\n            if not path:\n                raise ValueError(\n                    f\"Route instance method {handler.__name__} not found in any router\"\n                )\n\n            from serv.routing.generation import build_url_from_path\n            return build_url_from_path(path, kwargs)\n\n    # For function handlers\n    else:\n        return url_for_function_handler(\n            self._routes,\n            self._mounted_routers,\n            self._sub_routers,\n            handler,\n            **kwargs\n        )\n</code></pre>"},{"location":"reference/serv/_routing/#serv._routing.get_current_router","title":"get_current_router","text":"<pre><code>get_current_router(container: Inject[Container]) -&gt; Router\n</code></pre> <p>Retrieves the current request's root Router instance from the Bevy container.</p> Source code in <code>serv/routing/router.py</code> <pre><code>@injectable\ndef get_current_router(container: Inject[Container]) -&gt; Router:\n    \"\"\"Retrieves the current request's root Router instance from the Bevy container.\"\"\"\n    try:\n        return container.get(Router)\n    except Exception as e:  # Bevy might raise a specific exception if not found\n        raise RuntimeError(\n            \"Router not found in the current request container. Ensure it's added during request setup.\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/additional_context/","title":"additional_context","text":""},{"location":"reference/serv/additional_context/#serv.additional_context","title":"serv.additional_context","text":""},{"location":"reference/serv/additional_context/#serv.additional_context.ExceptionContext","title":"ExceptionContext","text":"<pre><code>ExceptionContext(exception: type[Exception] = Exception)\n</code></pre> <p>Context manager for adding additional context to exceptions.</p> <p>This can be used to add notes or perform additional actions when an exception is raised within the context.</p> Example <p>with ExceptionContext(ValueError).apply_note(\"Additional context\"):     raise ValueError(\"Original error message\")</p> Example <p>with ExceptionContext().capture(lambda exc: print(f\"Captured: {exc}\")):     raise ValueError(\"Original error message\")</p> Example <p>with ExceptionContext(ValueError).capture(lambda exc: print(f\"Captured: {exc}\")).apply_note(\"Additional context\"):     raise ValueError(\"Original error message\")</p> Source code in <code>serv/additional_context.py</code> <pre><code>def __init__(self, exception: type[Exception] = Exception):\n    self.exception_type = exception\n    self.capture_callback = None\n    self.note = None\n</code></pre>"},{"location":"reference/serv/app/","title":"App","text":""},{"location":"reference/serv/app/#serv.app","title":"serv.app","text":"<p>Application layer for Serv - core app, middleware, extensions, lifecycle.</p>"},{"location":"reference/serv/app/#serv.app.App","title":"App","text":"<pre><code>App(\n    *,\n    config: str = \"./serv.config.yaml\",\n    extension_dir: str = \"./extensions\",\n    dev_mode: bool = False,\n)\n</code></pre> <p>               Bases: <code>EventEmitterProtocol</code>, <code>AppContextProtocol</code></p> <p>The main ASGI application class for Serv web framework.</p> <p>This class serves as the central orchestrator for your web application, handling incoming HTTP requests, managing extensions, middleware, routing, and dependency injection. It implements the ASGI (Asynchronous Server Gateway Interface) specification.</p> <p>The App class provides: - Extension system for extensible functionality - Middleware stack for request/response processing - Dependency injection container - Error handling and custom error pages - Template rendering capabilities - Event emission system for extension communication</p> <p>Examples:</p> <p>Basic application setup:</p> <pre><code>from serv import App\n\n# Create a basic app\napp = App()\n\n# Create app with custom config\napp = App(config=\"./config/production.yaml\")\n\n# Create app with custom extension directory\napp = App(extension_dir=\"./my_extensions\")\n\n# Development mode with enhanced debugging\napp = App(dev_mode=True)\n</code></pre> <p>Using with ASGI servers:</p> <pre><code># For uvicorn\n# uvicorn main:app --reload\n\n# For gunicorn\n# gunicorn main:app -k uvicorn.workers.UvicornWorker\n</code></pre> <p>Advanced configuration:</p> <pre><code>app = App(\n    config=\"./config/production.yaml\",\n    extension_dir=\"./extensions\",\n    dev_mode=False\n)\n\n# Add custom error handler\nasync def custom_404_handler(error):\n    # Handle 404 errors\n    pass\n\napp.add_error_handler(HTTPNotFoundException, custom_404_handler)\n\n# Add middleware\nasync def logging_middleware():\n    # Middleware logic\n    yield\n\napp.add_middleware(logging_middleware)\n</code></pre> <p>Initialize a new Serv application instance.</p> <p>Creates and configures a new ASGI application with the specified settings. This includes setting up the dependency injection container, loading extensions, configuring middleware, and preparing the routing system.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>Path to the YAML configuration file. The config file defines site information, enabled extensions, middleware stack, and other application settings. Defaults to \"./serv.config.yaml\".</p> <code>'./serv.config.yaml'</code> <code>extension_dir</code> <code>str</code> <p>Directory path where extensions are located. Extensions in this directory will be available for loading. Defaults to \"./extensions\".</p> <code>'./extensions'</code> <code>extension_dir</code> <code>str</code> <p>Legacy parameter name for extension_dir (backward compatibility).</p> <code>'./extensions'</code> <code>dev_mode</code> <code>bool</code> <p>Enable development mode features including enhanced error reporting, debug logging, and development-specific behaviors. Should be False in production. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ServConfigError</code> <p>If the configuration file cannot be loaded or contains invalid YAML/configuration structure.</p> <code>ImportError</code> <p>If required dependencies for extensions cannot be imported.</p> <code>ValueError</code> <p>If extension_dir path is invalid or inaccessible.</p> <p>Examples:</p> <p>Basic initialization:</p> <pre><code># Use default settings\napp = App()\n\n# Custom config file\napp = App(config=\"config/production.yaml\")\n\n# Custom extension directory\napp = App(extension_dir=\"src/extensions\")\n\n# Development mode\napp = App(dev_mode=True)\n</code></pre> <p>Production setup:</p> <pre><code>app = App(\n    config=\"/etc/myapp/config.yaml\",\n    extension_dir=\"/opt/myapp/extensions\",\n    dev_mode=False\n)\n</code></pre> <p>Development setup:</p> <pre><code>app = App(\n    config=\"dev.config.yaml\",\n    extension_dir=\"./dev_extensions\",\n    dev_mode=True\n)\n</code></pre> Note <p>The application will automatically load the welcome extension if no other extensions are configured, providing a default landing page for new projects.</p> Source code in <code>serv/_app.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: str = \"./serv.config.yaml\",\n    extension_dir: str = \"./extensions\",\n    dev_mode: bool = False,\n):\n    \"\"\"Initialize a new Serv application instance.\n\n    Creates and configures a new ASGI application with the specified settings.\n    This includes setting up the dependency injection container, loading extensions,\n    configuring middleware, and preparing the routing system.\n\n    Args:\n        config: Path to the YAML configuration file. The config file defines\n            site information, enabled extensions, middleware stack, and other\n            application settings. Defaults to \"./serv.config.yaml\".\n        extension_dir: Directory path where extensions are located. Extensions in this\n            directory will be available for loading. Defaults to \"./extensions\".\n        extension_dir: Legacy parameter name for extension_dir (backward compatibility).\n        dev_mode: Enable development mode features including enhanced error\n            reporting, debug logging, and development-specific behaviors.\n            Should be False in production. Defaults to False.\n\n    Raises:\n        ServConfigError: If the configuration file cannot be loaded or contains\n            invalid YAML/configuration structure.\n        ImportError: If required dependencies for extensions cannot be imported.\n        ValueError: If extension_dir path is invalid or inaccessible.\n\n    Examples:\n        Basic initialization:\n\n        ```python\n        # Use default settings\n        app = App()\n\n        # Custom config file\n        app = App(config=\"config/production.yaml\")\n\n        # Custom extension directory\n        app = App(extension_dir=\"src/extensions\")\n\n        # Development mode\n        app = App(dev_mode=True)\n        ```\n\n        Production setup:\n\n        ```python\n        app = App(\n            config=\"/etc/myapp/config.yaml\",\n            extension_dir=\"/opt/myapp/extensions\",\n            dev_mode=False\n        )\n        ```\n\n        Development setup:\n\n        ```python\n        app = App(\n            config=\"dev.config.yaml\",\n            extension_dir=\"./dev_extensions\",\n            dev_mode=True\n        )\n        ```\n\n    Note:\n        The application will automatically load the welcome extension if no other\n        extensions are configured, providing a default landing page for new projects.\n    \"\"\"\n    self._config = self._load_config(config)\n    self._dev_mode = dev_mode\n    self._registry = get_registry()\n    self._container = self._registry.create_container()\n    self._async_exit_stack = contextlib.AsyncExitStack()\n    self._error_handlers: dict[\n        type[Exception], Callable[[Exception], Awaitable[None]]\n    ] = {}\n    self._middleware = []\n\n    # Handle backward compatibility for extension_dir parameter\n    actual_extension_dir = extension_dir if extension_dir is None else extension_dir\n    self._extension_loader = Importer(actual_extension_dir)\n    self._extensions: dict[Path, list[Listener]] = defaultdict(list)\n\n    # Initialize the extension loader\n    self._extension_loader_instance = ExtensionLoader(self, self._extension_loader)\n\n    self._emit = EventEmitter(self._extensions)\n\n    # Initialize database manager\n    self._database_manager = DatabaseManager(self._config, self._container)\n\n    self._init_container()\n    self._register_default_error_handlers()\n    self._init_extensions(\n        self._config.get(\"extensions\", self._config.get(\"extensions\", []))\n    )\n</code></pre>"},{"location":"reference/serv/app/#serv.app.App.dev_mode","title":"dev_mode  <code>property</code> <code>writable</code>","text":"<pre><code>dev_mode: bool\n</code></pre> <p>Get the current development mode setting.</p>"},{"location":"reference/serv/app/#serv.app.App.add_error_handler","title":"add_error_handler","text":"<pre><code>add_error_handler(\n    error_type: type[Exception],\n    handler: Callable[[Exception], Awaitable[None]],\n)\n</code></pre> <p>Register a custom error handler for specific exception types.</p> <p>Error handlers allow you to customize how your application responds to different types of errors, providing custom error pages, logging, or recovery mechanisms.</p> <p>Parameters:</p> Name Type Description Default <code>error_type</code> <code>type[Exception]</code> <p>The exception class to handle. The handler will be called for this exception type and any of its subclasses.</p> required <code>handler</code> <code>Callable[[Exception], Awaitable[None]]</code> <p>An async function that will be called when the exception occurs. The handler receives the exception instance and can use dependency injection to access request/response objects.</p> required <p>Examples:</p> <p>Handle 404 errors with a custom page:</p> <pre><code>from serv.exceptions import HTTPNotFoundException\nfrom serv.responses import ResponseBuilder\nfrom bevy import injectable, Inject\n\n@injectable\nasync def custom_404_handler(\n    error: HTTPNotFoundException,\n    response: Inject[ResponseBuilder]\n):\n    response.set_status(404)\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;Page Not Found&lt;/h1&gt;&lt;p&gt;Sorry, that page doesn't exist.&lt;/p&gt;\")\n\napp.add_error_handler(HTTPNotFoundException, custom_404_handler)\n</code></pre> <p>Handle validation errors:</p> <pre><code>class ValidationError(Exception):\n    def __init__(self, message: str, field: str):\n        self.message = message\n        self.field = field\n\n@injectable\nasync def validation_error_handler(\n    error: ValidationError,\n    response: Inject[ResponseBuilder]\n):\n    response.set_status(400)\n    response.content_type(\"application/json\")\n    response.body({\n        \"error\": \"validation_failed\",\n        \"message\": error.message,\n        \"field\": error.field\n    })\n\napp.add_error_handler(ValidationError, validation_error_handler)\n</code></pre> <p>Generic error handler with logging:</p> <pre><code>import logging\n\n@injectable\nasync def generic_error_handler(\n    error: Exception,\n    response: Inject[ResponseBuilder],\n    request: Inject[Request]\n):\n    logging.error(f\"Unhandled error on {request.path}: {error}\")\n    response.set_status(500)\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;Internal Server Error&lt;/h1&gt;\")\n\napp.add_error_handler(Exception, generic_error_handler)\n</code></pre> Source code in <code>serv/_app.py</code> <pre><code>def add_error_handler(\n    self,\n    error_type: type[Exception],\n    handler: Callable[[Exception], Awaitable[None]],\n):\n    \"\"\"Register a custom error handler for specific exception types.\n\n    Error handlers allow you to customize how your application responds to\n    different types of errors, providing custom error pages, logging, or\n    recovery mechanisms.\n\n    Args:\n        error_type: The exception class to handle. The handler will be called\n            for this exception type and any of its subclasses.\n        handler: An async function that will be called when the exception occurs.\n            The handler receives the exception instance and can use dependency\n            injection to access request/response objects.\n\n    Examples:\n        Handle 404 errors with a custom page:\n\n        ```python\n        from serv.exceptions import HTTPNotFoundException\n        from serv.responses import ResponseBuilder\n        from bevy import injectable, Inject\n\n        @injectable\n        async def custom_404_handler(\n            error: HTTPNotFoundException,\n            response: Inject[ResponseBuilder]\n        ):\n            response.set_status(404)\n            response.content_type(\"text/html\")\n            response.body(\"&lt;h1&gt;Page Not Found&lt;/h1&gt;&lt;p&gt;Sorry, that page doesn't exist.&lt;/p&gt;\")\n\n        app.add_error_handler(HTTPNotFoundException, custom_404_handler)\n        ```\n\n        Handle validation errors:\n\n        ```python\n        class ValidationError(Exception):\n            def __init__(self, message: str, field: str):\n                self.message = message\n                self.field = field\n\n        @injectable\n        async def validation_error_handler(\n            error: ValidationError,\n            response: Inject[ResponseBuilder]\n        ):\n            response.set_status(400)\n            response.content_type(\"application/json\")\n            response.body({\n                \"error\": \"validation_failed\",\n                \"message\": error.message,\n                \"field\": error.field\n            })\n\n        app.add_error_handler(ValidationError, validation_error_handler)\n        ```\n\n        Generic error handler with logging:\n\n        ```python\n        import logging\n\n        @injectable\n        async def generic_error_handler(\n            error: Exception,\n            response: Inject[ResponseBuilder],\n            request: Inject[Request]\n        ):\n            logging.error(f\"Unhandled error on {request.path}: {error}\")\n            response.set_status(500)\n            response.content_type(\"text/html\")\n            response.body(\"&lt;h1&gt;Internal Server Error&lt;/h1&gt;\")\n\n        app.add_error_handler(Exception, generic_error_handler)\n        ```\n    \"\"\"\n    self._error_handlers[error_type] = handler\n</code></pre>"},{"location":"reference/serv/app/#serv.app.App.add_middleware","title":"add_middleware","text":"<pre><code>add_middleware(\n    middleware: Callable[[], AsyncIterator[None]],\n)\n</code></pre> <p>Add middleware to the application's middleware stack.</p> <p>Middleware functions are executed in the order they are added, wrapping around the request handling process. They can modify requests, responses, add headers, implement authentication, logging, and more.</p> <p>Parameters:</p> Name Type Description Default <code>middleware</code> <code>Callable[[], AsyncIterator[None]]</code> <p>An async generator function that yields control to the next middleware or route handler. The function should yield exactly once.</p> required <p>Examples:</p> <p>Basic logging middleware:</p> <pre><code>import logging\nfrom serv.requests import Request\nfrom bevy import injectable, Inject\n\n@injectable\nasync def logging_middleware(\n    request: Inject[Request]\n):\n    logging.info(f\"Request: {request.method} {request.path}\")\n    start_time = time.time()\n\n    yield  # Pass control to next middleware/handler\n\n    duration = time.time() - start_time\n    logging.info(f\"Response time: {duration:.3f}s\")\n\napp.add_middleware(logging_middleware)\n</code></pre> <p>Authentication middleware:</p> <pre><code>from serv.responses import ResponseBuilder\nfrom serv.requests import Request\nfrom bevy import injectable, Inject\n\n@injectable\nasync def auth_middleware(\n    request: Inject[Request],\n    response: Inject[ResponseBuilder]\n):\n    # Check for authentication\n    auth_header = request.headers.get(\"authorization\")\n    if not auth_header and request.path.startswith(\"/api/\"):\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body({\"error\": \"Authentication required\"})\n        return  # Don't yield, stop processing\n\n    yield  # Continue to next middleware/handler\n\napp.add_middleware(auth_middleware)\n</code></pre> <p>CORS middleware:</p> <pre><code>@injectable\nasync def cors_middleware(\n    request: Inject[Request],\n    response: Inject[ResponseBuilder]\n):\n    # Add CORS headers\n    response.add_header(\"Access-Control-Allow-Origin\", \"*\")\n    response.add_header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n    response.add_header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\n    # Handle preflight requests\n    if request.method == \"OPTIONS\":\n        response.set_status(200)\n        return\n\n    yield  # Continue processing\n\napp.add_middleware(cors_middleware)\n</code></pre> Note <p>Middleware is executed in LIFO (Last In, First Out) order during request processing, and FIFO (First In, First Out) order during response processing.</p> Source code in <code>serv/_app.py</code> <pre><code>def add_middleware(self, middleware: Callable[[], AsyncIterator[None]]):\n    \"\"\"Add middleware to the application's middleware stack.\n\n    Middleware functions are executed in the order they are added, wrapping\n    around the request handling process. They can modify requests, responses,\n    add headers, implement authentication, logging, and more.\n\n    Args:\n        middleware: An async generator function that yields control to the next\n            middleware or route handler. The function should yield exactly once.\n\n    Examples:\n        Basic logging middleware:\n\n        ```python\n        import logging\n        from serv.requests import Request\n        from bevy import injectable, Inject\n\n        @injectable\n        async def logging_middleware(\n            request: Inject[Request]\n        ):\n            logging.info(f\"Request: {request.method} {request.path}\")\n            start_time = time.time()\n\n            yield  # Pass control to next middleware/handler\n\n            duration = time.time() - start_time\n            logging.info(f\"Response time: {duration:.3f}s\")\n\n        app.add_middleware(logging_middleware)\n        ```\n\n        Authentication middleware:\n\n        ```python\n        from serv.responses import ResponseBuilder\n        from serv.requests import Request\n        from bevy import injectable, Inject\n\n        @injectable\n        async def auth_middleware(\n            request: Inject[Request],\n            response: Inject[ResponseBuilder]\n        ):\n            # Check for authentication\n            auth_header = request.headers.get(\"authorization\")\n            if not auth_header and request.path.startswith(\"/api/\"):\n                response.set_status(401)\n                response.content_type(\"application/json\")\n                response.body({\"error\": \"Authentication required\"})\n                return  # Don't yield, stop processing\n\n            yield  # Continue to next middleware/handler\n\n        app.add_middleware(auth_middleware)\n        ```\n\n        CORS middleware:\n\n        ```python\n        @injectable\n        async def cors_middleware(\n            request: Inject[Request],\n            response: Inject[ResponseBuilder]\n        ):\n            # Add CORS headers\n            response.add_header(\"Access-Control-Allow-Origin\", \"*\")\n            response.add_header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n            response.add_header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\n            # Handle preflight requests\n            if request.method == \"OPTIONS\":\n                response.set_status(200)\n                return\n\n            yield  # Continue processing\n\n        app.add_middleware(cors_middleware)\n        ```\n\n    Note:\n        Middleware is executed in LIFO (Last In, First Out) order during request\n        processing, and FIFO (First In, First Out) order during response processing.\n    \"\"\"\n    self._middleware.append(middleware)\n</code></pre>"},{"location":"reference/serv/app/#serv.app.App.emit","title":"emit  <code>async</code>","text":"<pre><code>emit(\n    event: str, *, container: Inject[Container], **kwargs\n) -&gt; None\n</code></pre> <p>Async emit method for EventEmitterProtocol compliance.</p> Source code in <code>serv/_app.py</code> <pre><code>@injectable\nasync def emit(self, event: str, *, container: Inject[Container], **kwargs) -&gt; None:\n    \"\"\"Async emit method for EventEmitterProtocol compliance.\"\"\"\n    await self._emit.emit(event, container=container, **kwargs)\n</code></pre>"},{"location":"reference/serv/app/#serv.app.App.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(callback: Callable[[], Awaitable[None]])\n</code></pre> <p>Add a callback to be called when the application is shutting down.</p> Source code in <code>serv/_app.py</code> <pre><code>def on_shutdown(self, callback: Callable[[], Awaitable[None]]):\n    \"\"\"Add a callback to be called when the application is shutting down.\"\"\"\n    self._async_exit_stack.push_async_callback(callback)\n</code></pre>"},{"location":"reference/serv/app_factory/","title":"app_factory","text":""},{"location":"reference/serv/app_factory/#serv.app_factory","title":"serv.app_factory","text":"<p>Application factory for creating configured Serv apps.</p> <p>This module provides a reusable factory for creating App instances with CLI-style configuration, making it easy to create apps both in the CLI and for testing.</p>"},{"location":"reference/serv/app_factory/#serv.app_factory.create_app","title":"create_app","text":"<pre><code>create_app(\n    *,\n    app_module_str: str | None = None,\n    config: str | None = None,\n    extension_dirs: str | None = None,\n    dev: bool = False,\n) -&gt; App\n</code></pre> <p>Create a configured App instance.</p> <p>This function mirrors the CLI's app creation logic, allowing for the same configuration options to be used both in the CLI and programmatically.</p> <p>Parameters:</p> Name Type Description Default <code>app_module_str</code> <code>str | None</code> <p>Custom application class in the format \"module.path:ClassName\". If not provided, Serv's default App is used.</p> <code>None</code> <code>config</code> <code>str | None</code> <p>Path to config file. If not provided, App uses its default.</p> <code>None</code> <code>extension_dirs</code> <code>str | None</code> <p>Directory to search for extensions. If not provided, App uses its default.</p> <code>None</code> <code>dev</code> <code>bool</code> <p>Enable development mode with enhanced features.</p> <code>False</code> <p>Returns:</p> Type Description <code>App</code> <p>A configured App instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If app_module_str is not a valid App class.</p> <code>ImportError</code> <p>If the app module cannot be imported.</p> <code>Exception</code> <p>If app creation fails.</p> <p>Examples:</p> <p>Create a basic app: <pre><code>app = create_app()\n</code></pre></p> <p>Create app with custom config: <pre><code>app = create_app(config=\"./custom.config.yaml\")\n</code></pre></p> <p>Create app with development mode: <pre><code>app = create_app(dev=True)\n</code></pre></p> <p>Create app with custom app class: <pre><code>app = create_app(app_module_str=\"myproject.app:CustomApp\")\n</code></pre></p> Source code in <code>serv/app_factory.py</code> <pre><code>def create_app(\n    *,\n    app_module_str: str | None = None,\n    config: str | None = None,\n    extension_dirs: str | None = None,\n    dev: bool = False,\n) -&gt; App:\n    \"\"\"Create a configured App instance.\n\n    This function mirrors the CLI's app creation logic, allowing for the same\n    configuration options to be used both in the CLI and programmatically.\n\n    Args:\n        app_module_str: Custom application class in the format \"module.path:ClassName\".\n            If not provided, Serv's default App is used.\n        config: Path to config file. If not provided, App uses its default.\n        extension_dirs: Directory to search for extensions. If not provided, App uses its default.\n        dev: Enable development mode with enhanced features.\n\n    Returns:\n        A configured App instance.\n\n    Raises:\n        ValueError: If app_module_str is not a valid App class.\n        ImportError: If the app module cannot be imported.\n        Exception: If app creation fails.\n\n    Examples:\n        Create a basic app:\n        ```python\n        app = create_app()\n        ```\n\n        Create app with custom config:\n        ```python\n        app = create_app(config=\"./custom.config.yaml\")\n        ```\n\n        Create app with development mode:\n        ```python\n        app = create_app(dev=True)\n        ```\n\n        Create app with custom app class:\n        ```python\n        app = create_app(app_module_str=\"myproject.app:CustomApp\")\n        ```\n    \"\"\"\n    # Determine the app class to use\n    if app_module_str:\n        try:\n            app_class = import_from_string(app_module_str)\n            if not isclass(app_class) or not issubclass(app_class, App):\n                raise ValueError(f\"'{app_module_str}' is not a valid App class\")\n        except Exception as e:\n            logger.error(f\"Error importing app class '{app_module_str}': {e}\")\n            raise\n    else:\n        app_class = App\n\n    # Build app kwargs from provided arguments\n    app_kwargs: dict[str, Any] = {}\n\n    if config is not None:\n        app_kwargs[\"config\"] = config\n\n    if extension_dirs is not None:\n        app_kwargs[\"extension_dir\"] = extension_dirs\n    else:\n        # Default to ./extensions directory if it exists\n        default_extension_dir = Path.cwd() / \"extensions\"\n        if default_extension_dir.exists():\n            app_kwargs[\"extension_dir\"] = str(default_extension_dir)\n\n    if dev:\n        app_kwargs[\"dev_mode\"] = True\n\n    try:\n        logger.info(f\"Creating App ({app_class.__name__}) with arguments: {app_kwargs}\")\n        app = app_class(**app_kwargs)\n        return app\n    except Exception as e:\n        logger.error(f\"Error creating app instance: {e}\")\n        raise\n</code></pre>"},{"location":"reference/serv/config/","title":"config","text":""},{"location":"reference/serv/config/#serv.config","title":"serv.config","text":""},{"location":"reference/serv/config/#serv.config.ServConfigError","title":"ServConfigError","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for configuration errors.</p>"},{"location":"reference/serv/config/#serv.config.import_from_string","title":"import_from_string","text":"<pre><code>import_from_string(import_str: str) -&gt; Any\n</code></pre> <p>Import a class, function, or variable from a module by string.</p> <p>This utility function allows dynamic importing of Python objects using string notation, which is commonly used in configuration files and extension systems.</p> <p>Parameters:</p> Name Type Description Default <code>import_str</code> <code>str</code> <p>String in the format \"module.path:symbol\" where module.path is the Python module path and symbol is the name of the object to import from that module.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The imported object (class, function, variable, etc.).</p> <p>Raises:</p> Type Description <code>ServConfigError</code> <p>If the import failed due to missing module, missing symbol, or other import-related errors.</p> <p>Examples:</p> <p>Import a class:</p> <pre><code># Import the App class from serv.app module\napp_class = import_from_string(\"serv.app:App\")\napp = app_class()\n</code></pre> <p>Import a function:</p> <pre><code># Import a specific function\nhandler = import_from_string(\"myapp.handlers:user_handler\")\n</code></pre> <p>Import a nested attribute:</p> <pre><code># Import a nested class or attribute\nvalidator = import_from_string(\"myapp.validators:UserValidator.email_validator\")\n</code></pre> <p>Common usage in extension configuration:</p> <pre><code># In extension.yaml:\n# entry_points:\n#   main: \"myapp.extensions.auth:AuthExtension\"\n\nextension_class = import_from_string(\"myapp.extensions.auth:AuthExtension\")\nextension_instance = extension_class()\n</code></pre> Note <p>The import string format follows the pattern used by many Python frameworks and tools. The colon (:) separates the module path from the symbol name within that module.</p> Source code in <code>serv/config.py</code> <pre><code>def import_from_string(import_str: str) -&gt; Any:\n    \"\"\"Import a class, function, or variable from a module by string.\n\n    This utility function allows dynamic importing of Python objects using\n    string notation, which is commonly used in configuration files and\n    extension systems.\n\n    Args:\n        import_str: String in the format \"module.path:symbol\" where module.path\n            is the Python module path and symbol is the name of the object to\n            import from that module.\n\n    Returns:\n        The imported object (class, function, variable, etc.).\n\n    Raises:\n        ServConfigError: If the import failed due to missing module, missing\n            symbol, or other import-related errors.\n\n    Examples:\n        Import a class:\n\n        ```python\n        # Import the App class from serv.app module\n        app_class = import_from_string(\"serv.app:App\")\n        app = app_class()\n        ```\n\n        Import a function:\n\n        ```python\n        # Import a specific function\n        handler = import_from_string(\"myapp.handlers:user_handler\")\n        ```\n\n        Import a nested attribute:\n\n        ```python\n        # Import a nested class or attribute\n        validator = import_from_string(\"myapp.validators:UserValidator.email_validator\")\n        ```\n\n        Common usage in extension configuration:\n\n        ```python\n        # In extension.yaml:\n        # entry_points:\n        #   main: \"myapp.extensions.auth:AuthExtension\"\n\n        extension_class = import_from_string(\"myapp.extensions.auth:AuthExtension\")\n        extension_instance = extension_class()\n        ```\n\n    Note:\n        The import string format follows the pattern used by many Python\n        frameworks and tools. The colon (:) separates the module path from\n        the symbol name within that module.\n    \"\"\"\n    if \":\" not in import_str:\n        raise ServConfigError(\n            f\"Invalid import string format '{import_str}'. Expected 'module.path:symbol'.\"\n        )\n\n    module_path, object_path = import_str.split(\":\", 1)\n\n    try:\n        module = importlib.import_module(module_path)\n\n        # Handle nested attributes\n        target = module\n        for part in object_path.split(\".\"):\n            target = getattr(target, part)\n\n        return target\n    except (ImportError, AttributeError) as e:\n        raise ServConfigError(f\"Failed to import '{import_str}': {str(e)}\") from e\n</code></pre>"},{"location":"reference/serv/config/#serv.config.import_module_from_string","title":"import_module_from_string","text":"<pre><code>import_module_from_string(module_path: str) -&gt; Any\n</code></pre> <p>Import a module by string.</p> <p>Parameters:</p> Name Type Description Default <code>module_path</code> <code>str</code> <p>String representing the module path (e.g., \"serv.app\")</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The imported module</p> <p>Raises:</p> Type Description <code>ServConfigError</code> <p>If the import failed.</p> Source code in <code>serv/config.py</code> <pre><code>def import_module_from_string(module_path: str) -&gt; Any:\n    \"\"\"\n    Import a module by string.\n\n    Args:\n        module_path: String representing the module path (e.g., \"serv.app\")\n\n    Returns:\n        The imported module\n\n    Raises:\n        ServConfigError: If the import failed.\n    \"\"\"\n    try:\n        return importlib.import_module(module_path)\n    except ImportError as e:\n        raise ServConfigError(\n            f\"Failed to import module '{module_path}': {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/config/#serv.config.load_raw_config","title":"load_raw_config","text":"<pre><code>load_raw_config(config_path: str | Path) -&gt; dict[str, Any]\n</code></pre> <p>Load a configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str | Path</code> <p>Path to the configuration file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing the configuration.</p> <p>Raises:</p> Type Description <code>ServConfigError</code> <p>If the configuration file could not be loaded.</p> Source code in <code>serv/config.py</code> <pre><code>def load_raw_config(config_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Load a configuration file.\n\n    Args:\n        config_path: Path to the configuration file.\n\n    Returns:\n        Dictionary containing the configuration.\n\n    Raises:\n        ServConfigError: If the configuration file could not be loaded.\n    \"\"\"\n    try:\n        config_path_obj = Path(config_path)\n        if not config_path_obj.exists():\n            return {}\n\n        with open(config_path_obj) as f:\n            config = yaml.safe_load(f)\n\n        if config is None:  # Empty file\n            config = {}\n\n        if not isinstance(config, dict):\n            raise ServConfigError(\n                f\"Invalid configuration format in {config_path}. Expected a dictionary.\"\n            )\n\n        return config\n    except Exception as e:\n        if isinstance(e, ServConfigError):\n            raise\n        raise ServConfigError(\n            f\"Error loading configuration from {config_path}: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/exceptions/","title":"exceptions","text":""},{"location":"reference/serv/exceptions/#serv.exceptions","title":"serv.exceptions","text":""},{"location":"reference/serv/exceptions/#serv.exceptions.HTTPBadRequestException","title":"HTTPBadRequestException","text":"<pre><code>HTTPBadRequestException(message: str | None = None, *args)\n</code></pre> <p>               Bases: <code>ServException</code></p> <p>Raised for malformed requests or client errors (HTTP 400).</p> <p>This exception should be raised when the client sends a request that cannot be processed due to invalid syntax, missing required parameters, or other client-side errors.</p> <p>Examples:</p> <p>Validation errors:</p> <pre><code>from serv.routes import Route, PostRequest\nfrom serv.exceptions import HTTPBadRequestException\n\nclass UserRoute(Route):\n    async def handle_post(self, request: PostRequest):\n        data = await request.json()\n\n        if not data.get(\"email\"):\n            raise HTTPBadRequestException(\"Email field is required\")\n\n        if \"@\" not in data[\"email\"]:\n            raise HTTPBadRequestException(\"Invalid email format\")\n\n        # Process valid request...\n</code></pre> <p>Form validation:</p> <pre><code>class ContactForm(Form):\n    name: str\n    email: str\n    message: str\n\nclass ContactRoute(Route):\n    async def handle_contact_form(self, form: ContactForm):\n        if len(form.message) &lt; 10:\n            raise HTTPBadRequestException(\"Message must be at least 10 characters\")\n\n        # Process form...\n</code></pre> Source code in <code>serv/exceptions.py</code> <pre><code>def __init__(self, message: str | None = None, *args):\n    super().__init__(message, *args)  # Pass message to parent Exception\n    # Set self.message: use provided message, or if None, try to use the first arg (if any)\n    # or fall back to a default string representation of the class name.\n    if message is not None:\n        self.message = message\n    elif args and args[0]:  # If message is None but other args are present\n        self.message = str(args[0])\n    else:  # Fallback if no message-like argument is provided\n        self.message = self.__class__.__name__\n</code></pre>"},{"location":"reference/serv/exceptions/#serv.exceptions.HTTPMethodNotAllowedException","title":"HTTPMethodNotAllowedException","text":"<pre><code>HTTPMethodNotAllowedException(\n    message: str, allowed_methods: list[str]\n)\n</code></pre> <p>               Bases: <code>ServException</code></p> <p>Raised when a route exists but doesn't support the requested HTTP method (HTTP 405).</p> <p>This exception is automatically raised when a route is found but the specific HTTP method (GET, POST, etc.) is not implemented by the route handler.</p> <p>Attributes:</p> Name Type Description <code>allowed_methods</code> <p>List of HTTP methods that are supported by the route.</p> <p>Examples:</p> <p>Automatic usage by router:</p> <pre><code># If a route only supports GET but receives POST\n# -&gt; HTTPMethodNotAllowedException with allowed_methods=[\"GET\"]\n</code></pre> <p>Manual usage in route handlers:</p> <pre><code>from serv.exceptions import HTTPMethodNotAllowedException\n\nclass ApiRoute(Route):\n    async def handle_get(self, request: GetRequest):\n        if not self.is_read_only_mode():\n            return {\"data\": \"some data\"}\n        else:\n            raise HTTPMethodNotAllowedException(\n                \"API is in read-only mode\",\n                allowed_methods=[\"GET\"]\n            )\n</code></pre> Source code in <code>serv/exceptions.py</code> <pre><code>def __init__(self, message: str, allowed_methods: list[str]):\n    super().__init__(message)\n    self.allowed_methods = allowed_methods\n</code></pre>"},{"location":"reference/serv/exceptions/#serv.exceptions.HTTPNotFoundException","title":"HTTPNotFoundException","text":"<pre><code>HTTPNotFoundException(message: str | None = None, *args)\n</code></pre> <p>               Bases: <code>ServException</code></p> <p>Raised when a requested route or resource is not found (HTTP 404).</p> <p>This exception is automatically raised by the router when no matching route is found for the requested path. It can also be raised manually in route handlers when a specific resource is not found.</p> <p>Examples:</p> <p>Automatic usage by router:</p> <pre><code># GET /nonexistent-path -&gt; HTTPNotFoundException\n</code></pre> <p>Manual usage in route handlers:</p> <pre><code>from serv.routes import Route, GetRequest\nfrom serv.exceptions import HTTPNotFoundException\n\nclass UserRoute(Route):\n    async def handle_get(self, request: GetRequest):\n        user_id = request.path_params.get(\"id\")\n        user = await self.get_user(user_id)\n        if not user:\n            raise HTTPNotFoundException(f\"User {user_id} not found\")\n        return user\n</code></pre> Source code in <code>serv/exceptions.py</code> <pre><code>def __init__(self, message: str | None = None, *args):\n    super().__init__(message, *args)  # Pass message to parent Exception\n    # Set self.message: use provided message, or if None, try to use the first arg (if any)\n    # or fall back to a default string representation of the class name.\n    if message is not None:\n        self.message = message\n    elif args and args[0]:  # If message is None but other args are present\n        self.message = str(args[0])\n    else:  # Fallback if no message-like argument is provided\n        self.message = self.__class__.__name__\n</code></pre>"},{"location":"reference/serv/exceptions/#serv.exceptions.ServException","title":"ServException","text":"<pre><code>ServException(message: str | None = None, *args)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception class for all Serv application errors.</p> <p>This is the root exception class for the Serv framework. All framework-specific exceptions inherit from this class, providing a consistent interface for error handling and HTTP status code mapping.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <p>HTTP status code associated with this exception (default: 500).</p> <code>message</code> <code>str</code> <p>Human-readable error message.</p> <p>Examples:</p> <p>Creating custom exceptions:</p> <pre><code>class ValidationError(ServException):\n    status_code = 400\n\n    def __init__(self, field: str, value: str):\n        super().__init__(f\"Invalid value '{value}' for field '{field}'\")\n        self.field = field\n        self.value = value\n\nclass AuthenticationError(ServException):\n    status_code = 401\n\n    def __init__(self, message: str = \"Authentication required\"):\n        super().__init__(message)\n</code></pre> <p>Using in route handlers:</p> <pre><code>from serv.routes import Route, PostRequest\nfrom serv.exceptions import HTTPBadRequestException\n\nclass UserRoute(Route):\n    async def handle_post(self, request: PostRequest):\n        data = await request.json()\n        if not data.get(\"email\"):\n            raise HTTPBadRequestException(\"Email is required\")\n        # Process user creation...\n</code></pre> <p>Handling in error handlers:</p> <pre><code>from bevy import injectable, Inject\n\n@injectable\nasync def custom_error_handler(\n    error: ServException,\n    response: Inject[ResponseBuilder]\n):\n    response.set_status(error.status_code)\n    response.content_type(\"application/json\")\n    response.body({\n        \"error\": error.message,\n        \"status_code\": error.status_code\n    })\n\napp.add_error_handler(ServException, custom_error_handler)\n</code></pre> Source code in <code>serv/exceptions.py</code> <pre><code>def __init__(self, message: str | None = None, *args):\n    super().__init__(message, *args)  # Pass message to parent Exception\n    # Set self.message: use provided message, or if None, try to use the first arg (if any)\n    # or fall back to a default string representation of the class name.\n    if message is not None:\n        self.message = message\n    elif args and args[0]:  # If message is None but other args are present\n        self.message = str(args[0])\n    else:  # Fallback if no message-like argument is provided\n        self.message = self.__class__.__name__\n</code></pre>"},{"location":"reference/serv/injectors/","title":"injectors","text":""},{"location":"reference/serv/injectors/#serv.injectors","title":"serv.injectors","text":""},{"location":"reference/serv/injectors/#serv.injectors.inject_websocket_object","title":"inject_websocket_object","text":"<pre><code>inject_websocket_object(\n    container: Inject[Container], annotation: Any\n) -&gt; Optional[Any]\n</code></pre> <p>Inject WebSocket instances with proper frame type configuration.</p> <p>Handles both plain WebSocket injection and Annotated[WebSocket, FrameType.X] patterns.</p> Source code in <code>serv/injectors.py</code> <pre><code>@hooks.CREATE_INSTANCE\n@injectable\ndef inject_websocket_object(\n    container: Inject[Container], annotation: Any\n) -&gt; Optional[Any]:\n    \"\"\"Inject WebSocket instances with proper frame type configuration.\n\n    Handles both plain WebSocket injection and Annotated[WebSocket, FrameType.X] patterns.\n    \"\"\"\n    from serv.websocket import FrameType, WebSocket\n\n    # Handle plain WebSocket type\n    if isinstance(annotation, type) and issubclass(annotation, WebSocket):\n        if websocket := container.get_optional(annotation):\n            return websocket\n\n    # Handle Annotated[WebSocket, FrameType.X] pattern\n    origin = get_origin(annotation)\n    if origin is Annotated:\n        args = get_args(annotation)\n        if (\n            len(args) &gt;= 2\n            and isinstance(args[0], type)\n            and issubclass(args[0], WebSocket)\n        ):\n            websocket_opt = container.get(WebSocket)\n            if websocket_opt:\n                websocket = websocket_opt.unwrap()\n\n                # Check for FrameType annotation and update if needed\n                for annotation_arg in args[1:]:\n                    if isinstance(annotation_arg, FrameType):\n                        websocket.frame_type = annotation_arg\n                        break\n\n                return Optional.Some(websocket)\n\n    return Optional.Nothing()\n</code></pre>"},{"location":"reference/serv/multipart_parser/","title":"multipart_parser","text":""},{"location":"reference/serv/multipart_parser/#serv.multipart_parser","title":"serv.multipart_parser","text":""},{"location":"reference/serv/multipart_parser/#serv.multipart_parser.MultipartParser","title":"MultipartParser","text":"<pre><code>MultipartParser(\n    boundary: bytes,\n    charset: str = \"utf-8\",\n    config: dict[str, int] | None = None,\n)\n</code></pre> <p>An asynchronous streaming multipart/form-data parser using python_multipart.multipart.MultipartParser.</p> <p>This parser processes a multipart body stream obtained via an ASGI receive callable and returns a dictionary of fields and files. ParsedFileUpload instances capture individual file details, including their content_type and all headers associated with their part.</p> Source code in <code>serv/multipart_parser.py</code> <pre><code>def __init__(\n    self,\n    boundary: bytes,\n    charset: str = \"utf-8\",\n    config: dict[str, int] | None = None,\n):\n    if not boundary:\n        raise ValueError(\"Boundary is required for MultipartParser\")\n    self.boundary = boundary\n    self.charset = charset\n\n    current_config = DEFAULT_MULTIPART_CONFIG.copy()\n    if config:\n        current_config.update(config)\n\n    self._max_header_name_size = current_config[\"max_header_name_size\"]\n    self._max_header_value_size = current_config[\"max_header_value_size\"]\n    self._max_headers_per_part = current_config[\"max_headers_per_part\"]\n    self._max_file_size = current_config[\"max_file_size\"]\n    self._max_num_files = current_config[\"max_num_files\"]\n    self._max_total_body_size = current_config[\"max_total_body_size\"]\n\n    self._callbacks = {\n        \"on_part_begin\": self._on_part_begin,\n        \"on_part_data\": self._on_part_data,\n        \"on_part_end\": self._on_part_end,\n        \"on_header_begin\": self._on_header_begin,\n        \"on_header_field\": self._on_header_field,\n        \"on_header_value\": self._on_header_value,\n        \"on_header_end\": self._on_header_end,\n        \"on_headers_finished\": self._on_headers_finished,\n        \"on_end\": self._on_end,\n    }\n    # The low_level_parser is re-initialized in each parse call\n    # to ensure it's fresh, as it's stateful.\n    self._low_level_parser: PBaseParser | None = None\n\n    # --- Results storage ---\n    self.fields: dict[str, list[str]] = defaultdict(list)\n    self.files: dict[str, list[ParsedFileUpload]] = defaultdict(\n        list\n    )  # Use ParsedFileUpload\n\n    # --- Current part processing state ---\n    self._current_part_headers: dict[str, str] = {}\n    self._current_part_name: str | None = None\n    self._current_part_filename: str | None = None\n    self._current_part_content_type: str | None = None\n    self._current_part_data_buffer: io.BytesIO | None = None\n    self._current_headers_count_in_part: int = 0  # For max_headers_per_part\n    self._is_file_part: bool = False\n\n    # --- Current header processing state ---\n    self._current_header_name_buffer: bytearray = bytearray()\n    self._current_header_value_buffer: bytearray = bytearray()\n</code></pre>"},{"location":"reference/serv/multipart_parser/#serv.multipart_parser.MultipartParser.parse","title":"parse  <code>async</code>","text":"<pre><code>parse(\n    receive: Callable[[], Awaitable[dict[str, Any]]],\n) -&gt; dict[str, list[str | ParsedFileUpload]]\n</code></pre> <p>Asynchronously parses multipart/form-data from an ASGI receive callable.</p> <p>Parameters:</p> Name Type Description Default <code>receive</code> <code>Callable[[], Awaitable[dict[str, Any]]]</code> <p>An ASGI receive callable.</p> required <p>Returns:</p> Type Description <code>dict[str, list[str | ParsedFileUpload]]</code> <p>A dictionary where keys are field names and values are lists of</p> <code>dict[str, list[str | ParsedFileUpload]]</code> <p>strings (for regular fields) or ParsedFileUpload instances (for files).</p> Source code in <code>serv/multipart_parser.py</code> <pre><code>async def parse(\n    self, receive: Callable[[], Awaitable[dict[str, Any]]]\n) -&gt; dict[str, list[str | ParsedFileUpload]]:\n    \"\"\"\n    Asynchronously parses multipart/form-data from an ASGI receive callable.\n\n    Args:\n        receive: An ASGI receive callable.\n\n    Returns:\n        A dictionary where keys are field names and values are lists of\n        strings (for regular fields) or ParsedFileUpload instances (for files).\n    \"\"\"\n    self.fields.clear()\n    self.files.clear()\n\n    # Initialize the low-level parser for this parse operation\n    self._low_level_parser = PBaseParser(self.boundary, self._callbacks)\n    self._total_body_bytes_received = 0\n    self._total_files_count = 0  # Reset for this parse call\n\n    more_body = True\n    while more_body:\n        message = await receive()\n        if message[\"type\"] != \"http.request\":\n            # This shouldn't happen if called correctly within an ASGI request cycle\n            # for the body, but handle defensively.\n            # Could raise an error or log. For now, break.\n            break\n\n        body_chunk = message.get(\"body\", b\"\")\n        if body_chunk:\n            self._total_body_bytes_received += len(body_chunk)\n            if self._total_body_bytes_received &gt; self._max_total_body_size:\n                raise MultipartParserError(\n                    f\"Total request body size exceeds maximum of {self._max_total_body_size} bytes.\"\n                )\n            self._low_level_parser.write(body_chunk)\n\n        more_body = message.get(\"more_body\", False)\n\n    self._low_level_parser.finalize()\n\n    result: dict[str, list[Any]] = defaultdict(list)\n    for name, values_list in self.fields.items():\n        result[name].extend(values_list)\n    for name, file_uploads_list in self.files.items():\n        result[name].extend(file_uploads_list)\n\n    return dict(result)\n</code></pre>"},{"location":"reference/serv/multipart_parser/#serv.multipart_parser.MultipartParserError","title":"MultipartParserError","text":"<p>               Bases: <code>ValueError</code></p> <p>Custom exception for multipart parsing errors.</p>"},{"location":"reference/serv/protocols/","title":"protocols","text":""},{"location":"reference/serv/protocols/#serv.protocols","title":"serv.protocols","text":"<p>Protocol definitions for Serv framework.</p> <p>This module defines abstract protocols to break circular dependencies between core modules while maintaining type safety and clear interfaces.</p>"},{"location":"reference/serv/protocols/#serv.protocols.AppContextProtocol","title":"AppContextProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for application context.</p>"},{"location":"reference/serv/protocols/#serv.protocols.AppContextProtocol.add_extension","title":"add_extension  <code>abstractmethod</code>","text":"<pre><code>add_extension(extension: Any) -&gt; None\n</code></pre> <p>Add extension to app.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef add_extension(self, extension: Any) -&gt; None:\n    \"\"\"Add extension to app.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.AppContextProtocol.get_extension","title":"get_extension  <code>abstractmethod</code>","text":"<pre><code>get_extension(name: str) -&gt; Any\n</code></pre> <p>Get extension by name.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef get_extension(self, name: str) -&gt; Any:\n    \"\"\"Get extension by name.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.AppContextProtocol.on_shutdown","title":"on_shutdown  <code>abstractmethod</code>","text":"<pre><code>on_shutdown(callback: Callable[[], Any]) -&gt; None\n</code></pre> <p>Register a shutdown callback.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef on_shutdown(self, callback: Callable[[], Any]) -&gt; None:\n    \"\"\"Register a shutdown callback.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.ContainerProtocol","title":"ContainerProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for dependency injection container.</p>"},{"location":"reference/serv/protocols/#serv.protocols.ContainerProtocol.call","title":"call  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>call(func: Callable, *args, **kwargs) -&gt; Any\n</code></pre> <p>Call a function with dependency injection.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\nasync def call(self, func: Callable, *args, **kwargs) -&gt; Any:\n    \"\"\"Call a function with dependency injection.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.ContainerProtocol.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(type_: type) -&gt; Any\n</code></pre> <p>Get an instance of the requested type.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef get(self, type_: type) -&gt; Any:\n    \"\"\"Get an instance of the requested type.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.ContainerProtocol.register","title":"register  <code>abstractmethod</code>","text":"<pre><code>register(type_: type, instance: Any) -&gt; None\n</code></pre> <p>Register a type with an instance.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef register(self, type_: type, instance: Any) -&gt; None:\n    \"\"\"Register a type with an instance.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.EventEmitterProtocol","title":"EventEmitterProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for event emission capabilities.</p>"},{"location":"reference/serv/protocols/#serv.protocols.EventEmitterProtocol.emit","title":"emit  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>emit(event: str, **kwargs) -&gt; None\n</code></pre> <p>Emit an event with optional parameters.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\nasync def emit(self, event: str, **kwargs) -&gt; None:\n    \"\"\"Emit an event with optional parameters.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.ExtensionSpecProtocol","title":"ExtensionSpecProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for extension specifications.</p>"},{"location":"reference/serv/protocols/#serv.protocols.ExtensionSpecProtocol.load","title":"load  <code>abstractmethod</code>","text":"<pre><code>load() -&gt; Any\n</code></pre> <p>Load the extension.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef load(self) -&gt; Any:\n    \"\"\"Load the extension.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.ResponseBuilderProtocol","title":"ResponseBuilderProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for response building.</p>"},{"location":"reference/serv/protocols/#serv.protocols.ResponseBuilderProtocol.add_header","title":"add_header  <code>abstractmethod</code>","text":"<pre><code>add_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add response header.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef add_header(self, name: str, value: str) -&gt; None:\n    \"\"\"Add response header.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.ResponseBuilderProtocol.body","title":"body  <code>abstractmethod</code>","text":"<pre><code>body(content: Any) -&gt; None\n</code></pre> <p>Set response body.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef body(self, content: Any) -&gt; None:\n    \"\"\"Set response body.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.ResponseBuilderProtocol.set_status","title":"set_status  <code>abstractmethod</code>","text":"<pre><code>set_status(status_code: int) -&gt; None\n</code></pre> <p>Set response status code.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef set_status(self, status_code: int) -&gt; None:\n    \"\"\"Set response status code.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.RouterProtocol","title":"RouterProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for request routing capabilities.</p>"},{"location":"reference/serv/protocols/#serv.protocols.RouterProtocol.add_route","title":"add_route  <code>abstractmethod</code>","text":"<pre><code>add_route(\n    path: str, handler: Any, methods: list[str] = None\n) -&gt; None\n</code></pre> <p>Add a route to the router.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef add_route(self, path: str, handler: Any, methods: list[str] = None) -&gt; None:\n    \"\"\"Add a route to the router.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.RouterProtocol.mount","title":"mount  <code>abstractmethod</code>","text":"<pre><code>mount(path: str, sub_router: RouterProtocol) -&gt; None\n</code></pre> <p>Mount a sub-router at the given path.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef mount(self, path: str, sub_router: \"RouterProtocol\") -&gt; None:\n    \"\"\"Mount a sub-router at the given path.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/protocols/#serv.protocols.RouterProtocol.resolve_route","title":"resolve_route  <code>abstractmethod</code>","text":"<pre><code>resolve_route(method: str, path: str) -&gt; Any\n</code></pre> <p>Resolve a route handler for method and path.</p> Source code in <code>serv/protocols.py</code> <pre><code>@abstractmethod\ndef resolve_route(self, method: str, path: str) -&gt; Any:\n    \"\"\"Resolve a route handler for method and path.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/serv/requests/","title":"requests","text":""},{"location":"reference/serv/requests/#serv.requests","title":"serv.requests","text":""},{"location":"reference/serv/requests/#serv.requests.Request","title":"Request","text":"<pre><code>Request(scope, receive)\n</code></pre> <p>HTTP request object providing access to request data and parsing utilities.</p> <p>The Request class encapsulates all information about an incoming HTTP request, including headers, body, query parameters, cookies, and provides methods for parsing different content types like JSON, form data, and file uploads.</p> <p>This class is automatically injected into route handlers through the dependency injection system, so you typically don't need to instantiate it directly.</p> <p>Examples:</p> <p>Basic request handling:</p> <pre><code>from serv.routes import Route, GetRequest, PostRequest\nfrom serv.responses import JsonResponse\nfrom typing import Annotated\n\nclass ApiRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        # Access query parameters\n        user_id = request.query_params.get(\"user_id\")\n        page = int(request.query_params.get(\"page\", \"1\"))\n\n        # Access headers\n        auth_token = request.headers.get(\"authorization\")\n\n        return {\"user_id\": user_id, \"page\": page}\n\n    async def handle_post(self, request: PostRequest) -&gt; Annotated[dict, JsonResponse]:\n        # Parse JSON body\n        data = await request.json()\n\n        # Access cookies\n        session_id = request.cookies.get(\"session_id\")\n\n        return {\"received\": data, \"session\": session_id}\n</code></pre> <p>Form data handling:</p> <pre><code>from serv.routes import Form\n\nclass UserForm(Form):\n    name: str\n    email: str\n    age: int\n\nclass UserRoute(Route):\n    async def handle_post(self, request: PostRequest):\n        # Parse form data into a model\n        form_data = await request.form(UserForm)\n\n        # Access typed form fields\n        print(f\"Name: {form_data.name}, Age: {form_data.age}\")\n\n        return {\"status\": \"success\"}\n</code></pre> <p>File upload handling:</p> <pre><code>class UploadRoute(Route):\n    async def handle_post(self, request: PostRequest):\n        # Parse multipart form data\n        form_data = await request.form()\n\n        # Access uploaded files\n        if \"avatar\" in form_data:\n            file_upload = form_data[\"avatar\"]\n            filename = file_upload.filename\n            content = await file_upload.read()\n\n            # Save file or process content\n            with open(f\"uploads/{filename}\", \"wb\") as f:\n                f.write(content)\n\n        return {\"status\": \"uploaded\"}\n</code></pre> <p>Raw body access:</p> <pre><code>class WebhookRoute(Route):\n    async def handle_post(self, request: PostRequest):\n        # Get raw body bytes\n        raw_body = await request.body()\n\n        # Or stream large bodies\n        chunks = []\n        async for chunk in request.read(max_size=1024*1024):  # 1MB chunks\n            chunks.append(chunk)\n\n        return {\"received_bytes\": len(raw_body)}\n</code></pre> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>HTTP method (GET, POST, etc.)</p> <code>path</code> <code>str</code> <p>Request path without query string</p> <code>query_string</code> <code>str</code> <p>Raw query string</p> <code>query_params</code> <code>dict</code> <p>Parsed query parameters as dict</p> <code>headers</code> <code>dict</code> <p>Request headers as dict (lowercase keys)</p> <code>cookies</code> <code>dict</code> <p>Parsed cookies as dict</p> <code>scheme</code> <code>str</code> <p>URL scheme (http, https)</p> <code>client</code> <p>Client address information</p> <code>server</code> <p>Server address information</p> <code>http_version</code> <code>str</code> <p>HTTP version string</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/requests/#serv.requests.Request.body","title":"body  <code>async</code>","text":"<pre><code>body(max_size: int = 10 * 1024 * 1024) -&gt; bytes\n</code></pre> <p>Returns the request body as bytes up to max_size (default 10MB). Aggregates chunks from the read() stream.</p> Source code in <code>serv/requests.py</code> <pre><code>async def body(self, max_size: int = 10 * 1024 * 1024) -&gt; bytes:\n    \"\"\"\n    Returns the request body as bytes up to max_size (default 10MB).\n    Aggregates chunks from the read() stream.\n    \"\"\"\n    body_bytes = bytearray()\n    async for chunk in self.read(max_size=max_size):\n        body_bytes.extend(chunk)\n    return bytes(body_bytes)\n</code></pre>"},{"location":"reference/serv/requests/#serv.requests.Request.read","title":"read  <code>async</code>","text":"<pre><code>read(max_size: int = -1)\n</code></pre> <p>Async generator yielding chunks of the request body as bytes.</p> <p>Stops when no more chunks are available. If max_size is set, it only yields that many bytes across all yielded chunks.</p> <p>This method raises a RuntimeError if the body has been fully consumed.</p> Source code in <code>serv/requests.py</code> <pre><code>async def read(self, max_size: int = -1):\n    \"\"\"\n    Async generator yielding chunks of the request body as bytes.\n\n    Stops when no more chunks are available. If max_size is set, it only yields that many bytes\n    across all yielded chunks.\n\n    This method raises a RuntimeError if the body has been fully consumed.\n    \"\"\"\n    if self._body_consumed and not self._buffer:\n        raise RuntimeError(\"Request body already consumed\")\n\n    total_read = 0\n    while not self._body_consumed or self._buffer:\n        if not self._body_consumed and (\n            not self._buffer or total_read + len(self._buffer) &lt; max_size\n            if max_size &gt; 0\n            else True\n        ):\n            message = await self._receive()\n            if message[\"type\"] != \"http.request\":\n                break\n\n            self._buffer.extend(message.get(\"body\", b\"\"))\n            self._body_consumed = not message.get(\"more_body\", False)\n\n        if max_size &lt;= 0 or total_read + len(self._buffer) &lt;= max_size:\n            yield self._buffer\n            total_read += len(self._buffer)\n            self._buffer.clear()\n        else:  # max_size &gt; 0 and total_read + len(self._buffer) &gt; max_size\n            can_yield = max_size - total_read\n            yield self._buffer[:can_yield]\n            self._buffer = self._buffer[can_yield:]\n            total_read = max_size  # or total_read += can_yield\n            break\n</code></pre>"},{"location":"reference/serv/responses/","title":"responses","text":""},{"location":"reference/serv/responses/#serv.responses","title":"serv.responses","text":""},{"location":"reference/serv/responses/#serv.responses.ResponseBuilder","title":"ResponseBuilder","text":"<pre><code>ResponseBuilder(send_callable)\n</code></pre> <p>Builder for constructing HTTP responses in Serv applications.</p> <pre><code>The ResponseBuilder provides a fluent interface for building HTTP responses,\nincluding setting status codes, headers, cookies, and response bodies. It\nsupports streaming responses, various content types, and automatic encoding.\n\nThe ResponseBuilder is automatically injected into route handlers and middleware\nthrough the dependency injection system, so you typically don't need to\ninstantiate it directly.\n\nFeatures:\n- Fluent API for chaining method calls\n- Automatic content-type detection and encoding\n- Cookie management (set, delete)\n- Header manipulation\n- Streaming response support\n- Redirect helpers\n- Multiple body content types (str, bytes, iterables, async iterables)\n\nExamples:\n    Basic response:\n\n    ```python\n    from serv.http.responses import ResponseBuilder\n    from bevy import injectable, Inject\n\n    @injectable\n    async def my_handler(response: Inject[ResponseBuilder]):\n        response.set_status(200)\n        response.content_type(\"text/plain\")\n        response.body(\"Hello, World!\")\n    ```\n\n    JSON response:\n\n    ```python\n    import json\n\n    @injectable\n    async def api_handler(response: Inject[ResponseBuilder]):\n        data = {\"message\": \"Hello\", \"status\": \"success\"}\n        response.set_status(200)\n        response.content_type(\"application/json\")\n        response.body(json.dumps(data))\n    ```\n\n    HTML response with headers:\n\n    ```python\n    @injectable\n    async def html_handler(response: Inject[ResponseBuilder]):\n        html = \"&lt;h1&gt;Welcome&lt;/h1&gt;&lt;p&gt;This is a test page.&lt;/p&gt;\"\n        response.set_status(200)\n        response.content_type(\"text/html\")\n        response.add_header(\"X-Custom-Header\", \"MyValue\")\n        response.body(html)\n    ```\n\n    Redirect response:\n\n    ```python\n    @injectable\n    async def redirect_handler(response: Inject[ResponseBuilder]):\n        response.redirect(\"/new-location\", status_code=301)\n    ```\n\n    Cookie management:\n\n    ```python\n    @injectable\n    async def cookie_handler(response: Inject[ResponseBuilder]):\n        response.set_cookie(\"session_id\", \"abc123\", max_age=3600, httponly=True)\n        response.set_cookie(\"theme\", \"dark\", path=\"/\", secure=True)\n        response.body(\"Cookies set!\")\n    ```\n\n    Streaming response:\n\n    ```python\n    @injectable\n    async def stream_handler(response: Inject[ResponseBuilder]):\n        response.content_type(\"text/plain\")\n\n        # Add multiple body components\n        response.body(\"Starting stream...\n</code></pre> <p>\")             response.body(\"Processing data... \")</p> <pre><code>        # Add async iterable\n        async def data_generator():\n            for i in range(5):\n                yield f\"Item {i}\n</code></pre> <p>\"                     await asyncio.sleep(0.1)</p> <pre><code>        response.body(data_generator())\n        response.body(\"Stream complete!\")\n    ```\n\n    Chained method calls:\n\n    ```python\n    @injectable\n    async def chained_handler(response: Inject[ResponseBuilder]):\n        (response\n            .set_status(201)\n            .content_type(\"application/json\")\n            .add_header(\"Location\", \"/api/users/123\")\n            .set_cookie(\"last_action\", \"create_user\")\n            .body('{\"id\": 123, \"name\": \"John Doe\"}'))\n    ```\n\nNote:\n    The ResponseBuilder automatically handles encoding, content-length calculation,\n    and proper ASGI message formatting. Once `send_response()` is called (which\n    happens automatically at the end of request processing), no further\n    modifications can be made to the response.\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def __init__(self, send_callable):\n    self._send = send_callable\n\n    self._status = 200\n    self._headers = []  # List of (name_bytes, value_bytes)\n    self._body_components = []\n    self._headers_sent = False\n    self._default_encoding = \"utf-8\"\n    self._has_content_type = False\n</code></pre>"},{"location":"reference/serv/responses/#serv.responses.ResponseBuilder.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clears the response body and headers. This is useful for error handlers. It cannot change anything that has already been sent, it only affects future sends and is intended to be used before send_response() has been called.</p> Source code in <code>serv/http/responses.py</code> <pre><code>def clear(self):\n    \"\"\"Clears the response body and headers. This is useful for error handlers. It cannot change\n    anything that has already been sent, it only affects future sends and is intended to be used\n    before send_response() has been called.\"\"\"\n    self._body_components = []\n    self._headers = []\n    self._status = 200\n    return self\n</code></pre>"},{"location":"reference/serv/responses/#serv.responses.ResponseBuilder.content_type","title":"content_type","text":"<pre><code>content_type(ctype: str, charset: str | None = None)\n</code></pre> <p>Set the Content-Type header for the response.</p> <p>Parameters:</p> Name Type Description Default <code>ctype</code> <code>str</code> <p>MIME type (e.g., \"text/html\", \"application/json\").</p> required <code>charset</code> <code>str | None</code> <p>Character encoding. Defaults to \"utf-8\" if not specified.</p> <code>None</code> <p>Returns:</p> Type Description <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If headers have already been sent.</p> <p>Examples:</p> <pre><code>response.content_type(\"text/html\")\nresponse.content_type(\"application/json\")\nresponse.content_type(\"text/plain\", charset=\"iso-8859-1\")\nresponse.content_type(\"image/png\")  # No charset for binary content\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def content_type(self, ctype: str, charset: str | None = None):\n    \"\"\"Set the Content-Type header for the response.\n\n    Args:\n        ctype: MIME type (e.g., \"text/html\", \"application/json\").\n        charset: Character encoding. Defaults to \"utf-8\" if not specified.\n\n    Returns:\n        Self for method chaining.\n\n    Raises:\n        RuntimeError: If headers have already been sent.\n\n    Examples:\n        ```python\n        response.content_type(\"text/html\")\n        response.content_type(\"application/json\")\n        response.content_type(\"text/plain\", charset=\"iso-8859-1\")\n        response.content_type(\"image/png\")  # No charset for binary content\n        ```\n    \"\"\"\n    if self._headers_sent:\n        raise RuntimeError(\"Cannot set content_type after headers have been sent.\")\n    if charset is None:\n        charset = self._default_encoding\n    # Remove existing Content-Type headers before adding the new one to avoid duplicates\n    self._headers = [h for h in self._headers if h[0] != b\"content-type\"]\n    self.add_header(\"Content-Type\", f\"{ctype}; charset={charset}\")\n    self._has_content_type = True  # Explicitly set true by this method\n    return self\n</code></pre>"},{"location":"reference/serv/responses/#serv.responses.ResponseBuilder.delete_cookie","title":"delete_cookie","text":"<pre><code>delete_cookie(\n    key: str,\n    path: str = \"/\",\n    domain: str | None = None,\n    secure: bool = False,\n    httponly: bool = False,\n    samesite: str = \"lax\",\n)\n</code></pre> <p>Instructs the client to delete a cookie by setting its Max-Age to 0 and an expiry date in the past.</p> Source code in <code>serv/http/responses.py</code> <pre><code>def delete_cookie(\n    self,\n    key: str,\n    path: str = \"/\",\n    domain: str | None = None,\n    secure: bool = False,\n    httponly: bool = False,\n    samesite: str = \"lax\",\n):\n    \"\"\"Instructs the client to delete a cookie by setting its Max-Age to 0 and an expiry date in the past.\"\"\"\n    # Setting Max-Age=0 is the primary method. Expires is a fallback.\n    # Use a known past date string for Expires for robustness.\n    past_expiry_date = \"Thu, 01 Jan 1970 00:00:00 GMT\"\n    self.set_cookie(\n        key,\n        value=\"\",\n        max_age=0,\n        path=path,\n        domain=domain,\n        expires=past_expiry_date,\n        secure=secure,\n        httponly=httponly,\n        samesite=samesite,\n    )\n    return self\n</code></pre>"},{"location":"reference/serv/responses/#serv.responses.ResponseBuilder.set_status","title":"set_status","text":"<pre><code>set_status(status_code: int)\n</code></pre> <p>Set the HTTP status code for the response.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int</code> <p>HTTP status code (e.g., 200, 404, 500).</p> required <p>Returns:</p> Type Description <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If headers have already been sent.</p> <p>Examples:</p> <pre><code>response.set_status(200)  # OK\nresponse.set_status(404)  # Not Found\nresponse.set_status(500)  # Internal Server Error\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def set_status(self, status_code: int):\n    \"\"\"Set the HTTP status code for the response.\n\n    Args:\n        status_code: HTTP status code (e.g., 200, 404, 500).\n\n    Returns:\n        Self for method chaining.\n\n    Raises:\n        RuntimeError: If headers have already been sent.\n\n    Examples:\n        ```python\n        response.set_status(200)  # OK\n        response.set_status(404)  # Not Found\n        response.set_status(500)  # Internal Server Error\n        ```\n    \"\"\"\n    if self._headers_sent:\n        raise RuntimeError(\"Cannot set status after headers have been sent.\")\n    self._status = status_code\n    return self\n</code></pre>"},{"location":"reference/serv/routes/","title":"routes","text":""},{"location":"reference/serv/routes/#serv.routes","title":"serv.routes","text":"<p>Legacy route exports for backward compatibility.</p> <p>All route functionality has been moved to specialized modules. This module provides re-exports for backward compatibility.</p>"},{"location":"reference/serv/routes/#serv.routes.DeleteRequest","title":"DeleteRequest","text":"<pre><code>DeleteRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP DELETE request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.FileUpload","title":"FileUpload  <code>dataclass</code>","text":"<pre><code>FileUpload(\n    filename: str | None,\n    content_type: str | None,\n    headers: dict[str, str],\n    file: IOBase,\n)\n</code></pre> <p>Represents an uploaded file from a multipart form.</p> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str | None</code> <p>Original filename from the client, if provided</p> <code>content_type</code> <code>str | None</code> <p>MIME type of the uploaded file</p> <code>headers</code> <code>dict[str, str]</code> <p>Additional headers from the multipart section</p> <code>file</code> <code>IOBase</code> <p>File-like object containing the uploaded data</p>"},{"location":"reference/serv/routes/#serv.routes.FileUpload.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the file handle.</p> Source code in <code>serv/http/forms.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the file handle.\"\"\"\n    return self.file.close()\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.FileUpload.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; bytes\n</code></pre> <p>Read the entire content of the uploaded file.</p> Source code in <code>serv/http/forms.py</code> <pre><code>async def read(self) -&gt; bytes:\n    \"\"\"Read the entire content of the uploaded file.\"\"\"\n    return self.file.read()\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.FileUpload.seek","title":"seek  <code>async</code>","text":"<pre><code>seek(offset: int) -&gt; int\n</code></pre> <p>Seek to a specific position in the file.</p> Source code in <code>serv/http/forms.py</code> <pre><code>async def seek(self, offset: int) -&gt; int:\n    \"\"\"Seek to a specific position in the file.\"\"\"\n    return self.file.seek(offset)\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.Form","title":"Form","text":"<p>Base class for defining form models with automatic validation.</p> <p>Form classes define the expected structure and types of form data. They provide validation and type checking capabilities for HTTP form submissions.</p> <p>Attributes:</p> Name Type Description <code>__form_method__</code> <p>HTTP method this form accepts (defaults to \"POST\")</p> <p>Examples:</p> <p>Basic form definition:</p> <pre><code>from serv.http.forms import Form\n\nclass ContactForm(Form):\n    name: str\n    email: str\n    message: str\n    newsletter: bool = False  # Optional field\n</code></pre> <p>Form with custom method:</p> <pre><code>class SearchForm(Form):\n    __form_method__ = \"GET\"\n\n    query: str\n    category: str | None = None\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.Form.matches_form_data","title":"matches_form_data  <code>classmethod</code>","text":"<pre><code>matches_form_data(form_data: dict[str, Any]) -&gt; bool\n</code></pre> <p>Check if form data matches this form's structure and types.</p> <p>Parameters:</p> Name Type Description Default <code>form_data</code> <code>dict[str, Any]</code> <p>Dictionary of form field names to values</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the form data is valid for this form class</p> Source code in <code>serv/http/forms.py</code> <pre><code>@classmethod\ndef matches_form_data(cls, form_data: dict[str, Any]) -&gt; bool:\n    \"\"\"Check if form data matches this form's structure and types.\n\n    Args:\n        form_data: Dictionary of form field names to values\n\n    Returns:\n        True if the form data is valid for this form class\n    \"\"\"\n    annotations = get_annotations(cls)\n\n    allowed_keys = set(annotations.keys())\n    required_keys = {\n        key for key, value in annotations.items() if not is_optional(value)\n    }\n\n    form_data_keys = set(form_data.keys())\n    has_missing_required_keys = required_keys - form_data_keys\n    has_extra_keys = form_data_keys &gt; allowed_keys\n    if has_missing_required_keys or has_extra_keys:\n        return False  # Form data keys do not match the expected keys\n\n    for key, value in annotations.items():\n        optional = key not in required_keys\n        if key not in form_data and not optional:\n            return False\n\n        allowed_types = get_args(value)\n        if not allowed_types:\n            allowed_types = [value]\n\n        if get_origin(value) is list and not all(\n            _is_valid_type(item, allowed_types) for item in form_data[key]\n        ):\n            return False\n\n        if key in form_data and not _is_valid_type(\n            form_data[key][0], allowed_types\n        ):\n            return False\n\n    return True  # All fields match\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.GetRequest","title":"GetRequest","text":"<pre><code>GetRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP GET request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.HeadRequest","title":"HeadRequest","text":"<pre><code>HeadRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP HEAD request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.OptionsRequest","title":"OptionsRequest","text":"<pre><code>OptionsRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP OPTIONS request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.PatchRequest","title":"PatchRequest","text":"<pre><code>PatchRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP PATCH request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.PostRequest","title":"PostRequest","text":"<pre><code>PostRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP POST request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.PutRequest","title":"PutRequest","text":"<pre><code>PutRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP PUT request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.ResponseBuilder","title":"ResponseBuilder","text":"<pre><code>ResponseBuilder(send_callable)\n</code></pre> <p>Builder for constructing HTTP responses in Serv applications.</p> <pre><code>The ResponseBuilder provides a fluent interface for building HTTP responses,\nincluding setting status codes, headers, cookies, and response bodies. It\nsupports streaming responses, various content types, and automatic encoding.\n\nThe ResponseBuilder is automatically injected into route handlers and middleware\nthrough the dependency injection system, so you typically don't need to\ninstantiate it directly.\n\nFeatures:\n- Fluent API for chaining method calls\n- Automatic content-type detection and encoding\n- Cookie management (set, delete)\n- Header manipulation\n- Streaming response support\n- Redirect helpers\n- Multiple body content types (str, bytes, iterables, async iterables)\n\nExamples:\n    Basic response:\n\n    ```python\n    from serv.http.responses import ResponseBuilder\n    from bevy import injectable, Inject\n\n    @injectable\n    async def my_handler(response: Inject[ResponseBuilder]):\n        response.set_status(200)\n        response.content_type(\"text/plain\")\n        response.body(\"Hello, World!\")\n    ```\n\n    JSON response:\n\n    ```python\n    import json\n\n    @injectable\n    async def api_handler(response: Inject[ResponseBuilder]):\n        data = {\"message\": \"Hello\", \"status\": \"success\"}\n        response.set_status(200)\n        response.content_type(\"application/json\")\n        response.body(json.dumps(data))\n    ```\n\n    HTML response with headers:\n\n    ```python\n    @injectable\n    async def html_handler(response: Inject[ResponseBuilder]):\n        html = \"&lt;h1&gt;Welcome&lt;/h1&gt;&lt;p&gt;This is a test page.&lt;/p&gt;\"\n        response.set_status(200)\n        response.content_type(\"text/html\")\n        response.add_header(\"X-Custom-Header\", \"MyValue\")\n        response.body(html)\n    ```\n\n    Redirect response:\n\n    ```python\n    @injectable\n    async def redirect_handler(response: Inject[ResponseBuilder]):\n        response.redirect(\"/new-location\", status_code=301)\n    ```\n\n    Cookie management:\n\n    ```python\n    @injectable\n    async def cookie_handler(response: Inject[ResponseBuilder]):\n        response.set_cookie(\"session_id\", \"abc123\", max_age=3600, httponly=True)\n        response.set_cookie(\"theme\", \"dark\", path=\"/\", secure=True)\n        response.body(\"Cookies set!\")\n    ```\n\n    Streaming response:\n\n    ```python\n    @injectable\n    async def stream_handler(response: Inject[ResponseBuilder]):\n        response.content_type(\"text/plain\")\n\n        # Add multiple body components\n        response.body(\"Starting stream...\n</code></pre> <p>\")             response.body(\"Processing data... \")</p> <pre><code>        # Add async iterable\n        async def data_generator():\n            for i in range(5):\n                yield f\"Item {i}\n</code></pre> <p>\"                     await asyncio.sleep(0.1)</p> <pre><code>        response.body(data_generator())\n        response.body(\"Stream complete!\")\n    ```\n\n    Chained method calls:\n\n    ```python\n    @injectable\n    async def chained_handler(response: Inject[ResponseBuilder]):\n        (response\n            .set_status(201)\n            .content_type(\"application/json\")\n            .add_header(\"Location\", \"/api/users/123\")\n            .set_cookie(\"last_action\", \"create_user\")\n            .body('{\"id\": 123, \"name\": \"John Doe\"}'))\n    ```\n\nNote:\n    The ResponseBuilder automatically handles encoding, content-length calculation,\n    and proper ASGI message formatting. Once `send_response()` is called (which\n    happens automatically at the end of request processing), no further\n    modifications can be made to the response.\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def __init__(self, send_callable):\n    self._send = send_callable\n\n    self._status = 200\n    self._headers = []  # List of (name_bytes, value_bytes)\n    self._body_components = []\n    self._headers_sent = False\n    self._default_encoding = \"utf-8\"\n    self._has_content_type = False\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.ResponseBuilder.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clears the response body and headers. This is useful for error handlers. It cannot change anything that has already been sent, it only affects future sends and is intended to be used before send_response() has been called.</p> Source code in <code>serv/http/responses.py</code> <pre><code>def clear(self):\n    \"\"\"Clears the response body and headers. This is useful for error handlers. It cannot change\n    anything that has already been sent, it only affects future sends and is intended to be used\n    before send_response() has been called.\"\"\"\n    self._body_components = []\n    self._headers = []\n    self._status = 200\n    return self\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.ResponseBuilder.content_type","title":"content_type","text":"<pre><code>content_type(ctype: str, charset: str | None = None)\n</code></pre> <p>Set the Content-Type header for the response.</p> <p>Parameters:</p> Name Type Description Default <code>ctype</code> <code>str</code> <p>MIME type (e.g., \"text/html\", \"application/json\").</p> required <code>charset</code> <code>str | None</code> <p>Character encoding. Defaults to \"utf-8\" if not specified.</p> <code>None</code> <p>Returns:</p> Type Description <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If headers have already been sent.</p> <p>Examples:</p> <pre><code>response.content_type(\"text/html\")\nresponse.content_type(\"application/json\")\nresponse.content_type(\"text/plain\", charset=\"iso-8859-1\")\nresponse.content_type(\"image/png\")  # No charset for binary content\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def content_type(self, ctype: str, charset: str | None = None):\n    \"\"\"Set the Content-Type header for the response.\n\n    Args:\n        ctype: MIME type (e.g., \"text/html\", \"application/json\").\n        charset: Character encoding. Defaults to \"utf-8\" if not specified.\n\n    Returns:\n        Self for method chaining.\n\n    Raises:\n        RuntimeError: If headers have already been sent.\n\n    Examples:\n        ```python\n        response.content_type(\"text/html\")\n        response.content_type(\"application/json\")\n        response.content_type(\"text/plain\", charset=\"iso-8859-1\")\n        response.content_type(\"image/png\")  # No charset for binary content\n        ```\n    \"\"\"\n    if self._headers_sent:\n        raise RuntimeError(\"Cannot set content_type after headers have been sent.\")\n    if charset is None:\n        charset = self._default_encoding\n    # Remove existing Content-Type headers before adding the new one to avoid duplicates\n    self._headers = [h for h in self._headers if h[0] != b\"content-type\"]\n    self.add_header(\"Content-Type\", f\"{ctype}; charset={charset}\")\n    self._has_content_type = True  # Explicitly set true by this method\n    return self\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.ResponseBuilder.delete_cookie","title":"delete_cookie","text":"<pre><code>delete_cookie(\n    key: str,\n    path: str = \"/\",\n    domain: str | None = None,\n    secure: bool = False,\n    httponly: bool = False,\n    samesite: str = \"lax\",\n)\n</code></pre> <p>Instructs the client to delete a cookie by setting its Max-Age to 0 and an expiry date in the past.</p> Source code in <code>serv/http/responses.py</code> <pre><code>def delete_cookie(\n    self,\n    key: str,\n    path: str = \"/\",\n    domain: str | None = None,\n    secure: bool = False,\n    httponly: bool = False,\n    samesite: str = \"lax\",\n):\n    \"\"\"Instructs the client to delete a cookie by setting its Max-Age to 0 and an expiry date in the past.\"\"\"\n    # Setting Max-Age=0 is the primary method. Expires is a fallback.\n    # Use a known past date string for Expires for robustness.\n    past_expiry_date = \"Thu, 01 Jan 1970 00:00:00 GMT\"\n    self.set_cookie(\n        key,\n        value=\"\",\n        max_age=0,\n        path=path,\n        domain=domain,\n        expires=past_expiry_date,\n        secure=secure,\n        httponly=httponly,\n        samesite=samesite,\n    )\n    return self\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.ResponseBuilder.set_status","title":"set_status","text":"<pre><code>set_status(status_code: int)\n</code></pre> <p>Set the HTTP status code for the response.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int</code> <p>HTTP status code (e.g., 200, 404, 500).</p> required <p>Returns:</p> Type Description <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If headers have already been sent.</p> <p>Examples:</p> <pre><code>response.set_status(200)  # OK\nresponse.set_status(404)  # Not Found\nresponse.set_status(500)  # Internal Server Error\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def set_status(self, status_code: int):\n    \"\"\"Set the HTTP status code for the response.\n\n    Args:\n        status_code: HTTP status code (e.g., 200, 404, 500).\n\n    Returns:\n        Self for method chaining.\n\n    Raises:\n        RuntimeError: If headers have already been sent.\n\n    Examples:\n        ```python\n        response.set_status(200)  # OK\n        response.set_status(404)  # Not Found\n        response.set_status(500)  # Internal Server Error\n        ```\n    \"\"\"\n    if self._headers_sent:\n        raise RuntimeError(\"Cannot set status after headers have been sent.\")\n    self._status = status_code\n    return self\n</code></pre>"},{"location":"reference/serv/routes/#serv.routes.Route","title":"Route","text":"<p>Base class for creating HTTP route handlers in Serv applications.</p> <p>Route classes provide a structured way to handle HTTP requests by defining methods that correspond to HTTP methods (GET, POST, etc.) and form handlers. They support automatic request parsing, response type annotations, error handling, and dependency injection.</p> <p>The Route class automatically discovers handler methods based on their naming patterns and signatures: - Methods named <code>handle_&lt;method&gt;</code> become HTTP method handlers (e.g., <code>handle_get</code>, <code>handle_post</code>) - Methods with Form subclass parameters become form handlers - Methods with Exception parameters become error handlers - Return type annotations determine response wrapper classes - Handler selection is based on signature matching with request data</p> <p>Examples:</p> <p>Basic route with HTTP method handlers:</p> <pre><code>from serv.routes import Route\nfrom serv.responses import JsonResponse, TextResponse\nfrom serv.injectors import Query, Header\nfrom typing import Annotated\n\nclass UserRoute(Route):\n    async def handle_get(self, user_id: Annotated[str, Query(\"id\")]) -&gt; Annotated[dict, JsonResponse]:\n        return {\"id\": user_id, \"name\": \"John Doe\"}\n\n    async def handle_post(self, data: dict) -&gt; Annotated[str, TextResponse]:\n        # Create user logic here\n        return \"User created successfully\"\n</code></pre> <p>Route with multiple GET handlers based on parameters:</p> <pre><code>class ProductRoute(Route):\n    # Handler for requests with 'id' query parameter\n    async def handle_get(self, product_id: Annotated[str, Query(\"id\")]) -&gt; Annotated[dict, JsonResponse]:\n        return {\"id\": product_id, \"name\": \"Product Name\"}\n\n    # Handler for requests with 'category' query parameter\n    async def handle_get_by_category(self, category: Annotated[str, Query(\"category\")]) -&gt; Annotated[list, JsonResponse]:\n        return [{\"id\": 1, \"name\": \"Product 1\"}, {\"id\": 2, \"name\": \"Product 2\"}]\n\n    # Handler for requests with no specific parameters (fallback)\n    async def handle_get_all(self) -&gt; Annotated[list, JsonResponse]:\n        return [{\"id\": 1, \"name\": \"All Products\"}]\n</code></pre> <p>Route with form handling:</p> <pre><code>from serv.routes import Route, Form\nfrom serv.responses import HtmlResponse\nfrom typing import Annotated\n\nclass ContactForm(Form):\n    name: str\n    email: str\n    message: str\n\nclass ContactRoute(Route):\n    async def handle_get(self) -&gt; Annotated[str, HtmlResponse]:\n        return '''\n        &lt;form method=\"post\"&gt;\n            &lt;input name=\"name\" placeholder=\"Name\" required&gt;\n            &lt;input name=\"email\" type=\"email\" placeholder=\"Email\" required&gt;\n            &lt;textarea name=\"message\" placeholder=\"Message\" required&gt;&lt;/textarea&gt;\n            &lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n        &lt;/form&gt;\n        '''\n\n    async def handle_contact_form(self, form: ContactForm) -&gt; Annotated[str, HtmlResponse]:\n        # Process the form submission\n        await self.send_email(form.email, form.name, form.message)\n        return \"&lt;h1&gt;Thank you! Your message has been sent.&lt;/h1&gt;\"\n</code></pre> <p>Route with header and cookie injection:</p> <pre><code>from serv.injectors import Header, Cookie\n\nclass AuthRoute(Route):\n    async def handle_get(\n        self,\n        auth_token: Annotated[str, Header(\"Authorization\")],\n        session_id: Annotated[str, Cookie(\"session_id\")]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        # Validate token and session\n        return {\"authenticated\": True, \"user\": \"john_doe\"}\n</code></pre> Note <p>Route classes are automatically instantiated by the router when a matching request is received. Handler methods are selected based on the best match between the request data and the method's parameter signature. Methods with more specific parameter requirements will be preferred over generic handlers.</p>"},{"location":"reference/serv/routing/","title":"Routing","text":""},{"location":"reference/serv/routing/#serv.routing","title":"serv.routing","text":"<p>Routing layer for Serv - URL patterns, route resolution, handlers.</p>"},{"location":"reference/serv/routing/#serv.routing.Route","title":"Route","text":"<p>Base class for creating HTTP route handlers in Serv applications.</p> <p>Route classes provide a structured way to handle HTTP requests by defining methods that correspond to HTTP methods (GET, POST, etc.) and form handlers. They support automatic request parsing, response type annotations, error handling, and dependency injection.</p> <p>The Route class automatically discovers handler methods based on their naming patterns and signatures: - Methods named <code>handle_&lt;method&gt;</code> become HTTP method handlers (e.g., <code>handle_get</code>, <code>handle_post</code>) - Methods with Form subclass parameters become form handlers - Methods with Exception parameters become error handlers - Return type annotations determine response wrapper classes - Handler selection is based on signature matching with request data</p> <p>Examples:</p> <p>Basic route with HTTP method handlers:</p> <pre><code>from serv.routes import Route\nfrom serv.responses import JsonResponse, TextResponse\nfrom serv.injectors import Query, Header\nfrom typing import Annotated\n\nclass UserRoute(Route):\n    async def handle_get(self, user_id: Annotated[str, Query(\"id\")]) -&gt; Annotated[dict, JsonResponse]:\n        return {\"id\": user_id, \"name\": \"John Doe\"}\n\n    async def handle_post(self, data: dict) -&gt; Annotated[str, TextResponse]:\n        # Create user logic here\n        return \"User created successfully\"\n</code></pre> <p>Route with multiple GET handlers based on parameters:</p> <pre><code>class ProductRoute(Route):\n    # Handler for requests with 'id' query parameter\n    async def handle_get(self, product_id: Annotated[str, Query(\"id\")]) -&gt; Annotated[dict, JsonResponse]:\n        return {\"id\": product_id, \"name\": \"Product Name\"}\n\n    # Handler for requests with 'category' query parameter\n    async def handle_get_by_category(self, category: Annotated[str, Query(\"category\")]) -&gt; Annotated[list, JsonResponse]:\n        return [{\"id\": 1, \"name\": \"Product 1\"}, {\"id\": 2, \"name\": \"Product 2\"}]\n\n    # Handler for requests with no specific parameters (fallback)\n    async def handle_get_all(self) -&gt; Annotated[list, JsonResponse]:\n        return [{\"id\": 1, \"name\": \"All Products\"}]\n</code></pre> <p>Route with form handling:</p> <pre><code>from serv.routes import Route, Form\nfrom serv.responses import HtmlResponse\nfrom typing import Annotated\n\nclass ContactForm(Form):\n    name: str\n    email: str\n    message: str\n\nclass ContactRoute(Route):\n    async def handle_get(self) -&gt; Annotated[str, HtmlResponse]:\n        return '''\n        &lt;form method=\"post\"&gt;\n            &lt;input name=\"name\" placeholder=\"Name\" required&gt;\n            &lt;input name=\"email\" type=\"email\" placeholder=\"Email\" required&gt;\n            &lt;textarea name=\"message\" placeholder=\"Message\" required&gt;&lt;/textarea&gt;\n            &lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n        &lt;/form&gt;\n        '''\n\n    async def handle_contact_form(self, form: ContactForm) -&gt; Annotated[str, HtmlResponse]:\n        # Process the form submission\n        await self.send_email(form.email, form.name, form.message)\n        return \"&lt;h1&gt;Thank you! Your message has been sent.&lt;/h1&gt;\"\n</code></pre> <p>Route with header and cookie injection:</p> <pre><code>from serv.injectors import Header, Cookie\n\nclass AuthRoute(Route):\n    async def handle_get(\n        self,\n        auth_token: Annotated[str, Header(\"Authorization\")],\n        session_id: Annotated[str, Cookie(\"session_id\")]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        # Validate token and session\n        return {\"authenticated\": True, \"user\": \"john_doe\"}\n</code></pre> Note <p>Route classes are automatically instantiated by the router when a matching request is received. Handler methods are selected based on the best match between the request data and the method's parameter signature. Methods with more specific parameter requirements will be preferred over generic handlers.</p>"},{"location":"reference/serv/routing/#serv.routing.Router","title":"Router","text":"<pre><code>Router(settings: dict[str, Any] = None)\n</code></pre> <p>               Bases: <code>RouterProtocol</code></p> <p>HTTP request router for mapping URLs to handlers.</p> <p>The Router class is responsible for matching incoming HTTP requests to the appropriate handler functions or Route classes. It supports path parameters, HTTP method filtering, route mounting, and URL generation.</p> <p>Features: - Path parameter extraction (e.g., <code>/users/{id}</code>) - HTTP method-specific routing - Route mounting and sub-routers - URL generation with <code>url_for()</code> - Route settings and metadata - Flexible handler types (functions, Route classes) - WebSocket route support</p> <p>Examples:</p> <p>Basic router setup:</p> <pre><code>from serv.routing.router import Router\n\nrouter = Router()\n\n# Add function-based routes\nasync def get_users():\n    return {\"users\": []}\n\nrouter.add_route(\"/users\", get_users, [\"GET\"])\n\n# Add Route class\nclass UserRoute:\n    async def handle_get(self, request):\n        return {\"user\": \"data\"}\n\nrouter.add_route(\"/users/{id}\", UserRoute)\n\n# Add WebSocket handler\nasync def websocket_handler(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\nrouter.add_websocket(\"/ws\", websocket_handler)\n</code></pre> <p>Router with settings:</p> <pre><code>router = Router(settings={\n    \"auth_required\": True,\n    \"rate_limit\": 100\n})\n</code></pre> <p>Mounting sub-routers:</p> <pre><code>api_router = Router()\napi_router.add_route(\"/users\", users_handler)\napi_router.add_route(\"/posts\", posts_handler)\n\nmain_router = Router()\nmain_router.mount(\"/api/v1\", api_router)\n# Now /api/v1/users and /api/v1/posts are available\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of router-level settings that will be available to all routes handled by this router.</p> <code>None</code> Source code in <code>serv/routing/router.py</code> <pre><code>def __init__(self, settings: dict[str, Any] = None):\n    # Stores tuples of (path_pattern, methods, handler_callable, settings)\n    self._routes: list[\n        tuple[str, frozenset[str] | None, Callable, dict[str, Any]]\n    ] = []\n    # Stores WebSocket routes as tuples of (path_pattern, handler_callable, settings)\n    self._websocket_routes: list[tuple[str, Callable, dict[str, Any]]] = []\n    # Stores mapping of (route_class -&gt; path_pattern) for url_for lookups\n    self._route_class_paths: dict[type[routes.Route], list[str]] = {}\n    # Stores mapping of route path patterns to settings\n    self._route_settings: dict[str, dict[str, Any]] = {}\n    # Stores tuples of (mount_path, router_instance)\n    self._mounted_routers: list[tuple[str, Router]] = []\n    self._sub_routers: list[Router] = []\n    # Router-level settings\n    self._settings: dict[str, Any] = settings or {}\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.add_route","title":"add_route","text":"<pre><code>add_route(\n    path: str,\n    handler: type[Route],\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre><pre><code>add_route(\n    path: str,\n    handler: Callable[..., Awaitable[Any]],\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre> <pre><code>add_route(\n    path: str,\n    handler: Callable[..., Awaitable[Any]] | type[Route],\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n    container: Container = None,\n)\n</code></pre> <p>Adds a route to this router.</p> <p>This method can handle both direct route handlers and Route objects. For Route objects, it will automatically register all method and form handlers defined in the route.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern for the route.</p> required <code>handler</code> <code>Callable[..., Awaitable[Any]] | type[Route]</code> <p>Either a Route object or an async handler function.</p> required <code>methods</code> <code>Sequence[str] | None</code> <p>A list of HTTP methods (e.g., ['GET', 'POST']). Only used when handler is a function.     If None, allows all methods.</p> <code>None</code> <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of settings to be added to the container when handling this route.</p> <code>None</code> <code>container</code> <code>Container</code> <p>Optional container instance to use for dependency injection. If not provided, uses the global container.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; router.add_route(\"/users\", user_handler, [\"GET\", \"POST\"])\n&gt;&gt;&gt; router.add_route(\"/items\", ItemRoute, settings={\"db_table\": \"items\"})\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def add_route(\n    self,\n    path: str,\n    handler: \"Callable[..., Awaitable[Any]] | type[routes.Route]\",\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n    container: Container = None,\n):\n    \"\"\"Adds a route to this router.\n\n    This method can handle both direct route handlers and Route objects. For Route objects,\n    it will automatically register all method and form handlers defined in the route.\n\n    Args:\n        path: The path pattern for the route.\n        handler: Either a Route object or an async handler function.\n        methods: A list of HTTP methods (e.g., ['GET', 'POST']). Only used when handler is a function.\n                If None, allows all methods.\n        settings: Optional dictionary of settings to be added to the container when handling this route.\n        container: Optional container instance to use for dependency injection. If not provided, uses the global container.\n\n    Examples:\n        &gt;&gt;&gt; router.add_route(\"/users\", user_handler, [\"GET\", \"POST\"])\n        &gt;&gt;&gt; router.add_route(\"/items\", ItemRoute, settings={\"db_table\": \"items\"})\n    \"\"\"\n    match handler:\n        case type() as route if hasattr(route, \"__method_handlers__\") and hasattr(\n            route, \"__form_handlers__\"\n        ):\n            # Keep track of which paths are mapped to which Route classes\n            if route not in self._route_class_paths:\n                self._route_class_paths[route] = []\n            self._route_class_paths[route].append(path)\n\n            # Initialize the Route class directly to avoid container.call issues\n            # We'll still use a container branch to handle RouteSettings\n            if container is None:\n                # Create a new container from scratch if none was provided\n                from bevy import get_registry\n\n                container = get_registry().create_container()\n\n            with container.branch() as branch_container:\n                branch_container.add(RouteSettings, RouteSettings(**settings or {}))\n                # Create route instance directly instead of using container.call\n                try:\n                    route_instance = route()\n                except Exception as e:\n                    import logging\n\n                    logging.getLogger(__name__).error(\n                        f\"Error initializing route {route}: {e}\"\n                    )\n                    raise\n\n            methods = (\n                route.__method_handlers__.keys() | route.__form_handlers__.keys()\n            )\n            # Store these settings for the actual path\n            self._route_settings[path] = settings or {}\n            self.add_route(\n                path, route_instance.__call__, list(methods), settings=settings\n            )\n\n        case _:\n            normalized_methods = (\n                frozenset(m.upper() for m in methods) if methods else None\n            )\n            self._routes.append((path, normalized_methods, handler, settings or {}))\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.add_router","title":"add_router","text":"<pre><code>add_router(router: Router)\n</code></pre> <p>Adds a sub-router. Sub-routers are checked before the current router's own routes. Later added sub-routers are checked first (LIFO order for matching).</p> Source code in <code>serv/routing/router.py</code> <pre><code>def add_router(self, router: \"Router\"):\n    \"\"\"Adds a sub-router. Sub-routers are checked before the current router's own routes.\n    Later added sub-routers are checked first (LIFO order for matching).\"\"\"\n    self._sub_routers.append(router)\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.add_websocket","title":"add_websocket","text":"<pre><code>add_websocket(\n    path: str,\n    handler: Callable[..., Awaitable[Any]],\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre> <p>Adds a WebSocket route to this router.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern for the WebSocket route.</p> required <code>handler</code> <code>Callable[..., Awaitable[Any]]</code> <p>An async WebSocket handler function that accepts a WebSocket parameter.</p> required <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of settings to be added to the container when handling this route.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def echo_handler(websocket):\n...     async for message in websocket:\n...         await websocket.send(message)\n&gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler)\n</code></pre> <pre><code>&gt;&gt;&gt; # With settings\n&gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler, settings={\"auth_required\": True})\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def add_websocket(\n    self,\n    path: str,\n    handler: \"Callable[..., Awaitable[Any]]\",\n    *,\n    settings: dict[str, Any] = None,\n):\n    \"\"\"Adds a WebSocket route to this router.\n\n    Args:\n        path: The path pattern for the WebSocket route.\n        handler: An async WebSocket handler function that accepts a WebSocket parameter.\n        settings: Optional dictionary of settings to be added to the container when handling this route.\n\n    Examples:\n        &gt;&gt;&gt; async def echo_handler(websocket):\n        ...     async for message in websocket:\n        ...         await websocket.send(message)\n        &gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler)\n\n        &gt;&gt;&gt; # With settings\n        &gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler, settings={\"auth_required\": True})\n    \"\"\"\n    self._websocket_routes.append((path, handler, settings or {}))\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.mount","title":"mount","text":"<pre><code>mount(path: str, router: Router)\n</code></pre> <p>Mounts a router at a specific path.</p> <p>Unlike add_router which adds a router with full request path access, mount prefixes all routes in the mounted router with the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path prefix where the router should be mounted.  Should start with a '/' and not end with one.</p> required <code>router</code> <code>Router</code> <p>The router instance to mount at the specified path.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; api_router = Router()\n&gt;&gt;&gt; api_router.add_route(\"/users\", users_handler)\n&gt;&gt;&gt; main_router.mount(\"/api\", api_router)\n# Now \"/api/users\" will be handled by users_handler\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def mount(self, path: str, router: \"Router\"):\n    \"\"\"Mounts a router at a specific path.\n\n    Unlike add_router which adds a router with full request path access,\n    mount prefixes all routes in the mounted router with the given path.\n\n    Args:\n        path: The path prefix where the router should be mounted.\n             Should start with a '/' and not end with one.\n        router: The router instance to mount at the specified path.\n\n    Examples:\n        &gt;&gt;&gt; api_router = Router()\n        &gt;&gt;&gt; api_router.add_route(\"/users\", users_handler)\n        &gt;&gt;&gt; main_router.mount(\"/api\", api_router)\n        # Now \"/api/users\" will be handled by users_handler\n    \"\"\"\n    if not path.startswith(\"/\"):\n        path = \"/\" + path\n    if path.endswith(\"/\"):\n        path = path[:-1]\n\n    self._mounted_routers.append((path, router))\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.resolve_route","title":"resolve_route","text":"<pre><code>resolve_route(\n    request_path: str, request_method: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Recursively finds a handler for the given path and method.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The path of the incoming request.</p> required <code>request_method</code> <code>str</code> <p>The HTTP method of the incoming request.</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>None if no route matches the path (results in a 404).</p> <p>Raises:</p> Type Description <code>HTTPMethodNotAllowedException</code> <p>If one or more routes match the path but not the method,                            and no route matches both path and method.</p> Source code in <code>serv/routing/router.py</code> <pre><code>def resolve_route(\n    self, request_path: str, request_method: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Recursively finds a handler for the given path and method.\n\n    Args:\n        request_path: The path of the incoming request.\n        request_method: The HTTP method of the incoming request.\n\n    Returns:\n        A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.\n        None if no route matches the path (results in a 404).\n\n    Raises:\n        HTTPMethodNotAllowedException: If one or more routes match the path but not the method,\n                                       and no route matches both path and method.\n    \"\"\"\n    from serv.routing.resolvers import resolve_http_route\n\n    return resolve_http_route(\n        request_path,\n        request_method,\n        self._mounted_routers,\n        self._sub_routers,\n        self._routes,\n        self._settings,\n        self._match_path\n    )\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.resolve_websocket","title":"resolve_websocket","text":"<pre><code>resolve_websocket(\n    request_path: str,\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Resolve a WebSocket route for the given path.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The WebSocket request path to match against registered routes.</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_params, route_settings) if a matching</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>WebSocket route is found, None otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler, params, settings = router.resolve_websocket(\"/ws/user/123\")\n&gt;&gt;&gt; if handler:\n...     # Handle WebSocket connection\n...     await handler(websocket, **params)\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def resolve_websocket(\n    self, request_path: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Resolve a WebSocket route for the given path.\n\n    Args:\n        request_path: The WebSocket request path to match against registered routes.\n\n    Returns:\n        A tuple of (handler_callable, path_params, route_settings) if a matching\n        WebSocket route is found, None otherwise.\n\n    Examples:\n        &gt;&gt;&gt; handler, params, settings = router.resolve_websocket(\"/ws/user/123\")\n        &gt;&gt;&gt; if handler:\n        ...     # Handle WebSocket connection\n        ...     await handler(websocket, **params)\n    \"\"\"\n    from serv.routing.resolvers import resolve_websocket_route\n\n    return resolve_websocket_route(\n        request_path,\n        self._mounted_routers,\n        self._sub_routers,\n        self._websocket_routes,\n        self._settings,\n        self._match_path\n    )\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.url_for","title":"url_for","text":"<pre><code>url_for(handler: Callable | type[Route], **kwargs) -&gt; str\n</code></pre> <p>Builds a URL for a registered route handler with the given path parameters.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable | type[Route]</code> <p>The route handler function or Route class for which to build a URL.</p> required <code>**kwargs</code> <p>Path parameters to substitute in the URL pattern.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A URL string with path parameters filled in.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the handler is not found in any router, or if required path        parameters are missing from kwargs.</p> Source code in <code>serv/routing/router.py</code> <pre><code>def url_for(self, handler: Callable | type[\"routes.Route\"], **kwargs) -&gt; str:\n    \"\"\"Builds a URL for a registered route handler with the given path parameters.\n\n    Args:\n        handler: The route handler function or Route class for which to build a URL.\n        **kwargs: Path parameters to substitute in the URL pattern.\n\n    Returns:\n        A URL string with path parameters filled in.\n\n    Raises:\n        ValueError: If the handler is not found in any router, or if required path\n                   parameters are missing from kwargs.\n    \"\"\"\n    # Import generation functions to avoid circular dependency\n    from serv.routing.generation import url_for_route_class, url_for_function_handler\n\n    # Import routes at runtime to avoid circular dependency\n    import serv.routes as routes\n\n    # First check if handler is a Route class\n    if isinstance(handler, type) and issubclass(handler, routes.Route):\n        return url_for_route_class(\n            self._route_class_paths,\n            self._mounted_routers,\n            self._sub_routers,\n            handler,\n            **kwargs\n        )\n\n    # Handle methods on Route instances (less common case)\n    elif hasattr(handler, \"__self__\"):\n        if isinstance(handler.__self__, routes.Route):\n            route_instance = handler.__self__\n            handler = route_instance.__call__\n            path = self._find_handler_path(handler)\n            if not path:\n                raise ValueError(\n                    f\"Route instance method {handler.__name__} not found in any router\"\n                )\n\n            from serv.routing.generation import build_url_from_path\n            return build_url_from_path(path, kwargs)\n\n    # For function handlers\n    else:\n        return url_for_function_handler(\n            self._routes,\n            self._mounted_routers,\n            self._sub_routers,\n            handler,\n            **kwargs\n        )\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.build_url_from_path","title":"build_url_from_path","text":"<pre><code>build_url_from_path(\n    path: str, kwargs: dict[str, Any]\n) -&gt; str\n</code></pre> <p>Build a URL by substituting path parameters from kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern with parameter placeholders (e.g., \"/users/{user_id}\")</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Dictionary containing parameter values</p> required <p>Returns:</p> Type Description <code>str</code> <p>A URL string with path parameters filled in</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required path parameters are missing from kwargs</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; build_url_from_path(\"/users/{user_id}\", {\"user_id\": 123})\n\"/users/123\"\n</code></pre> <pre><code>&gt;&gt;&gt; build_url_from_path(\"/api/v{version}/users/{user_id}\", {\"version\": 1, \"user_id\": 123})\n\"/api/v1/users/123\"\n</code></pre> <pre><code>&gt;&gt;&gt; build_url_from_path(\"/files/{path:path}\", {\"path\": \"docs/readme.txt\"})\n\"/files/docs/readme.txt\"\n</code></pre> Source code in <code>serv/routing/generation.py</code> <pre><code>def build_url_from_path(path: str, kwargs: dict[str, Any]) -&gt; str:\n    \"\"\"Build a URL by substituting path parameters from kwargs.\n\n    Args:\n        path: The path pattern with parameter placeholders (e.g., \"/users/{user_id}\")\n        kwargs: Dictionary containing parameter values\n\n    Returns:\n        A URL string with path parameters filled in\n\n    Raises:\n        ValueError: If required path parameters are missing from kwargs\n\n    Examples:\n        &gt;&gt;&gt; build_url_from_path(\"/users/{user_id}\", {\"user_id\": 123})\n        \"/users/123\"\n\n        &gt;&gt;&gt; build_url_from_path(\"/api/v{version}/users/{user_id}\", {\"version\": 1, \"user_id\": 123})\n        \"/api/v1/users/123\"\n\n        &gt;&gt;&gt; build_url_from_path(\"/files/{path:path}\", {\"path\": \"docs/readme.txt\"})\n        \"/files/docs/readme.txt\"\n    \"\"\"\n    parts = path.split(\"/\")\n    result_parts = []\n\n    for part in parts:\n        if part.startswith(\"{\") and part.endswith(\"}\"):\n            param_name = part[1:-1]\n            # Handle typed parameters like {user_id:int}\n            if \":\" in param_name:\n                param_name = param_name.split(\":\")[0]\n            if param_name not in kwargs:\n                raise ValueError(f\"Missing required path parameter: {param_name}\")\n            result_parts.append(str(kwargs[param_name]))\n        else:\n            result_parts.append(part)\n\n    return \"/\" + \"/\".join(p for p in result_parts if p)\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.match_path","title":"match_path","text":"<pre><code>match_path(\n    request_path: str, path_pattern: str\n) -&gt; dict[str, Any] | None\n</code></pre> <p>Performs path matching against a pattern.</p> <p>Supports exact matches and path parameters with optional type hints. Supported types: {param}, {param:int}, {param:path}</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The incoming request path to match</p> required <code>path_pattern</code> <code>str</code> <p>The route pattern to match against</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dict of path parameters if matched, else None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; match_path(\"/users/123\", \"/users/{user_id:int}\")\n{\"user_id\": 123}\n</code></pre> <pre><code>&gt;&gt;&gt; match_path(\"/files/docs/readme.txt\", \"/files/{path:path}\")\n{\"path\": \"docs/readme.txt\"}\n</code></pre> <pre><code>&gt;&gt;&gt; match_path(\"/api/v1/users\", \"/api/v{version:int}/users\")\n{\"version\": 1}\n</code></pre> Source code in <code>serv/routing/patterns.py</code> <pre><code>def match_path(request_path: str, path_pattern: str) -&gt; dict[str, Any] | None:\n    \"\"\"Performs path matching against a pattern.\n\n    Supports exact matches and path parameters with optional type hints.\n    Supported types: {param}, {param:int}, {param:path}\n\n    Args:\n        request_path: The incoming request path to match\n        path_pattern: The route pattern to match against\n\n    Returns:\n        A dict of path parameters if matched, else None.\n\n    Examples:\n        &gt;&gt;&gt; match_path(\"/users/123\", \"/users/{user_id:int}\")\n        {\"user_id\": 123}\n\n        &gt;&gt;&gt; match_path(\"/files/docs/readme.txt\", \"/files/{path:path}\")\n        {\"path\": \"docs/readme.txt\"}\n\n        &gt;&gt;&gt; match_path(\"/api/v1/users\", \"/api/v{version:int}/users\")\n        {\"version\": 1}\n    \"\"\"\n    pattern_parts = path_pattern.strip(\"/\").split(\"/\")\n    request_parts = request_path.strip(\"/\").split(\"/\")\n\n    # Handle special case for path type parameters that can consume multiple segments\n    if any(\"{\" in part and \":path}\" in part for part in pattern_parts):\n        return match_path_with_path_type(request_path, path_pattern)\n\n    if len(pattern_parts) != len(request_parts):\n        return None\n\n    params = {}\n    for p_part, r_part in zip(pattern_parts, request_parts, strict=False):\n        if \"{\" in p_part and \"}\" in p_part:\n            # Handle parameters that might be embedded in text (like \"v{version:int}\")\n            result = match_segment_with_params(p_part, r_part)\n            if result is None:\n                return None\n            params.update(result)\n        elif p_part != r_part:\n            return None\n\n    return params\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.resolve_http_route","title":"resolve_http_route","text":"<pre><code>resolve_http_route(\n    request_path: str,\n    request_method: str,\n    mounted_routers: list[tuple[str, Router]],\n    sub_routers: list[Router],\n    routes: list[\n        tuple[\n            str, list[str] | None, Callable, dict[str, Any]\n        ]\n    ],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[\n        [str, str], dict[str, Any] | None\n    ],\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Resolve an HTTP route for the given path and method.</p> <p>This function implements the complete route resolution algorithm, checking mounted routers, sub-routers, and direct routes in the correct order.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The path of the incoming request</p> required <code>request_method</code> <code>str</code> <p>The HTTP method of the incoming request</p> required <code>mounted_routers</code> <code>list[tuple[str, Router]]</code> <p>List of (mount_path, router) tuples</p> required <code>sub_routers</code> <code>list[Router]</code> <p>List of sub-routers to check</p> required <code>routes</code> <code>list[tuple[str, list[str] | None, Callable, dict[str, Any]]]</code> <p>List of route tuples (path, methods, handler, settings)</p> required <code>router_settings</code> <code>dict[str, Any]</code> <p>Router-level settings to merge</p> required <code>match_path_func</code> <code>Callable[[str, str], dict[str, Any] | None]</code> <p>Function to perform path pattern matching</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>None if no route matches the path (results in a 404).</p> <p>Raises:</p> Type Description <code>HTTPMethodNotAllowedException</code> <p>If one or more routes match the path but not the method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler, params, settings = resolve_http_route(\n...     \"/users/123\", \"GET\", [], [], \n...     [(\"/users/{id}\", [\"GET\"], my_handler, {})],\n...     {}, match_path\n... )\n&gt;&gt;&gt; if handler:\n...     # Route found, call handler with params\n...     await handler(**params)\n</code></pre> Source code in <code>serv/routing/resolvers.py</code> <pre><code>def resolve_http_route(\n    request_path: str,\n    request_method: str,\n    mounted_routers: list[tuple[str, \"Router\"]],\n    sub_routers: list[\"Router\"], \n    routes: list[tuple[str, list[str] | None, Callable, dict[str, Any]]],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[[str, str], dict[str, Any] | None]\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Resolve an HTTP route for the given path and method.\n\n    This function implements the complete route resolution algorithm, checking\n    mounted routers, sub-routers, and direct routes in the correct order.\n\n    Args:\n        request_path: The path of the incoming request\n        request_method: The HTTP method of the incoming request\n        mounted_routers: List of (mount_path, router) tuples\n        sub_routers: List of sub-routers to check\n        routes: List of route tuples (path, methods, handler, settings)\n        router_settings: Router-level settings to merge\n        match_path_func: Function to perform path pattern matching\n\n    Returns:\n        A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.\n        None if no route matches the path (results in a 404).\n\n    Raises:\n        HTTPMethodNotAllowedException: If one or more routes match the path but not the method.\n\n    Examples:\n        &gt;&gt;&gt; handler, params, settings = resolve_http_route(\n        ...     \"/users/123\", \"GET\", [], [], \n        ...     [(\"/users/{id}\", [\"GET\"], my_handler, {})],\n        ...     {}, match_path\n        ... )\n        &gt;&gt;&gt; if handler:\n        ...     # Route found, call handler with params\n        ...     await handler(**params)\n    \"\"\"\n    collected_allowed_methods: set[str] = set()\n    found_path_match_but_not_method = False\n\n    # 1. Check mounted routers first\n    for mount_path, mounted_router in mounted_routers:\n        if request_path.startswith(mount_path):\n            # Strip the mount path prefix for the mounted router\n            sub_path = request_path[len(mount_path) :]\n            if not sub_path:\n                sub_path = \"/\"\n            elif not sub_path.startswith(\"/\"):\n                sub_path = \"/\" + sub_path\n\n            try:\n                resolved_in_mounted = mounted_router.resolve_route(\n                    sub_path, request_method\n                )\n                if resolved_in_mounted:\n                    handler, params, settings = resolved_in_mounted\n                    # Merge router settings with any more specific settings\n                    merged_settings = {\n                        **router_settings,\n                        **mounted_router._settings,\n                        **settings,\n                    }\n                    return handler, params, merged_settings\n            except HTTPMethodNotAllowedException as e:\n                # Mounted router matched the path but not the method\n                collected_allowed_methods.update(e.allowed_methods)\n                found_path_match_but_not_method = True\n            except HTTPNotFoundException:\n                # Mounted router did not find the path. Continue search.\n                pass\n\n    # 2. Check sub-routers in reverse order of addition (LIFO for matching)\n    for sub_router in reversed(sub_routers):\n        try:\n            resolved_in_sub = sub_router.resolve_route(request_path, request_method)\n            if resolved_in_sub:\n                handler, params, settings = resolved_in_sub\n                # Merge router settings with any more specific settings\n                merged_settings = {\n                    **router_settings,\n                    **sub_router._settings,\n                    **settings,\n                }\n                return handler, params, merged_settings\n        except HTTPMethodNotAllowedException as e:\n            # Sub-router matched the path but not the method.\n            # Collect its allowed methods and mark that a path match occurred.\n            collected_allowed_methods.update(e.allowed_methods)\n            found_path_match_but_not_method = True\n            # Continue searching other sub-routers or parent's direct routes.\n        except HTTPNotFoundException:\n            # Sub-router did not find the path at all. Continue search.\n            pass\n\n    # 3. Check own routes\n    for (\n        path_pattern,\n        route_specific_methods,\n        handler_callable,\n        route_settings,\n    ) in routes:\n        match_info = match_path_func(request_path, path_pattern)\n        if match_info is not None:  # Path matches\n            found_path_match_but_not_method = (\n                True  # Mark that we at least matched the path\n            )\n            if (\n                route_specific_methods is None\n                or request_method.upper() in route_specific_methods\n            ):\n                # Path and method match\n                # Merge router settings with route settings\n                merged_settings = {**router_settings, **route_settings}\n                return handler_callable, match_info, merged_settings\n            else:\n                # Path matches, but method is not allowed for this specific route.\n                # Collect allowed methods.\n                if route_specific_methods:\n                    collected_allowed_methods.update(route_specific_methods)\n\n    # 4. After checking all mounted routers, sub-routers and own routes:\n    if found_path_match_but_not_method and collected_allowed_methods:\n        # We found one or more path matches, but no method matches for that path.\n        # And we have a list of methods that *would* have been allowed.\n        raise HTTPMethodNotAllowedException(\n            f\"Method {request_method} not allowed for {request_path}\",\n            allowed_methods=list(collected_allowed_methods),\n        )\n\n    # If no path match was found at all, or if path matched but no methods were ever defined for it\n    # (e.g. route_specific_methods was None and it wasn't a match, which is unlikely with current logic\n    # but covering bases if collected_allowed_methods is empty despite found_path_match_but_not_method)\n    if found_path_match_but_not_method and not collected_allowed_methods:\n        # This case implies a path was matched by a route that allows ALL methods (None),\n        # but the request_method somehow didn't trigger the \"return handler_callable, match_info\"\n        # This shouldn't happen if request_method.upper() is in route_specific_methods when it's None.\n        # For safety, if we matched a path but have no specific allowed methods to suggest,\n        # it's still a method not allowed situation, but without specific 'Allow' header.\n        # However, current logic means if route_specific_methods is None, it's an immediate match.\n        # This path should ideally not be hit frequently.\n        # To be safe, we will treat it as a 404 if no specific methods were collected.\n        pass\n\n    # No route matched the path at all, or a path was matched but it didn't lead to a 405 (e.g. ill-defined route).\n    return None\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.resolve_websocket_route","title":"resolve_websocket_route","text":"<pre><code>resolve_websocket_route(\n    request_path: str,\n    mounted_routers: list[tuple[str, Router]],\n    sub_routers: list[Router],\n    websocket_routes: list[\n        tuple[str, Callable, dict[str, Any]]\n    ],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[\n        [str, str], dict[str, Any] | None\n    ],\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Resolve a WebSocket route for the given path.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The WebSocket request path to match against registered routes</p> required <code>mounted_routers</code> <code>list[tuple[str, Router]]</code> <p>List of (mount_path, router) tuples</p> required <code>sub_routers</code> <code>list[Router]</code> <p>List of sub-routers to check</p> required <code>websocket_routes</code> <code>list[tuple[str, Callable, dict[str, Any]]]</code> <p>List of WebSocket route tuples (path, handler, settings)</p> required <code>router_settings</code> <code>dict[str, Any]</code> <p>Router-level settings to merge</p> required <code>match_path_func</code> <code>Callable[[str, str], dict[str, Any] | None]</code> <p>Function to perform path pattern matching</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_params, route_settings) if a matching</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>WebSocket route is found, None otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler, params, settings = resolve_websocket_route(\n...     \"/ws/user/123\", [], [],\n...     [(\"/ws/user/{id}\", ws_handler, {})],\n...     {}, match_path\n... )\n&gt;&gt;&gt; if handler:\n...     # Handle WebSocket connection\n...     await handler(websocket, **params)\n</code></pre> Source code in <code>serv/routing/resolvers.py</code> <pre><code>def resolve_websocket_route(\n    request_path: str,\n    mounted_routers: list[tuple[str, \"Router\"]],\n    sub_routers: list[\"Router\"],\n    websocket_routes: list[tuple[str, Callable, dict[str, Any]]],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[[str, str], dict[str, Any] | None]\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Resolve a WebSocket route for the given path.\n\n    Args:\n        request_path: The WebSocket request path to match against registered routes\n        mounted_routers: List of (mount_path, router) tuples\n        sub_routers: List of sub-routers to check\n        websocket_routes: List of WebSocket route tuples (path, handler, settings)\n        router_settings: Router-level settings to merge\n        match_path_func: Function to perform path pattern matching\n\n    Returns:\n        A tuple of (handler_callable, path_params, route_settings) if a matching\n        WebSocket route is found, None otherwise.\n\n    Examples:\n        &gt;&gt;&gt; handler, params, settings = resolve_websocket_route(\n        ...     \"/ws/user/123\", [], [],\n        ...     [(\"/ws/user/{id}\", ws_handler, {})],\n        ...     {}, match_path\n        ... )\n        &gt;&gt;&gt; if handler:\n        ...     # Handle WebSocket connection\n        ...     await handler(websocket, **params)\n    \"\"\"\n    # First check sub-routers (they take precedence)\n    for sub_router in reversed(sub_routers):\n        result = sub_router.resolve_websocket(request_path)\n        if result:\n            return result\n\n    # Check mounted routers\n    for mount_path, mounted_router in mounted_routers:\n        if request_path.startswith(mount_path):\n            # Remove the mount path prefix before checking the mounted router\n            relative_path = request_path[len(mount_path) :] or \"/\"\n            result = mounted_router.resolve_websocket(relative_path)\n            if result:\n                return result\n\n    # Check our own WebSocket routes\n    for path_pattern, handler, settings in websocket_routes:\n        path_params = match_path_func(request_path, path_pattern)\n        if path_params is not None:\n            # Merge router-level settings with route-specific settings\n            merged_settings = {**router_settings, **settings}\n            return handler, path_params, merged_settings\n\n    return None\n</code></pre>"},{"location":"reference/serv/serv/","title":"serv","text":""},{"location":"reference/serv/serv/#serv.serv","title":"serv.serv","text":""},{"location":"reference/serv/test_client/","title":"test_client","text":""},{"location":"reference/serv/test_client/#serv.test_client","title":"serv.test_client","text":"<p>Test client utilities for Serv applications.</p> <p>This module provides utilities for creating test clients that wrap Serv apps in httpx AsyncClient instances, allowing for easy testing without running a server.</p>"},{"location":"reference/serv/test_client/#serv.test_client.LifespanManager","title":"LifespanManager","text":"<pre><code>LifespanManager(app: App)\n</code></pre> <p>Manages the lifespan of an ASGI application by handling the protocol messages.</p> <p>This class handles the startup and shutdown events for an ASGI application, which is necessary for proper initialization of extensions and cleanup.</p> Source code in <code>serv/test_client.py</code> <pre><code>def __init__(self, app: App):\n    self.app = app\n    self.receive_queue = asyncio.Queue()\n    self.send_queue = asyncio.Queue()\n    self.lifespan_task = None\n</code></pre>"},{"location":"reference/serv/test_client/#serv.test_client.LifespanManager.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan()\n</code></pre> <p>Context manager for the lifespan protocol.</p> Source code in <code>serv/test_client.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(self):\n    \"\"\"Context manager for the lifespan protocol.\"\"\"\n    await self.startup()\n    try:\n        yield\n    finally:\n        await self.shutdown()\n</code></pre>"},{"location":"reference/serv/test_client/#serv.test_client.LifespanManager.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Send shutdown event and wait for completion.</p> Source code in <code>serv/test_client.py</code> <pre><code>async def shutdown(self):\n    \"\"\"Send shutdown event and wait for completion.\"\"\"\n    if not self.lifespan_task:\n        raise RuntimeError(\"Cannot shutdown: lifespan task not started.\")\n    await self.receive_queue.put({\"type\": \"lifespan.shutdown\"})\n    shutdown_complete = await self.send_queue.get()\n    if shutdown_complete[\"type\"] != \"lifespan.shutdown.complete\":\n        raise RuntimeError(\n            f\"Unexpected response to lifespan.shutdown: {shutdown_complete}\"\n        )\n    self.lifespan_task.cancel()\n    with contextlib.suppress(asyncio.CancelledError):\n        await self.lifespan_task\n</code></pre>"},{"location":"reference/serv/test_client/#serv.test_client.LifespanManager.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>Send startup event and wait for completion.</p> Source code in <code>serv/test_client.py</code> <pre><code>async def startup(self):\n    \"\"\"Send startup event and wait for completion.\"\"\"\n    self.lifespan_task = asyncio.create_task(\n        self.app.handle_lifespan({\"type\": \"lifespan\"}, self.receive, self.send)\n    )\n    await self.receive_queue.put({\"type\": \"lifespan.startup\"})\n    startup_complete = await self.send_queue.get()\n    if startup_complete[\"type\"] != \"lifespan.startup.complete\":\n        raise RuntimeError(\n            f\"Unexpected response to lifespan.startup: {startup_complete}\"\n        )\n</code></pre>"},{"location":"reference/serv/test_client/#serv.test_client.create_test_app_client","title":"create_test_app_client  <code>async</code>","text":"<pre><code>create_test_app_client(\n    config_path: Path | str,\n    *,\n    app_module_str: str | None = None,\n    extension_dirs: str | None = None,\n    dev: bool = False,\n    host: str = \"127.0.0.1\",\n    port: int = 8000,\n    reload: bool = False,\n    no_reload: bool = False,\n    workers: int = 1,\n    factory: bool = False,\n    dry_run: bool = False,\n    base_url: str = \"http://testserver\",\n    use_lifespan: bool = True,\n    timeout: float = 5.0,\n) -&gt; AsyncGenerator[AsyncClient]\n</code></pre> <p>Create a test client that wraps a Serv app in an httpx AsyncClient.</p> <p>This function creates an App instance using the same configuration options as the CLI's 'serv launch' command, then wraps it in an httpx AsyncClient for testing without needing to start a server.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path | str</code> <p>Path to the config file to use (equivalent to --config)</p> required <code>app_module_str</code> <code>str | None</code> <p>Custom application class in format \"module.path:ClassName\" (equivalent to --app)</p> <code>None</code> <code>extension_dirs</code> <code>str | None</code> <p>Directory to search for extensions (equivalent to --extension-dirs)</p> <code>None</code> <code>dev</code> <code>bool</code> <p>Enable development mode (equivalent to --dev)</p> <code>False</code> <code>host</code> <code>str</code> <p>Host binding (equivalent to --host, used only for dry_run info)</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>Port binding (equivalent to --port, used only for dry_run info)</p> <code>8000</code> <code>reload</code> <code>bool</code> <p>Enable auto-reload (equivalent to --reload, used only for dry_run info)</p> <code>False</code> <code>no_reload</code> <code>bool</code> <p>Disable auto-reload (equivalent to --no-reload, used only for dry_run info)</p> <code>False</code> <code>workers</code> <code>int</code> <p>Number of workers (equivalent to --workers, used only for dry_run info)</p> <code>1</code> <code>factory</code> <code>bool</code> <p>Treat app_module_str as factory (equivalent to --factory, used only for dry_run info)</p> <code>False</code> <code>dry_run</code> <code>bool</code> <p>If True, just create app but don't return client (equivalent to --dry-run)</p> <code>False</code> <code>base_url</code> <code>str</code> <p>Base URL for test requests</p> <code>'http://testserver'</code> <code>use_lifespan</code> <code>bool</code> <p>Whether to handle app lifespan events</p> <code>True</code> <code>timeout</code> <code>float</code> <p>Request timeout in seconds</p> <code>5.0</code> <p>Returns:</p> Type Description <code>AsyncGenerator[AsyncClient]</code> <p>An AsyncClient configured to communicate with the app</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If app creation fails</p> <p>Examples:</p> <p>Basic usage: <pre><code>from pathlib import Path\nfrom serv import create_test_app_client\n\nasync with create_test_app_client(Path(\"serv.config.yaml\")) as client:\n    response = await client.get(\"/\")\n    assert response.status_code == 200\n</code></pre></p> <p>With development mode: <pre><code>async with create_test_app_client(\n    Path(\"serv.config.yaml\"),\n    dev=True\n) as client:\n    response = await client.get(\"/debug\")\n    assert response.status_code == 200\n</code></pre></p> <p>With custom extension directory: <pre><code>async with create_test_app_client(\n    Path(\"serv.config.yaml\"),\n    extension_dirs=\"./custom_extensions\"\n) as client:\n    response = await client.get(\"/custom-endpoint\")\n    assert response.status_code == 200\n</code></pre></p> <p>Testing a specific endpoint: <pre><code>async def test_api_endpoint():\n    async with create_test_app_client(Path(\"test.config.yaml\")) as client:\n        # Test POST request\n        response = await client.post(\"/api/users\", json={\"name\": \"Test User\"})\n        assert response.status_code == 201\n\n        # Test GET request\n        response = await client.get(\"/api/users/1\")\n        assert response.status_code == 200\n        user = response.json()\n        assert user[\"name\"] == \"Test User\"\n</code></pre></p> Source code in <code>serv/test_client.py</code> <pre><code>@asynccontextmanager\nasync def create_test_app_client(\n    config_path: Path | str,\n    *,\n    app_module_str: str | None = None,\n    extension_dirs: str | None = None,\n    dev: bool = False,\n    host: str = \"127.0.0.1\",\n    port: int = 8000,\n    reload: bool = False,\n    no_reload: bool = False,\n    workers: int = 1,\n    factory: bool = False,\n    dry_run: bool = False,\n    base_url: str = \"http://testserver\",\n    use_lifespan: bool = True,\n    timeout: float = 5.0,\n) -&gt; AsyncGenerator[AsyncClient]:\n    \"\"\"\n    Create a test client that wraps a Serv app in an httpx AsyncClient.\n\n    This function creates an App instance using the same configuration options\n    as the CLI's 'serv launch' command, then wraps it in an httpx AsyncClient\n    for testing without needing to start a server.\n\n    Args:\n        config_path: Path to the config file to use (equivalent to --config)\n        app_module_str: Custom application class in format \"module.path:ClassName\" (equivalent to --app)\n        extension_dirs: Directory to search for extensions (equivalent to --extension-dirs)\n        dev: Enable development mode (equivalent to --dev)\n        host: Host binding (equivalent to --host, used only for dry_run info)\n        port: Port binding (equivalent to --port, used only for dry_run info)\n        reload: Enable auto-reload (equivalent to --reload, used only for dry_run info)\n        no_reload: Disable auto-reload (equivalent to --no-reload, used only for dry_run info)\n        workers: Number of workers (equivalent to --workers, used only for dry_run info)\n        factory: Treat app_module_str as factory (equivalent to --factory, used only for dry_run info)\n        dry_run: If True, just create app but don't return client (equivalent to --dry-run)\n        base_url: Base URL for test requests\n        use_lifespan: Whether to handle app lifespan events\n        timeout: Request timeout in seconds\n\n    Returns:\n        An AsyncClient configured to communicate with the app\n\n    Raises:\n        Exception: If app creation fails\n\n    Examples:\n        Basic usage:\n        ```python\n        from pathlib import Path\n        from serv import create_test_app_client\n\n        async with create_test_app_client(Path(\"serv.config.yaml\")) as client:\n            response = await client.get(\"/\")\n            assert response.status_code == 200\n        ```\n\n        With development mode:\n        ```python\n        async with create_test_app_client(\n            Path(\"serv.config.yaml\"),\n            dev=True\n        ) as client:\n            response = await client.get(\"/debug\")\n            assert response.status_code == 200\n        ```\n\n        With custom extension directory:\n        ```python\n        async with create_test_app_client(\n            Path(\"serv.config.yaml\"),\n            extension_dirs=\"./custom_extensions\"\n        ) as client:\n            response = await client.get(\"/custom-endpoint\")\n            assert response.status_code == 200\n        ```\n\n        Testing a specific endpoint:\n        ```python\n        async def test_api_endpoint():\n            async with create_test_app_client(Path(\"test.config.yaml\")) as client:\n                # Test POST request\n                response = await client.post(\"/api/users\", json={\"name\": \"Test User\"})\n                assert response.status_code == 201\n\n                # Test GET request\n                response = await client.get(\"/api/users/1\")\n                assert response.status_code == 200\n                user = response.json()\n                assert user[\"name\"] == \"Test User\"\n        ```\n    \"\"\"\n    if not Path(config_path).exists():\n        raise FileNotFoundError(f\"Config file not found: {config_path}\")\n\n    # Convert Path to string if needed\n    config_str = str(config_path) if isinstance(config_path, Path) else config_path\n\n    # Create the app using the same logic as the CLI\n    app = create_app(\n        app_module_str=app_module_str,\n        config=config_str,\n        extension_dirs=extension_dirs,\n        dev=dev,\n    )\n\n    # Handle dry run mode\n    if dry_run:\n        print(\"=== Dry Run Mode ===\")\n        print(\"Application loaded successfully. Server would start with:\")\n        print(f\"  Host: {host}\")\n        print(f\"  Port: {port}\")\n        print(f\"  Dev Mode: {dev}\")\n        if dev:\n            reload_enabled = not no_reload\n            print(f\"  Reload: {reload_enabled}\")\n        else:\n            print(f\"  Reload: {reload}\")\n        print(f\"  Workers: {workers}\")\n        # For dry run, we don't yield a client\n        yield None\n        return\n\n    # Set up the transport for the client\n    transport = ASGITransport(app=app)\n\n    # Use the app's lifespan if requested\n    if use_lifespan:\n        lifespan_mgr = LifespanManager(app)\n        async with lifespan_mgr.lifespan():\n            async with AsyncClient(\n                transport=transport, base_url=base_url, timeout=timeout\n            ) as client:\n                yield client\n    else:\n        async with AsyncClient(\n            transport=transport, base_url=base_url, timeout=timeout\n        ) as client:\n            yield client\n</code></pre>"},{"location":"reference/serv/websocket/","title":"websocket","text":""},{"location":"reference/serv/websocket/#serv.websocket","title":"serv.websocket","text":"<p>WebSocket support for Serv framework.</p> <p>This module provides WebSocket functionality including connection management, frame handling, and integration with the Serv routing system.</p>"},{"location":"reference/serv/websocket/#serv.websocket.FrameType","title":"FrameType","text":"<p>               Bases: <code>Enum</code></p> <p>WebSocket frame types for message communication.</p> <p>Examples:</p> <p>Setting frame type for binary messages:</p> <pre><code>from typing import Annotated\nfrom serv.websocket import WebSocket, FrameType\n\nasync def binary_handler(ws: Annotated[WebSocket, FrameType.BINARY]):\n    async for message in ws:\n        # Message is bytes\n        await ws.send(message)\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket","title":"WebSocket","text":"<pre><code>WebSocket(\n    scope, receive, send, frame_type: FrameType = TEXT\n)\n</code></pre> <p>WebSocket connection handler for managing bidirectional communication.</p> <p>The WebSocket class provides async iteration over incoming messages and methods for sending messages back to the client. It handles frame types, connection state, and proper WebSocket protocol compliance.</p> <p>Examples:</p> <p>Basic echo handler:</p> <pre><code>async def echo_handler(websocket: WebSocket):\n    async for message in websocket:\n        await websocket.send(message)\n</code></pre> <p>JSON message handling:</p> <pre><code>async def json_handler(websocket: WebSocket):\n    async for message in websocket:\n        try:\n            data = json.loads(message)\n            response = {\"echo\": data, \"timestamp\": time.time()}\n            await websocket.send_json(response)\n        except json.JSONDecodeError:\n            await websocket.send_json({\"error\": \"Invalid JSON\"})\n</code></pre> <p>Binary message handling:</p> <pre><code>from typing import Annotated\nfrom serv.websocket import FrameType\n\nasync def binary_handler(ws: Annotated[WebSocket, FrameType.BINARY]):\n    async for message in ws:\n        # message is bytes\n        processed = process_binary_data(message)\n        await ws.send(processed)\n</code></pre> <p>Initialize WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <p>ASGI scope dict for WebSocket connection</p> required <code>receive</code> <p>ASGI receive callable for incoming messages</p> required <code>send</code> <p>ASGI send callable for outgoing messages</p> required <code>frame_type</code> <code>FrameType</code> <p>Preferred frame type for messages (TEXT or BINARY)</p> <code>TEXT</code> Source code in <code>serv/websocket.py</code> <pre><code>def __init__(self, scope, receive, send, frame_type: FrameType = FrameType.TEXT):\n    \"\"\"Initialize WebSocket connection.\n\n    Args:\n        scope: ASGI scope dict for WebSocket connection\n        receive: ASGI receive callable for incoming messages\n        send: ASGI send callable for outgoing messages\n        frame_type: Preferred frame type for messages (TEXT or BINARY)\n    \"\"\"\n    if scope[\"type\"] != \"websocket\":\n        raise ValueError(\"WebSocket requires 'websocket' scope type\")\n\n    self.scope = scope\n    self._receive = receive\n    self._send = send\n    self.frame_type = frame_type\n    self.state = WebSocketState.CONNECTING\n    self._closed = False\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.client","title":"client  <code>property</code>","text":"<pre><code>client\n</code></pre> <p>Client connection information.</p>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.headers","title":"headers  <code>property</code>","text":"<pre><code>headers: dict[str, str]\n</code></pre> <p>The WebSocket request headers.</p>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>True if WebSocket connection is active.</p>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>The WebSocket request path.</p>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.query_string","title":"query_string  <code>property</code>","text":"<pre><code>query_string: str\n</code></pre> <p>The WebSocket request query string.</p>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry - automatically accept connection.</p> Source code in <code>serv/websocket.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry - automatically accept connection.\"\"\"\n    await self.accept()\n    return self\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit - automatically close connection.</p> Source code in <code>serv/websocket.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit - automatically close connection.\"\"\"\n    await self.close()\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; AsyncIterator[str | bytes]\n</code></pre> <p>Enable async iteration over WebSocket messages.</p> <p>Yields:</p> Type Description <code>AsyncIterator[str | bytes]</code> <p>Messages received from the WebSocket connection</p> <p>Examples:</p> <pre><code>async def handler(websocket: WebSocket):\n    async for message in websocket:\n        print(f\"Received: {message}\")\n        await websocket.send(f\"Echo: {message}\")\n</code></pre> Source code in <code>serv/websocket.py</code> <pre><code>def __aiter__(self) -&gt; AsyncIterator[str | bytes]:\n    \"\"\"Enable async iteration over WebSocket messages.\n\n    Yields:\n        Messages received from the WebSocket connection\n\n    Examples:\n        ```python\n        async def handler(websocket: WebSocket):\n            async for message in websocket:\n                print(f\"Received: {message}\")\n                await websocket.send(f\"Echo: {message}\")\n        ```\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.__anext__","title":"__anext__  <code>async</code>","text":"<pre><code>__anext__() -&gt; str | bytes\n</code></pre> <p>Get the next message from the WebSocket connection.</p> <p>Returns:</p> Type Description <code>str | bytes</code> <p>The next received message</p> <p>Raises:</p> Type Description <code>StopAsyncIteration</code> <p>When the connection is closed</p> <code>WebSocketConnectionError</code> <p>If there's a connection error</p> Source code in <code>serv/websocket.py</code> <pre><code>async def __anext__(self) -&gt; str | bytes:\n    \"\"\"Get the next message from the WebSocket connection.\n\n    Returns:\n        The next received message\n\n    Raises:\n        StopAsyncIteration: When the connection is closed\n        WebSocketConnectionError: If there's a connection error\n    \"\"\"\n    try:\n        return await self.receive()\n    except WebSocketConnectionError:\n        # Convert connection errors to StopAsyncIteration for proper async iteration\n        raise StopAsyncIteration from None\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.accept","title":"accept  <code>async</code>","text":"<pre><code>accept(subprotocol: str | None = None) -&gt; None\n</code></pre> <p>Accept the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>subprotocol</code> <code>str | None</code> <p>Optional WebSocket subprotocol to accept</p> <code>None</code> <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection cannot be accepted</p> Source code in <code>serv/websocket.py</code> <pre><code>async def accept(self, subprotocol: str | None = None) -&gt; None:\n    \"\"\"Accept the WebSocket connection.\n\n    Args:\n        subprotocol: Optional WebSocket subprotocol to accept\n\n    Raises:\n        WebSocketConnectionError: If connection cannot be accepted\n    \"\"\"\n    if self.state != WebSocketState.CONNECTING:\n        raise WebSocketConnectionError(\"WebSocket connection already established\")\n\n    # Consume the initial websocket.connect message\n    try:\n        connect_message = await self._receive()\n        if connect_message[\"type\"] != \"websocket.connect\":\n            raise WebSocketConnectionError(\n                f\"Expected websocket.connect, got {connect_message['type']}\"\n            )\n    except Exception as e:\n        self.state = WebSocketState.DISCONNECTED\n        raise WebSocketConnectionError(\n            f\"Failed to receive connection message: {e}\"\n        ) from e\n\n    try:\n        accept_message = {\"type\": \"websocket.accept\"}\n        if subprotocol:\n            accept_message[\"subprotocol\"] = subprotocol\n\n        await self._send(accept_message)\n        self.state = WebSocketState.CONNECTED\n\n    except Exception as e:\n        self.state = WebSocketState.DISCONNECTED\n        raise WebSocketConnectionError(\n            f\"Failed to accept WebSocket connection: {e}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.close","title":"close  <code>async</code>","text":"<pre><code>close(code: int = 1000, reason: str = '') -&gt; None\n</code></pre> <p>Close the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>WebSocket close code (default: 1000 for normal closure)</p> <code>1000</code> <code>reason</code> <code>str</code> <p>Optional reason for closing</p> <code>''</code> Source code in <code>serv/websocket.py</code> <pre><code>async def close(self, code: int = 1000, reason: str = \"\") -&gt; None:\n    \"\"\"Close the WebSocket connection.\n\n    Args:\n        code: WebSocket close code (default: 1000 for normal closure)\n        reason: Optional reason for closing\n    \"\"\"\n    if self._closed:\n        return\n\n    try:\n        await self._send(\n            {\"type\": \"websocket.close\", \"code\": code, \"reason\": reason}\n        )\n    except Exception as e:\n        logger.warning(f\"Error sending WebSocket close message: {e}\")\n    finally:\n        self._closed = True\n        self.state = WebSocketState.DISCONNECTED\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.receive","title":"receive  <code>async</code>","text":"<pre><code>receive() -&gt; str | bytes\n</code></pre> <p>Receive a single message from the WebSocket connection.</p> <p>Returns:</p> Type Description <code>str | bytes</code> <p>The received message as str (text) or bytes (binary)</p> <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection is lost or receives disconnect</p> Source code in <code>serv/websocket.py</code> <pre><code>async def receive(self) -&gt; str | bytes:\n    \"\"\"Receive a single message from the WebSocket connection.\n\n    Returns:\n        The received message as str (text) or bytes (binary)\n\n    Raises:\n        WebSocketConnectionError: If connection is lost or receives disconnect\n    \"\"\"\n    if not self.is_connected:\n        raise WebSocketConnectionError(\"WebSocket connection is not active\")\n\n    try:\n        message = await self._receive()\n\n        if message[\"type\"] == \"websocket.receive\":\n            if \"text\" in message:\n                return message[\"text\"]\n            elif \"bytes\" in message:\n                return message[\"bytes\"]\n            else:\n                raise WebSocketConnectionError(\"Received empty WebSocket message\")\n\n        elif message[\"type\"] == \"websocket.disconnect\":\n            code = message.get(\"code\", 1000)\n            reason = message.get(\"reason\", \"\")\n            self._closed = True\n            self.state = WebSocketState.DISCONNECTED\n            raise WebSocketConnectionError(\n                f\"WebSocket disconnected: {code} {reason}\"\n            )\n\n        else:\n            raise WebSocketConnectionError(\n                f\"Unexpected WebSocket message type: {message['type']}\"\n            )\n\n    except Exception as e:\n        if not isinstance(e, WebSocketConnectionError):\n            self._closed = True\n            self.state = WebSocketState.DISCONNECTED\n            raise WebSocketConnectionError(\n                f\"Error receiving WebSocket message: {e}\"\n            ) from e\n        raise\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.receive_bytes","title":"receive_bytes  <code>async</code>","text":"<pre><code>receive_bytes() -&gt; bytes\n</code></pre> <p>Receive a binary message from the WebSocket connection.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The received binary message</p> <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection is lost</p> <code>TypeError</code> <p>If received message is not binary</p> Source code in <code>serv/websocket.py</code> <pre><code>async def receive_bytes(self) -&gt; bytes:\n    \"\"\"Receive a binary message from the WebSocket connection.\n\n    Returns:\n        The received binary message\n\n    Raises:\n        WebSocketConnectionError: If connection is lost\n        TypeError: If received message is not binary\n    \"\"\"\n    message = await self.receive()\n    if not isinstance(message, bytes):\n        raise TypeError(f\"Expected binary message, got {type(message)}\")\n    return message\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.receive_json","title":"receive_json  <code>async</code>","text":"<pre><code>receive_json() -&gt; Any\n</code></pre> <p>Receive and parse a JSON message from the WebSocket connection.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The parsed JSON data</p> <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection is lost</p> <code>JSONDecodeError</code> <p>If message is not valid JSON</p> Source code in <code>serv/websocket.py</code> <pre><code>async def receive_json(self) -&gt; Any:\n    \"\"\"Receive and parse a JSON message from the WebSocket connection.\n\n    Returns:\n        The parsed JSON data\n\n    Raises:\n        WebSocketConnectionError: If connection is lost\n        json.JSONDecodeError: If message is not valid JSON\n    \"\"\"\n    text = await self.receive_text()\n    return json.loads(text)\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.receive_text","title":"receive_text  <code>async</code>","text":"<pre><code>receive_text() -&gt; str\n</code></pre> <p>Receive a text message from the WebSocket connection.</p> <p>Returns:</p> Type Description <code>str</code> <p>The received text message</p> <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection is lost</p> <code>TypeError</code> <p>If received message is not text</p> Source code in <code>serv/websocket.py</code> <pre><code>async def receive_text(self) -&gt; str:\n    \"\"\"Receive a text message from the WebSocket connection.\n\n    Returns:\n        The received text message\n\n    Raises:\n        WebSocketConnectionError: If connection is lost\n        TypeError: If received message is not text\n    \"\"\"\n    message = await self.receive()\n    if not isinstance(message, str):\n        raise TypeError(f\"Expected text message, got {type(message)}\")\n    return message\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.send","title":"send  <code>async</code>","text":"<pre><code>send(data: str | bytes) -&gt; None\n</code></pre> <p>Send a message over the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | bytes</code> <p>Message data to send (str for text, bytes for binary)</p> required <p>Raises:</p> Type Description <code>WebSocketConnectionError</code> <p>If connection is not active</p> <code>TypeError</code> <p>If data type doesn't match expected frame type</p> Source code in <code>serv/websocket.py</code> <pre><code>async def send(self, data: str | bytes) -&gt; None:\n    \"\"\"Send a message over the WebSocket connection.\n\n    Args:\n        data: Message data to send (str for text, bytes for binary)\n\n    Raises:\n        WebSocketConnectionError: If connection is not active\n        TypeError: If data type doesn't match expected frame type\n    \"\"\"\n    if not self.is_connected:\n        raise WebSocketConnectionError(\"WebSocket connection is not active\")\n\n    # Determine message type based on data type and frame preference\n    if isinstance(data, str):\n        message_type = \"websocket.send\"\n        message = {\"type\": message_type, \"text\": data}\n    elif isinstance(data, bytes):\n        message_type = \"websocket.send\"\n        message = {\"type\": message_type, \"bytes\": data}\n    else:\n        raise TypeError(f\"WebSocket data must be str or bytes, got {type(data)}\")\n\n    try:\n        await self._send(message)\n        logger.debug(f\"Sent WebSocket message: {len(data)} chars/bytes\")\n    except Exception as e:\n        raise WebSocketConnectionError(\n            f\"Failed to send WebSocket message: {e}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.send_bytes","title":"send_bytes  <code>async</code>","text":"<pre><code>send_bytes(data: bytes) -&gt; None\n</code></pre> <p>Send a binary message over the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Binary data to send</p> required Source code in <code>serv/websocket.py</code> <pre><code>async def send_bytes(self, data: bytes) -&gt; None:\n    \"\"\"Send a binary message over the WebSocket connection.\n\n    Args:\n        data: Binary data to send\n    \"\"\"\n    await self.send(data)\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.send_json","title":"send_json  <code>async</code>","text":"<pre><code>send_json(data: Any) -&gt; None\n</code></pre> <p>Send a JSON message over the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to serialize as JSON and send</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If data is not JSON serializable</p> Source code in <code>serv/websocket.py</code> <pre><code>async def send_json(self, data: Any) -&gt; None:\n    \"\"\"Send a JSON message over the WebSocket connection.\n\n    Args:\n        data: Data to serialize as JSON and send\n\n    Raises:\n        TypeError: If data is not JSON serializable\n    \"\"\"\n    try:\n        json_str = json.dumps(data)\n        await self.send_text(json_str)\n    except (TypeError, ValueError) as e:\n        raise TypeError(f\"Data is not JSON serializable: {e}\") from e\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocket.send_text","title":"send_text  <code>async</code>","text":"<pre><code>send_text(data: str) -&gt; None\n</code></pre> <p>Send a text message over the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Text message to send</p> required Source code in <code>serv/websocket.py</code> <pre><code>async def send_text(self, data: str) -&gt; None:\n    \"\"\"Send a text message over the WebSocket connection.\n\n    Args:\n        data: Text message to send\n    \"\"\"\n    await self.send(data)\n</code></pre>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocketConnectionError","title":"WebSocketConnectionError","text":"<p>               Bases: <code>WebSocketError</code></p> <p>Raised when WebSocket connection fails or is lost.</p>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocketError","title":"WebSocketError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for WebSocket errors.</p>"},{"location":"reference/serv/websocket/#serv.websocket.WebSocketState","title":"WebSocketState","text":"<p>               Bases: <code>Enum</code></p> <p>WebSocket connection states.</p>"},{"location":"reference/serv/app/","title":"app","text":""},{"location":"reference/serv/app/#serv.app","title":"serv.app","text":"<p>Application layer for Serv - core app, middleware, extensions, lifecycle.</p>"},{"location":"reference/serv/app/#serv.app.App","title":"App","text":"<pre><code>App(\n    *,\n    config: str = \"./serv.config.yaml\",\n    extension_dir: str = \"./extensions\",\n    dev_mode: bool = False,\n)\n</code></pre> <p>               Bases: <code>EventEmitterProtocol</code>, <code>AppContextProtocol</code></p> <p>The main ASGI application class for Serv web framework.</p> <p>This class serves as the central orchestrator for your web application, handling incoming HTTP requests, managing extensions, middleware, routing, and dependency injection. It implements the ASGI (Asynchronous Server Gateway Interface) specification.</p> <p>The App class provides: - Extension system for extensible functionality - Middleware stack for request/response processing - Dependency injection container - Error handling and custom error pages - Template rendering capabilities - Event emission system for extension communication</p> <p>Examples:</p> <p>Basic application setup:</p> <pre><code>from serv import App\n\n# Create a basic app\napp = App()\n\n# Create app with custom config\napp = App(config=\"./config/production.yaml\")\n\n# Create app with custom extension directory\napp = App(extension_dir=\"./my_extensions\")\n\n# Development mode with enhanced debugging\napp = App(dev_mode=True)\n</code></pre> <p>Using with ASGI servers:</p> <pre><code># For uvicorn\n# uvicorn main:app --reload\n\n# For gunicorn\n# gunicorn main:app -k uvicorn.workers.UvicornWorker\n</code></pre> <p>Advanced configuration:</p> <pre><code>app = App(\n    config=\"./config/production.yaml\",\n    extension_dir=\"./extensions\",\n    dev_mode=False\n)\n\n# Add custom error handler\nasync def custom_404_handler(error):\n    # Handle 404 errors\n    pass\n\napp.add_error_handler(HTTPNotFoundException, custom_404_handler)\n\n# Add middleware\nasync def logging_middleware():\n    # Middleware logic\n    yield\n\napp.add_middleware(logging_middleware)\n</code></pre> <p>Initialize a new Serv application instance.</p> <p>Creates and configures a new ASGI application with the specified settings. This includes setting up the dependency injection container, loading extensions, configuring middleware, and preparing the routing system.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>Path to the YAML configuration file. The config file defines site information, enabled extensions, middleware stack, and other application settings. Defaults to \"./serv.config.yaml\".</p> <code>'./serv.config.yaml'</code> <code>extension_dir</code> <code>str</code> <p>Directory path where extensions are located. Extensions in this directory will be available for loading. Defaults to \"./extensions\".</p> <code>'./extensions'</code> <code>extension_dir</code> <code>str</code> <p>Legacy parameter name for extension_dir (backward compatibility).</p> <code>'./extensions'</code> <code>dev_mode</code> <code>bool</code> <p>Enable development mode features including enhanced error reporting, debug logging, and development-specific behaviors. Should be False in production. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ServConfigError</code> <p>If the configuration file cannot be loaded or contains invalid YAML/configuration structure.</p> <code>ImportError</code> <p>If required dependencies for extensions cannot be imported.</p> <code>ValueError</code> <p>If extension_dir path is invalid or inaccessible.</p> <p>Examples:</p> <p>Basic initialization:</p> <pre><code># Use default settings\napp = App()\n\n# Custom config file\napp = App(config=\"config/production.yaml\")\n\n# Custom extension directory\napp = App(extension_dir=\"src/extensions\")\n\n# Development mode\napp = App(dev_mode=True)\n</code></pre> <p>Production setup:</p> <pre><code>app = App(\n    config=\"/etc/myapp/config.yaml\",\n    extension_dir=\"/opt/myapp/extensions\",\n    dev_mode=False\n)\n</code></pre> <p>Development setup:</p> <pre><code>app = App(\n    config=\"dev.config.yaml\",\n    extension_dir=\"./dev_extensions\",\n    dev_mode=True\n)\n</code></pre> Note <p>The application will automatically load the welcome extension if no other extensions are configured, providing a default landing page for new projects.</p> Source code in <code>serv/_app.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: str = \"./serv.config.yaml\",\n    extension_dir: str = \"./extensions\",\n    dev_mode: bool = False,\n):\n    \"\"\"Initialize a new Serv application instance.\n\n    Creates and configures a new ASGI application with the specified settings.\n    This includes setting up the dependency injection container, loading extensions,\n    configuring middleware, and preparing the routing system.\n\n    Args:\n        config: Path to the YAML configuration file. The config file defines\n            site information, enabled extensions, middleware stack, and other\n            application settings. Defaults to \"./serv.config.yaml\".\n        extension_dir: Directory path where extensions are located. Extensions in this\n            directory will be available for loading. Defaults to \"./extensions\".\n        extension_dir: Legacy parameter name for extension_dir (backward compatibility).\n        dev_mode: Enable development mode features including enhanced error\n            reporting, debug logging, and development-specific behaviors.\n            Should be False in production. Defaults to False.\n\n    Raises:\n        ServConfigError: If the configuration file cannot be loaded or contains\n            invalid YAML/configuration structure.\n        ImportError: If required dependencies for extensions cannot be imported.\n        ValueError: If extension_dir path is invalid or inaccessible.\n\n    Examples:\n        Basic initialization:\n\n        ```python\n        # Use default settings\n        app = App()\n\n        # Custom config file\n        app = App(config=\"config/production.yaml\")\n\n        # Custom extension directory\n        app = App(extension_dir=\"src/extensions\")\n\n        # Development mode\n        app = App(dev_mode=True)\n        ```\n\n        Production setup:\n\n        ```python\n        app = App(\n            config=\"/etc/myapp/config.yaml\",\n            extension_dir=\"/opt/myapp/extensions\",\n            dev_mode=False\n        )\n        ```\n\n        Development setup:\n\n        ```python\n        app = App(\n            config=\"dev.config.yaml\",\n            extension_dir=\"./dev_extensions\",\n            dev_mode=True\n        )\n        ```\n\n    Note:\n        The application will automatically load the welcome extension if no other\n        extensions are configured, providing a default landing page for new projects.\n    \"\"\"\n    self._config = self._load_config(config)\n    self._dev_mode = dev_mode\n    self._registry = get_registry()\n    self._container = self._registry.create_container()\n    self._async_exit_stack = contextlib.AsyncExitStack()\n    self._error_handlers: dict[\n        type[Exception], Callable[[Exception], Awaitable[None]]\n    ] = {}\n    self._middleware = []\n\n    # Handle backward compatibility for extension_dir parameter\n    actual_extension_dir = extension_dir if extension_dir is None else extension_dir\n    self._extension_loader = Importer(actual_extension_dir)\n    self._extensions: dict[Path, list[Listener]] = defaultdict(list)\n\n    # Initialize the extension loader\n    self._extension_loader_instance = ExtensionLoader(self, self._extension_loader)\n\n    self._emit = EventEmitter(self._extensions)\n\n    # Initialize database manager\n    self._database_manager = DatabaseManager(self._config, self._container)\n\n    self._init_container()\n    self._register_default_error_handlers()\n    self._init_extensions(\n        self._config.get(\"extensions\", self._config.get(\"extensions\", []))\n    )\n</code></pre>"},{"location":"reference/serv/app/#serv.app.App.dev_mode","title":"dev_mode  <code>property</code> <code>writable</code>","text":"<pre><code>dev_mode: bool\n</code></pre> <p>Get the current development mode setting.</p>"},{"location":"reference/serv/app/#serv.app.App.add_error_handler","title":"add_error_handler","text":"<pre><code>add_error_handler(\n    error_type: type[Exception],\n    handler: Callable[[Exception], Awaitable[None]],\n)\n</code></pre> <p>Register a custom error handler for specific exception types.</p> <p>Error handlers allow you to customize how your application responds to different types of errors, providing custom error pages, logging, or recovery mechanisms.</p> <p>Parameters:</p> Name Type Description Default <code>error_type</code> <code>type[Exception]</code> <p>The exception class to handle. The handler will be called for this exception type and any of its subclasses.</p> required <code>handler</code> <code>Callable[[Exception], Awaitable[None]]</code> <p>An async function that will be called when the exception occurs. The handler receives the exception instance and can use dependency injection to access request/response objects.</p> required <p>Examples:</p> <p>Handle 404 errors with a custom page:</p> <pre><code>from serv.exceptions import HTTPNotFoundException\nfrom serv.responses import ResponseBuilder\nfrom bevy import injectable, Inject\n\n@injectable\nasync def custom_404_handler(\n    error: HTTPNotFoundException,\n    response: Inject[ResponseBuilder]\n):\n    response.set_status(404)\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;Page Not Found&lt;/h1&gt;&lt;p&gt;Sorry, that page doesn't exist.&lt;/p&gt;\")\n\napp.add_error_handler(HTTPNotFoundException, custom_404_handler)\n</code></pre> <p>Handle validation errors:</p> <pre><code>class ValidationError(Exception):\n    def __init__(self, message: str, field: str):\n        self.message = message\n        self.field = field\n\n@injectable\nasync def validation_error_handler(\n    error: ValidationError,\n    response: Inject[ResponseBuilder]\n):\n    response.set_status(400)\n    response.content_type(\"application/json\")\n    response.body({\n        \"error\": \"validation_failed\",\n        \"message\": error.message,\n        \"field\": error.field\n    })\n\napp.add_error_handler(ValidationError, validation_error_handler)\n</code></pre> <p>Generic error handler with logging:</p> <pre><code>import logging\n\n@injectable\nasync def generic_error_handler(\n    error: Exception,\n    response: Inject[ResponseBuilder],\n    request: Inject[Request]\n):\n    logging.error(f\"Unhandled error on {request.path}: {error}\")\n    response.set_status(500)\n    response.content_type(\"text/html\")\n    response.body(\"&lt;h1&gt;Internal Server Error&lt;/h1&gt;\")\n\napp.add_error_handler(Exception, generic_error_handler)\n</code></pre> Source code in <code>serv/_app.py</code> <pre><code>def add_error_handler(\n    self,\n    error_type: type[Exception],\n    handler: Callable[[Exception], Awaitable[None]],\n):\n    \"\"\"Register a custom error handler for specific exception types.\n\n    Error handlers allow you to customize how your application responds to\n    different types of errors, providing custom error pages, logging, or\n    recovery mechanisms.\n\n    Args:\n        error_type: The exception class to handle. The handler will be called\n            for this exception type and any of its subclasses.\n        handler: An async function that will be called when the exception occurs.\n            The handler receives the exception instance and can use dependency\n            injection to access request/response objects.\n\n    Examples:\n        Handle 404 errors with a custom page:\n\n        ```python\n        from serv.exceptions import HTTPNotFoundException\n        from serv.responses import ResponseBuilder\n        from bevy import injectable, Inject\n\n        @injectable\n        async def custom_404_handler(\n            error: HTTPNotFoundException,\n            response: Inject[ResponseBuilder]\n        ):\n            response.set_status(404)\n            response.content_type(\"text/html\")\n            response.body(\"&lt;h1&gt;Page Not Found&lt;/h1&gt;&lt;p&gt;Sorry, that page doesn't exist.&lt;/p&gt;\")\n\n        app.add_error_handler(HTTPNotFoundException, custom_404_handler)\n        ```\n\n        Handle validation errors:\n\n        ```python\n        class ValidationError(Exception):\n            def __init__(self, message: str, field: str):\n                self.message = message\n                self.field = field\n\n        @injectable\n        async def validation_error_handler(\n            error: ValidationError,\n            response: Inject[ResponseBuilder]\n        ):\n            response.set_status(400)\n            response.content_type(\"application/json\")\n            response.body({\n                \"error\": \"validation_failed\",\n                \"message\": error.message,\n                \"field\": error.field\n            })\n\n        app.add_error_handler(ValidationError, validation_error_handler)\n        ```\n\n        Generic error handler with logging:\n\n        ```python\n        import logging\n\n        @injectable\n        async def generic_error_handler(\n            error: Exception,\n            response: Inject[ResponseBuilder],\n            request: Inject[Request]\n        ):\n            logging.error(f\"Unhandled error on {request.path}: {error}\")\n            response.set_status(500)\n            response.content_type(\"text/html\")\n            response.body(\"&lt;h1&gt;Internal Server Error&lt;/h1&gt;\")\n\n        app.add_error_handler(Exception, generic_error_handler)\n        ```\n    \"\"\"\n    self._error_handlers[error_type] = handler\n</code></pre>"},{"location":"reference/serv/app/#serv.app.App.add_middleware","title":"add_middleware","text":"<pre><code>add_middleware(\n    middleware: Callable[[], AsyncIterator[None]],\n)\n</code></pre> <p>Add middleware to the application's middleware stack.</p> <p>Middleware functions are executed in the order they are added, wrapping around the request handling process. They can modify requests, responses, add headers, implement authentication, logging, and more.</p> <p>Parameters:</p> Name Type Description Default <code>middleware</code> <code>Callable[[], AsyncIterator[None]]</code> <p>An async generator function that yields control to the next middleware or route handler. The function should yield exactly once.</p> required <p>Examples:</p> <p>Basic logging middleware:</p> <pre><code>import logging\nfrom serv.requests import Request\nfrom bevy import injectable, Inject\n\n@injectable\nasync def logging_middleware(\n    request: Inject[Request]\n):\n    logging.info(f\"Request: {request.method} {request.path}\")\n    start_time = time.time()\n\n    yield  # Pass control to next middleware/handler\n\n    duration = time.time() - start_time\n    logging.info(f\"Response time: {duration:.3f}s\")\n\napp.add_middleware(logging_middleware)\n</code></pre> <p>Authentication middleware:</p> <pre><code>from serv.responses import ResponseBuilder\nfrom serv.requests import Request\nfrom bevy import injectable, Inject\n\n@injectable\nasync def auth_middleware(\n    request: Inject[Request],\n    response: Inject[ResponseBuilder]\n):\n    # Check for authentication\n    auth_header = request.headers.get(\"authorization\")\n    if not auth_header and request.path.startswith(\"/api/\"):\n        response.set_status(401)\n        response.content_type(\"application/json\")\n        response.body({\"error\": \"Authentication required\"})\n        return  # Don't yield, stop processing\n\n    yield  # Continue to next middleware/handler\n\napp.add_middleware(auth_middleware)\n</code></pre> <p>CORS middleware:</p> <pre><code>@injectable\nasync def cors_middleware(\n    request: Inject[Request],\n    response: Inject[ResponseBuilder]\n):\n    # Add CORS headers\n    response.add_header(\"Access-Control-Allow-Origin\", \"*\")\n    response.add_header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n    response.add_header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\n    # Handle preflight requests\n    if request.method == \"OPTIONS\":\n        response.set_status(200)\n        return\n\n    yield  # Continue processing\n\napp.add_middleware(cors_middleware)\n</code></pre> Note <p>Middleware is executed in LIFO (Last In, First Out) order during request processing, and FIFO (First In, First Out) order during response processing.</p> Source code in <code>serv/_app.py</code> <pre><code>def add_middleware(self, middleware: Callable[[], AsyncIterator[None]]):\n    \"\"\"Add middleware to the application's middleware stack.\n\n    Middleware functions are executed in the order they are added, wrapping\n    around the request handling process. They can modify requests, responses,\n    add headers, implement authentication, logging, and more.\n\n    Args:\n        middleware: An async generator function that yields control to the next\n            middleware or route handler. The function should yield exactly once.\n\n    Examples:\n        Basic logging middleware:\n\n        ```python\n        import logging\n        from serv.requests import Request\n        from bevy import injectable, Inject\n\n        @injectable\n        async def logging_middleware(\n            request: Inject[Request]\n        ):\n            logging.info(f\"Request: {request.method} {request.path}\")\n            start_time = time.time()\n\n            yield  # Pass control to next middleware/handler\n\n            duration = time.time() - start_time\n            logging.info(f\"Response time: {duration:.3f}s\")\n\n        app.add_middleware(logging_middleware)\n        ```\n\n        Authentication middleware:\n\n        ```python\n        from serv.responses import ResponseBuilder\n        from serv.requests import Request\n        from bevy import injectable, Inject\n\n        @injectable\n        async def auth_middleware(\n            request: Inject[Request],\n            response: Inject[ResponseBuilder]\n        ):\n            # Check for authentication\n            auth_header = request.headers.get(\"authorization\")\n            if not auth_header and request.path.startswith(\"/api/\"):\n                response.set_status(401)\n                response.content_type(\"application/json\")\n                response.body({\"error\": \"Authentication required\"})\n                return  # Don't yield, stop processing\n\n            yield  # Continue to next middleware/handler\n\n        app.add_middleware(auth_middleware)\n        ```\n\n        CORS middleware:\n\n        ```python\n        @injectable\n        async def cors_middleware(\n            request: Inject[Request],\n            response: Inject[ResponseBuilder]\n        ):\n            # Add CORS headers\n            response.add_header(\"Access-Control-Allow-Origin\", \"*\")\n            response.add_header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n            response.add_header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\n            # Handle preflight requests\n            if request.method == \"OPTIONS\":\n                response.set_status(200)\n                return\n\n            yield  # Continue processing\n\n        app.add_middleware(cors_middleware)\n        ```\n\n    Note:\n        Middleware is executed in LIFO (Last In, First Out) order during request\n        processing, and FIFO (First In, First Out) order during response processing.\n    \"\"\"\n    self._middleware.append(middleware)\n</code></pre>"},{"location":"reference/serv/app/#serv.app.App.emit","title":"emit  <code>async</code>","text":"<pre><code>emit(\n    event: str, *, container: Inject[Container], **kwargs\n) -&gt; None\n</code></pre> <p>Async emit method for EventEmitterProtocol compliance.</p> Source code in <code>serv/_app.py</code> <pre><code>@injectable\nasync def emit(self, event: str, *, container: Inject[Container], **kwargs) -&gt; None:\n    \"\"\"Async emit method for EventEmitterProtocol compliance.\"\"\"\n    await self._emit.emit(event, container=container, **kwargs)\n</code></pre>"},{"location":"reference/serv/app/#serv.app.App.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(callback: Callable[[], Awaitable[None]])\n</code></pre> <p>Add a callback to be called when the application is shutting down.</p> Source code in <code>serv/_app.py</code> <pre><code>def on_shutdown(self, callback: Callable[[], Awaitable[None]]):\n    \"\"\"Add a callback to be called when the application is shutting down.\"\"\"\n    self._async_exit_stack.push_async_callback(callback)\n</code></pre>"},{"location":"reference/serv/bundled/","title":"bundled","text":""},{"location":"reference/serv/bundled/#serv.bundled","title":"serv.bundled","text":""},{"location":"reference/serv/bundled/database/","title":"database","text":""},{"location":"reference/serv/bundled/database/#serv.bundled.database","title":"serv.bundled.database","text":"<p>Bundled database providers for Serv.</p>"},{"location":"reference/serv/bundled/database/ommi/","title":"ommi","text":""},{"location":"reference/serv/bundled/database/ommi/#serv.bundled.database.ommi","title":"serv.bundled.database.ommi","text":"<p>Ommi database provider for Serv.</p>"},{"location":"reference/serv/bundled/database/ommi/#serv.bundled.database.ommi.create_ommi","title":"create_ommi  <code>async</code>","text":"<pre><code>create_ommi(\n    name: str,\n    connection_string: str = \"sqlite:///:memory:\",\n    qualifier: str | None = None,\n    **kwargs,\n) -&gt; Any\n</code></pre> <p>Create Ommi database instance with auto-detected driver (PRIMARY FACTORY).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>connection_string</code> <code>str</code> <p>Database connection string</p> <code>'sqlite:///:memory:'</code> <code>qualifier</code> <code>str | None</code> <p>Optional qualifier for DI</p> <code>None</code> <code>**kwargs</code> <p>Additional driver parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Configured Ommi instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If database scheme is unsupported</p> Source code in <code>serv/bundled/database/ommi/factory.py</code> <pre><code>async def create_ommi(\n    name: str,\n    connection_string: str = \"sqlite:///:memory:\",\n    qualifier: str | None = None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Create Ommi database instance with auto-detected driver (PRIMARY FACTORY).\n\n    Args:\n        name: Database name\n        connection_string: Database connection string\n        qualifier: Optional qualifier for DI\n        **kwargs: Additional driver parameters\n\n    Returns:\n        Configured Ommi instance\n\n    Raises:\n        ValueError: If database scheme is unsupported\n    \"\"\"\n    Ommi = _import_ommi()\n\n    # Auto-detect driver from connection string scheme\n    if connection_string.startswith(\"sqlite\"):\n        SQLiteDriver = _import_sqlite_driver()\n        from ommi.ext.drivers.sqlite.driver import SQLiteSettings\n\n        # Extract database path from connection string\n        # Format: sqlite:///path/to/db.db -&gt; path/to/db.db\n        if connection_string.startswith(\"sqlite:///\"):\n            database_path = connection_string[10:]  # Remove \"sqlite:///\"\n        elif connection_string.startswith(\"sqlite://\"):\n            database_path = connection_string[9:]  # Remove \"sqlite://\"\n        else:\n            database_path = connection_string\n\n        # Create SQLiteSettings with the database path\n        settings = SQLiteSettings(database_path=database_path)\n        driver = SQLiteDriver.connect(settings)\n    elif connection_string.startswith(\"postgresql\"):\n        PostgreSQLDriver = _import_postgresql_driver()\n        driver = PostgreSQLDriver.connect(connection_string, **kwargs)\n    else:\n        # Extract scheme for error message\n        scheme = (\n            connection_string.split(\"://\")[0]\n            if \"://\" in connection_string\n            else connection_string\n        )\n        raise ValueError(f\"Unsupported database scheme: {scheme}\")\n\n    # Create Ommi instance\n    ommi_instance = Ommi(driver)\n    await ommi_instance.__aenter__()\n\n    # Register cleanup\n    async def cleanup():\n        await ommi_instance.__aexit__(None, None, None)\n\n    ommi_instance._cleanup = cleanup\n\n    return ommi_instance\n</code></pre>"},{"location":"reference/serv/bundled/database/ommi/#serv.bundled.database.ommi.create_ommi_postgresql","title":"create_ommi_postgresql  <code>async</code>","text":"<pre><code>create_ommi_postgresql(\n    name: str,\n    host: str = \"localhost\",\n    port: int = 5432,\n    database: str = \"postgres\",\n    username: str = \"postgres\",\n    password: str = \"\",\n    qualifier: str | None = None,\n    **kwargs,\n) -&gt; Any\n</code></pre> <p>Create Ommi instance with PostgreSQL database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>host</code> <code>str</code> <p>PostgreSQL host</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>PostgreSQL port</p> <code>5432</code> <code>database</code> <code>str</code> <p>Database name</p> <code>'postgres'</code> <code>username</code> <code>str</code> <p>Username</p> <code>'postgres'</code> <code>password</code> <code>str</code> <p>Password</p> <code>''</code> <code>qualifier</code> <code>str | None</code> <p>Optional qualifier for DI</p> <code>None</code> <code>**kwargs</code> <p>Additional driver parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Configured Ommi instance with PostgreSQL</p> Source code in <code>serv/bundled/database/ommi/factory.py</code> <pre><code>async def create_ommi_postgresql(\n    name: str,\n    host: str = \"localhost\",\n    port: int = 5432,\n    database: str = \"postgres\",\n    username: str = \"postgres\",\n    password: str = \"\",\n    qualifier: str | None = None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Create Ommi instance with PostgreSQL database.\n\n    Args:\n        name: Database name\n        host: PostgreSQL host\n        port: PostgreSQL port\n        database: Database name\n        username: Username\n        password: Password\n        qualifier: Optional qualifier for DI\n        **kwargs: Additional driver parameters\n\n    Returns:\n        Configured Ommi instance with PostgreSQL\n    \"\"\"\n    connection_string = f\"postgresql://{username}:{password}@{host}:{port}/{database}\"\n    return await create_ommi(name, connection_string, qualifier, **kwargs)\n</code></pre>"},{"location":"reference/serv/bundled/database/ommi/#serv.bundled.database.ommi.create_ommi_sqlite","title":"create_ommi_sqlite  <code>async</code>","text":"<pre><code>create_ommi_sqlite(\n    name: str,\n    database_path: str = \":memory:\",\n    qualifier: str | None = None,\n    **kwargs,\n) -&gt; Any\n</code></pre> <p>Create Ommi instance with SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>database_path</code> <code>str</code> <p>Path to SQLite database file</p> <code>':memory:'</code> <code>qualifier</code> <code>str | None</code> <p>Optional qualifier for DI</p> <code>None</code> <code>**kwargs</code> <p>Additional driver parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Configured Ommi instance with SQLite</p> Source code in <code>serv/bundled/database/ommi/factory.py</code> <pre><code>async def create_ommi_sqlite(\n    name: str, database_path: str = \":memory:\", qualifier: str | None = None, **kwargs\n) -&gt; Any:\n    \"\"\"Create Ommi instance with SQLite database.\n\n    Args:\n        name: Database name\n        database_path: Path to SQLite database file\n        qualifier: Optional qualifier for DI\n        **kwargs: Additional driver parameters\n\n    Returns:\n        Configured Ommi instance with SQLite\n    \"\"\"\n    connection_string = f\"sqlite:///{database_path}\"\n    return await create_ommi(name, connection_string, qualifier, **kwargs)\n</code></pre>"},{"location":"reference/serv/bundled/database/ommi/factory/","title":"factory","text":""},{"location":"reference/serv/bundled/database/ommi/factory/#serv.bundled.database.ommi.factory","title":"serv.bundled.database.ommi.factory","text":"<p>Ommi database provider factory functions.</p>"},{"location":"reference/serv/bundled/database/ommi/factory/#serv.bundled.database.ommi.factory.create_ommi","title":"create_ommi  <code>async</code>","text":"<pre><code>create_ommi(\n    name: str,\n    connection_string: str = \"sqlite:///:memory:\",\n    qualifier: str | None = None,\n    **kwargs,\n) -&gt; Any\n</code></pre> <p>Create Ommi database instance with auto-detected driver (PRIMARY FACTORY).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>connection_string</code> <code>str</code> <p>Database connection string</p> <code>'sqlite:///:memory:'</code> <code>qualifier</code> <code>str | None</code> <p>Optional qualifier for DI</p> <code>None</code> <code>**kwargs</code> <p>Additional driver parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Configured Ommi instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If database scheme is unsupported</p> Source code in <code>serv/bundled/database/ommi/factory.py</code> <pre><code>async def create_ommi(\n    name: str,\n    connection_string: str = \"sqlite:///:memory:\",\n    qualifier: str | None = None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Create Ommi database instance with auto-detected driver (PRIMARY FACTORY).\n\n    Args:\n        name: Database name\n        connection_string: Database connection string\n        qualifier: Optional qualifier for DI\n        **kwargs: Additional driver parameters\n\n    Returns:\n        Configured Ommi instance\n\n    Raises:\n        ValueError: If database scheme is unsupported\n    \"\"\"\n    Ommi = _import_ommi()\n\n    # Auto-detect driver from connection string scheme\n    if connection_string.startswith(\"sqlite\"):\n        SQLiteDriver = _import_sqlite_driver()\n        from ommi.ext.drivers.sqlite.driver import SQLiteSettings\n\n        # Extract database path from connection string\n        # Format: sqlite:///path/to/db.db -&gt; path/to/db.db\n        if connection_string.startswith(\"sqlite:///\"):\n            database_path = connection_string[10:]  # Remove \"sqlite:///\"\n        elif connection_string.startswith(\"sqlite://\"):\n            database_path = connection_string[9:]  # Remove \"sqlite://\"\n        else:\n            database_path = connection_string\n\n        # Create SQLiteSettings with the database path\n        settings = SQLiteSettings(database_path=database_path)\n        driver = SQLiteDriver.connect(settings)\n    elif connection_string.startswith(\"postgresql\"):\n        PostgreSQLDriver = _import_postgresql_driver()\n        driver = PostgreSQLDriver.connect(connection_string, **kwargs)\n    else:\n        # Extract scheme for error message\n        scheme = (\n            connection_string.split(\"://\")[0]\n            if \"://\" in connection_string\n            else connection_string\n        )\n        raise ValueError(f\"Unsupported database scheme: {scheme}\")\n\n    # Create Ommi instance\n    ommi_instance = Ommi(driver)\n    await ommi_instance.__aenter__()\n\n    # Register cleanup\n    async def cleanup():\n        await ommi_instance.__aexit__(None, None, None)\n\n    ommi_instance._cleanup = cleanup\n\n    return ommi_instance\n</code></pre>"},{"location":"reference/serv/bundled/database/ommi/factory/#serv.bundled.database.ommi.factory.create_ommi_nested","title":"create_ommi_nested  <code>async</code>","text":"<pre><code>create_ommi_nested(\n    name: str, settings: dict[str, Any] | None = None\n) -&gt; Any\n</code></pre> <p>Create Ommi instance with nested settings (backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>settings</code> <code>dict[str, Any] | None</code> <p>Nested configuration dictionary</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Configured Ommi instance</p> Source code in <code>serv/bundled/database/ommi/factory.py</code> <pre><code>async def create_ommi_nested(name: str, settings: dict[str, Any] | None = None) -&gt; Any:\n    \"\"\"Create Ommi instance with nested settings (backward compatibility).\n\n    Args:\n        name: Database name\n        settings: Nested configuration dictionary\n\n    Returns:\n        Configured Ommi instance\n    \"\"\"\n    config = settings or {}\n    connection_string = config.get(\"connection_string\", \"sqlite:///:memory:\")\n    qualifier = config.get(\"qualifier\")\n\n    # Forward to the main factory with auto-detection\n    return await create_ommi(\n        name,\n        connection_string,\n        qualifier,\n        **{\n            k: v\n            for k, v in config.items()\n            if k not in [\"connection_string\", \"qualifier\"]\n        },\n    )\n</code></pre>"},{"location":"reference/serv/bundled/database/ommi/factory/#serv.bundled.database.ommi.factory.create_ommi_postgresql","title":"create_ommi_postgresql  <code>async</code>","text":"<pre><code>create_ommi_postgresql(\n    name: str,\n    host: str = \"localhost\",\n    port: int = 5432,\n    database: str = \"postgres\",\n    username: str = \"postgres\",\n    password: str = \"\",\n    qualifier: str | None = None,\n    **kwargs,\n) -&gt; Any\n</code></pre> <p>Create Ommi instance with PostgreSQL database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>host</code> <code>str</code> <p>PostgreSQL host</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>PostgreSQL port</p> <code>5432</code> <code>database</code> <code>str</code> <p>Database name</p> <code>'postgres'</code> <code>username</code> <code>str</code> <p>Username</p> <code>'postgres'</code> <code>password</code> <code>str</code> <p>Password</p> <code>''</code> <code>qualifier</code> <code>str | None</code> <p>Optional qualifier for DI</p> <code>None</code> <code>**kwargs</code> <p>Additional driver parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Configured Ommi instance with PostgreSQL</p> Source code in <code>serv/bundled/database/ommi/factory.py</code> <pre><code>async def create_ommi_postgresql(\n    name: str,\n    host: str = \"localhost\",\n    port: int = 5432,\n    database: str = \"postgres\",\n    username: str = \"postgres\",\n    password: str = \"\",\n    qualifier: str | None = None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Create Ommi instance with PostgreSQL database.\n\n    Args:\n        name: Database name\n        host: PostgreSQL host\n        port: PostgreSQL port\n        database: Database name\n        username: Username\n        password: Password\n        qualifier: Optional qualifier for DI\n        **kwargs: Additional driver parameters\n\n    Returns:\n        Configured Ommi instance with PostgreSQL\n    \"\"\"\n    connection_string = f\"postgresql://{username}:{password}@{host}:{port}/{database}\"\n    return await create_ommi(name, connection_string, qualifier, **kwargs)\n</code></pre>"},{"location":"reference/serv/bundled/database/ommi/factory/#serv.bundled.database.ommi.factory.create_ommi_sqlite","title":"create_ommi_sqlite  <code>async</code>","text":"<pre><code>create_ommi_sqlite(\n    name: str,\n    database_path: str = \":memory:\",\n    qualifier: str | None = None,\n    **kwargs,\n) -&gt; Any\n</code></pre> <p>Create Ommi instance with SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>database_path</code> <code>str</code> <p>Path to SQLite database file</p> <code>':memory:'</code> <code>qualifier</code> <code>str | None</code> <p>Optional qualifier for DI</p> <code>None</code> <code>**kwargs</code> <p>Additional driver parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Configured Ommi instance with SQLite</p> Source code in <code>serv/bundled/database/ommi/factory.py</code> <pre><code>async def create_ommi_sqlite(\n    name: str, database_path: str = \":memory:\", qualifier: str | None = None, **kwargs\n) -&gt; Any:\n    \"\"\"Create Ommi instance with SQLite database.\n\n    Args:\n        name: Database name\n        database_path: Path to SQLite database file\n        qualifier: Optional qualifier for DI\n        **kwargs: Additional driver parameters\n\n    Returns:\n        Configured Ommi instance with SQLite\n    \"\"\"\n    connection_string = f\"sqlite:///{database_path}\"\n    return await create_ommi(name, connection_string, qualifier, **kwargs)\n</code></pre>"},{"location":"reference/serv/bundled/extensions/","title":"extensions","text":""},{"location":"reference/serv/bundled/extensions/#serv.bundled.extensions","title":"serv.bundled.extensions","text":""},{"location":"reference/serv/bundled/extensions/welcome/","title":"welcome","text":""},{"location":"reference/serv/bundled/extensions/welcome/#serv.bundled.extensions.welcome","title":"serv.bundled.extensions.welcome","text":""},{"location":"reference/serv/bundled/extensions/welcome/#serv.bundled.extensions.welcome.WelcomeRoute","title":"WelcomeRoute","text":"<p>               Bases: <code>Route</code></p> <p>Route handler for the welcome page.</p> <p>This route serves the default welcome page at the root path (\"/\") for new Serv applications. It renders a Jinja2 template that provides information about Serv, getting started guidance, and links to documentation.</p> <p>The route uses the Jinja2Response type annotation to automatically wrap the returned template name and context in a proper HTML response.</p> <p>Examples:</p> <pre><code># Accessing the welcome page\n# GET / -&gt; Renders welcome.html template\n</code></pre> <p>The route can also be used as a reference for creating other template-based routes:</p> <pre><code>class MyRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[tuple[str, dict[str, Any]], Jinja2Response]:\n        context = {\"user\": \"John\", \"message\": \"Hello!\"}\n        return (\"my_template.html\", context)\n</code></pre>"},{"location":"reference/serv/bundled/extensions/welcome/#serv.bundled.extensions.welcome.WelcomeRoute.show_welcome_page","title":"show_welcome_page  <code>async</code>","text":"<pre><code>show_welcome_page(\n    _: GetRequest,\n) -&gt; Annotated[tuple[str, dict[str, Any]], Jinja2Response]\n</code></pre> <p>Handle GET requests to display the welcome page.</p> <p>Returns:</p> Type Description <code>Annotated[tuple[str, dict[str, Any]], Jinja2Response]</code> <p>A tuple containing the template name and context dictionary</p> <code>Annotated[tuple[str, dict[str, Any]], Jinja2Response]</code> <p>for rendering the welcome page.</p> Source code in <code>serv/bundled/extensions/welcome/welcome.py</code> <pre><code>@handle.GET\nasync def show_welcome_page(\n    self, _: GetRequest\n) -&gt; Annotated[tuple[str, dict[str, Any]], Jinja2Response]:\n    \"\"\"Handle GET requests to display the welcome page.\n\n    Returns:\n        A tuple containing the template name and context dictionary\n        for rendering the welcome page.\n    \"\"\"\n    # The Jinja2Response expects (template_name, context_dict)\n    # The context dict is currently empty as the template is static.\n    return (\"welcome.html\", {})\n</code></pre>"},{"location":"reference/serv/bundled/extensions/welcome/welcome/","title":"welcome","text":""},{"location":"reference/serv/bundled/extensions/welcome/welcome/#serv.bundled.extensions.welcome.welcome","title":"serv.bundled.extensions.welcome.welcome","text":"<p>Welcome Extension - Default landing page for new Serv applications.</p> <p>This module provides the built-in welcome extension that displays a friendly landing page for new Serv applications. The extension is automatically enabled when no other extensions are configured, providing immediate feedback that the application is running correctly.</p> <p>The welcome extension demonstrates several key Serv concepts: - Extension architecture and lifecycle hooks - Route registration and handling - Template rendering with Jinja2 - Conditional route registration to avoid conflicts</p> Components <p>WelcomeRoute: A simple route handler that renders the welcome template</p> <p>The extension registers a GET route at the root path (\"/\") that displays a welcome page with information about Serv, links to documentation, and getting started guidance. It only registers the route if no other route is already handling the root path, ensuring it doesn't interfere with user-defined routes.</p> Example <p>The welcome extension is automatically loaded when creating a new Serv app with no other extensions configured:</p> <pre><code>from serv import App\n\n# Creates app with welcome extension automatically enabled\napp = App()\n\n# Visit http://localhost:8000/ to see the welcome page\n</code></pre> <p>To disable the welcome extension, simply configure other extensions:</p> <pre><code># In serv.config.yaml:\nextensions:\n  - name: \"my_extension\"\n    entry: \"extensions.my_extension:MyExtension\"\n</code></pre> Note <p>This extension is part of Serv's bundled extensions and is located in the serv.bundled.extensions.welcome package. It serves as both a useful default and an example of how to create Serv extensions.</p>"},{"location":"reference/serv/bundled/extensions/welcome/welcome/#serv.bundled.extensions.welcome.welcome.WelcomeRoute","title":"WelcomeRoute","text":"<p>               Bases: <code>Route</code></p> <p>Route handler for the welcome page.</p> <p>This route serves the default welcome page at the root path (\"/\") for new Serv applications. It renders a Jinja2 template that provides information about Serv, getting started guidance, and links to documentation.</p> <p>The route uses the Jinja2Response type annotation to automatically wrap the returned template name and context in a proper HTML response.</p> <p>Examples:</p> <pre><code># Accessing the welcome page\n# GET / -&gt; Renders welcome.html template\n</code></pre> <p>The route can also be used as a reference for creating other template-based routes:</p> <pre><code>class MyRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[tuple[str, dict[str, Any]], Jinja2Response]:\n        context = {\"user\": \"John\", \"message\": \"Hello!\"}\n        return (\"my_template.html\", context)\n</code></pre>"},{"location":"reference/serv/bundled/extensions/welcome/welcome/#serv.bundled.extensions.welcome.welcome.WelcomeRoute.show_welcome_page","title":"show_welcome_page  <code>async</code>","text":"<pre><code>show_welcome_page(\n    _: GetRequest,\n) -&gt; Annotated[tuple[str, dict[str, Any]], Jinja2Response]\n</code></pre> <p>Handle GET requests to display the welcome page.</p> <p>Returns:</p> Type Description <code>Annotated[tuple[str, dict[str, Any]], Jinja2Response]</code> <p>A tuple containing the template name and context dictionary</p> <code>Annotated[tuple[str, dict[str, Any]], Jinja2Response]</code> <p>for rendering the welcome page.</p> Source code in <code>serv/bundled/extensions/welcome/welcome.py</code> <pre><code>@handle.GET\nasync def show_welcome_page(\n    self, _: GetRequest\n) -&gt; Annotated[tuple[str, dict[str, Any]], Jinja2Response]:\n    \"\"\"Handle GET requests to display the welcome page.\n\n    Returns:\n        A tuple containing the template name and context dictionary\n        for rendering the welcome page.\n    \"\"\"\n    # The Jinja2Response expects (template_name, context_dict)\n    # The context dict is currently empty as the template is static.\n    return (\"welcome.html\", {})\n</code></pre>"},{"location":"reference/serv/database/","title":"database","text":""},{"location":"reference/serv/database/#serv.database","title":"serv.database","text":"<p>Database integration system for Serv.</p>"},{"location":"reference/serv/database/#serv.database.DatabaseConfigurationError","title":"DatabaseConfigurationError","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Configuration-related database errors.</p>"},{"location":"reference/serv/database/#serv.database.DatabaseConnectionError","title":"DatabaseConnectionError","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Connection-related database errors.</p>"},{"location":"reference/serv/database/#serv.database.DatabaseError","title":"DatabaseError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for database operations.</p>"},{"location":"reference/serv/database/#serv.database.DatabaseFactoryError","title":"DatabaseFactoryError","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Factory loading/invocation errors.</p>"},{"location":"reference/serv/database/#serv.database.DatabaseLifecycleError","title":"DatabaseLifecycleError","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Lifecycle management errors.</p>"},{"location":"reference/serv/database/#serv.database.DatabaseManager","title":"DatabaseManager","text":"<pre><code>DatabaseManager(\n    app_config: dict[str, Any], container: Container\n)\n</code></pre> <p>Manages database connections defined in configuration. Handles factory loading, connection lifecycle, and DI registration.</p> <p>Initialize database manager.</p> <p>Parameters:</p> Name Type Description Default <code>app_config</code> <code>dict[str, Any]</code> <p>Application configuration dictionary</p> required <code>container</code> <code>Container</code> <p>Bevy DI container for registering connections</p> required Source code in <code>serv/database/manager.py</code> <pre><code>def __init__(self, app_config: dict[str, Any], container: Container):\n    \"\"\"Initialize database manager.\n\n    Args:\n        app_config: Application configuration dictionary\n        container: Bevy DI container for registering connections\n    \"\"\"\n    self.config = app_config.get(\"databases\", {})\n    self.container = container\n    self.connections: dict[str, Any] = {}\n    self.exit_stack = AsyncExitStack()\n    self.lifecycle = DatabaseLifecycle(self, self.exit_stack)\n</code></pre>"},{"location":"reference/serv/database/#serv.database.DatabaseManager.create_connection","title":"create_connection  <code>async</code>","text":"<pre><code>create_connection(name: str, config: dict[str, Any]) -&gt; Any\n</code></pre> <p>Create single database connection from config with qualifier support.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>config</code> <code>dict[str, Any]</code> <p>Database configuration</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Database connection instance</p> <p>Raises:</p> Type Description <code>DatabaseConfigurationError</code> <p>If configuration is invalid</p> <code>DatabaseConnectionError</code> <p>If connection creation fails</p> Source code in <code>serv/database/manager.py</code> <pre><code>async def create_connection(self, name: str, config: dict[str, Any]) -&gt; Any:\n    \"\"\"Create single database connection from config with qualifier support.\n\n    Args:\n        name: Database name\n        config: Database configuration\n\n    Returns:\n        Database connection instance\n\n    Raises:\n        DatabaseConfigurationError: If configuration is invalid\n        DatabaseConnectionError: If connection creation fails\n    \"\"\"\n    if \"provider\" not in config:\n        raise DatabaseConfigurationError(\n            f\"Database '{name}' missing required 'provider' field\"\n        )\n\n    provider = config[\"provider\"]\n\n    try:\n        # Load factory function\n        factory = FactoryLoader.load_factory(provider)\n\n        # Create connection using factory\n        connection = await FactoryLoader.invoke_factory(factory, name, config)\n\n        return connection\n\n    except Exception as e:\n        raise DatabaseConnectionError(\n            f\"Failed to create connection for database '{name}': {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/database/#serv.database.DatabaseManager.initialize_databases","title":"initialize_databases  <code>async</code>","text":"<pre><code>initialize_databases() -&gt; None\n</code></pre> <p>Initialize all configured database connections.</p> <p>Raises:</p> Type Description <code>DatabaseConfigurationError</code> <p>If configuration is invalid</p> <code>DatabaseConnectionError</code> <p>If connection creation fails</p> Source code in <code>serv/database/manager.py</code> <pre><code>async def initialize_databases(self) -&gt; None:\n    \"\"\"Initialize all configured database connections.\n\n    Raises:\n        DatabaseConfigurationError: If configuration is invalid\n        DatabaseConnectionError: If connection creation fails\n    \"\"\"\n    if not self.config:\n        return  # No databases configured\n\n    for name, db_config in self.config.items():\n        try:\n            connection = await self.create_connection(name, db_config)\n            self.connections[name] = connection\n\n            # Register with DI container\n            self.register_connection(name, connection)\n\n            # Register cleanup\n            self.lifecycle.register_cleanup(connection)\n\n        except Exception as e:\n            raise DatabaseConnectionError(\n                f\"Failed to initialize database '{name}': {str(e)}\"\n            ) from e\n</code></pre>"},{"location":"reference/serv/database/#serv.database.DatabaseManager.register_connection","title":"register_connection","text":"<pre><code>register_connection(name: str, connection: Any) -&gt; None\n</code></pre> <p>Register database connection with dependency injection using Bevy 3.1 qualifiers.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>connection</code> <code>Any</code> <p>Database connection instance</p> required Source code in <code>serv/database/manager.py</code> <pre><code>def register_connection(self, name: str, connection: Any) -&gt; None:\n    \"\"\"Register database connection with dependency injection using Bevy 3.1 qualifiers.\n\n    Args:\n        name: Database name\n        connection: Database connection instance\n    \"\"\"\n    # Register by factory return type with qualifier\n    # This allows multiple instances of the same type (e.g., multiple Ommi instances)\n    self.container.add(type(connection), connection, qualifier=name)\n</code></pre>"},{"location":"reference/serv/database/#serv.database.DatabaseManager.shutdown_databases","title":"shutdown_databases  <code>async</code>","text":"<pre><code>shutdown_databases() -&gt; None\n</code></pre> <p>Shutdown all database connections.</p> Source code in <code>serv/database/manager.py</code> <pre><code>async def shutdown_databases(self) -&gt; None:\n    \"\"\"Shutdown all database connections.\"\"\"\n    await self.exit_stack.aclose()\n    self.connections.clear()\n</code></pre>"},{"location":"reference/serv/database/cli/","title":"cli","text":""},{"location":"reference/serv/database/cli/#serv.database.cli","title":"serv.database.cli","text":"<p>Database CLI commands for Serv.</p>"},{"location":"reference/serv/database/cli/#serv.database.cli.handle_database_config_command","title":"handle_database_config_command","text":"<pre><code>handle_database_config_command(args_ns)\n</code></pre> <p>Handles the 'database config' command.</p> Source code in <code>serv/database/cli.py</code> <pre><code>def handle_database_config_command(args_ns):\n    \"\"\"Handles the 'database config' command.\"\"\"\n    logger.debug(\"Database config command started.\")\n\n    print(\"\ud83d\udcd6 Database Configuration Examples:\")\n    print(\"=\" * 50)\n\n    # Try to load the template file\n    try:\n        import importlib.util\n\n        template_dir = (\n            Path(importlib.util.find_spec(\"serv.cli\").submodule_search_locations[0])\n            / \"scaffolding\"\n        )\n        template_path = template_dir / \"database_configs.yaml\"\n\n        if template_path.exists():\n            print(f\"\ud83d\udcc4 Loading templates from: {template_path}\")\n            print(\"\\n\" + \"=\" * 50 + \"\\n\")\n\n            with open(template_path) as f:\n                content = f.read()\n\n            # Display the template file content\n            print(content)\n\n            print(\"\\n\" + \"=\" * 50)\n            print(\"\ud83d\udca1 Usage Instructions:\")\n            print(\n                \"1. Copy the relevant database configurations to your serv.config.yaml\"\n            )\n            print(\"2. Place them under the 'databases:' section\")\n            print(\"3. Customize connection strings and parameters as needed\")\n            print(\"4. Set up environment variables for sensitive data\")\n\n        else:\n            # Fallback to inline examples if template file not found\n            _show_inline_database_examples()\n\n    except Exception as e:\n        logger.warning(f\"Could not load database templates: {e}\")\n        # Fallback to inline examples\n        _show_inline_database_examples()\n\n    return True\n</code></pre>"},{"location":"reference/serv/database/cli/#serv.database.cli.handle_database_list_command","title":"handle_database_list_command","text":"<pre><code>handle_database_list_command(args_ns)\n</code></pre> <p>Handles the 'database list' command.</p> Source code in <code>serv/database/cli.py</code> <pre><code>def handle_database_list_command(args_ns):\n    \"\"\"Handles the 'database list' command.\"\"\"\n    logger.debug(\"Database list command started.\")\n\n    config_path = Path.cwd() / DEFAULT_CONFIG_FILE\n    if not config_path.exists():\n        print(f\"\u274c Configuration file '{config_path}' not found\")\n        print(\"   Run 'serv create app' to create a configuration file\")\n        return False\n\n    try:\n        config = load_raw_config(config_path)\n        databases = config.get(\"databases\", {})\n\n        if not databases:\n            print(\"\u2139\ufe0f  No databases configured\")\n            print(\n                \"   Add databases to your serv.config.yaml file or use 'serv database config' for examples\"\n            )\n            return True\n\n        print(f\"\ud83d\udcca Configured databases ({len(databases)}):\")\n        print(\"=\" * 50)\n\n        for name, db_config in databases.items():\n            provider = db_config.get(\"provider\", \"Unknown\")\n            qualifier = db_config.get(\"qualifier\", name)\n            connection_string = db_config.get(\"connection_string\", \"Not specified\")\n\n            # Mask credentials in connection string for display\n            display_connection = _mask_credentials(connection_string)\n\n            print(f\"\u2022 {name}\")\n            print(f\"  Provider: {provider}\")\n            print(f\"  Qualifier: {qualifier}\")\n            print(f\"  Connection: {display_connection}\")\n            print()\n\n        return True\n\n    except Exception as e:\n        logger.error(f\"Error listing databases: {e}\")\n        print(f\"\u274c Error listing databases: {e}\")\n        return False\n</code></pre>"},{"location":"reference/serv/database/cli/#serv.database.cli.handle_database_providers_command","title":"handle_database_providers_command","text":"<pre><code>handle_database_providers_command(args_ns)\n</code></pre> <p>Handles the 'database providers' command.</p> Source code in <code>serv/database/cli.py</code> <pre><code>def handle_database_providers_command(args_ns):\n    \"\"\"Handles the 'database providers' command.\"\"\"\n    logger.debug(\"Database providers command started.\")\n\n    print(\"\ud83d\udd0c Available Database Providers:\")\n    print(\"=\" * 50)\n\n    providers = [\n        {\n            \"name\": \"Ommi ORM (Default)\",\n            \"provider\": \"serv.bundled.database.ommi:create_ommi\",\n            \"description\": \"Primary ORM for Serv with auto-detected drivers\",\n            \"schemes\": [\"sqlite://\", \"postgresql://\"],\n            \"recommended\": True,\n        },\n        {\n            \"name\": \"Ommi SQLite\",\n            \"provider\": \"serv.bundled.database.ommi:create_ommi_sqlite\",\n            \"description\": \"Ommi with SQLite database (convenience factory)\",\n            \"schemes\": [\"sqlite://\"],\n            \"recommended\": True,\n        },\n        {\n            \"name\": \"Ommi PostgreSQL\",\n            \"provider\": \"serv.bundled.database.ommi:create_ommi_postgresql\",\n            \"description\": \"Ommi with PostgreSQL database (convenience factory)\",\n            \"schemes\": [\"postgresql://\"],\n            \"recommended\": True,\n        },\n        {\n            \"name\": \"Ommi Nested\",\n            \"provider\": \"serv.bundled.database.ommi:create_ommi_nested\",\n            \"description\": \"Ommi with nested settings (backward compatibility)\",\n            \"schemes\": [\"Various\"],\n            \"recommended\": False,\n        },\n    ]\n\n    for provider in providers:\n        status = \"\ud83c\udf1f RECOMMENDED\" if provider[\"recommended\"] else \"\u2139\ufe0f  Available\"\n        print(f\"\\n{status}\")\n        print(f\"Name: {provider['name']}\")\n        print(f\"Provider: {provider['provider']}\")\n        print(f\"Description: {provider['description']}\")\n        print(f\"Supported schemes: {', '.join(provider['schemes'])}\")\n\n    print(\"\\n\ud83d\udca1 Custom Providers:\")\n    print(\"You can create custom providers by implementing factory functions\")\n    print(\"Format: 'module.path:factory_function'\")\n    print(\"\\n\ud83d\udcda See the provider development documentation for more details\")\n\n    return True\n</code></pre>"},{"location":"reference/serv/database/cli/#serv.database.cli.handle_database_status_command","title":"handle_database_status_command","text":"<pre><code>handle_database_status_command(args_ns)\n</code></pre> <p>Handles the 'database status' command.</p> Source code in <code>serv/database/cli.py</code> <pre><code>def handle_database_status_command(args_ns):\n    \"\"\"Handles the 'database status' command.\"\"\"\n    logger.debug(\"Database status command started.\")\n\n    config_path = Path.cwd() / DEFAULT_CONFIG_FILE\n    if not config_path.exists():\n        print(f\"\u274c Configuration file '{config_path}' not found\")\n        return False\n\n    try:\n        config = load_raw_config(config_path)\n        databases = config.get(\"databases\", {})\n\n        if not databases:\n            print(\"\u2139\ufe0f  No databases configured\")\n            return True\n\n        # Filter by specific database if provided\n        if hasattr(args_ns, \"name\") and args_ns.name:\n            if args_ns.name not in databases:\n                print(f\"\u274c Database '{args_ns.name}' not found in configuration\")\n                return False\n            databases = {args_ns.name: databases[args_ns.name]}\n\n        print(\"\ud83d\udd0d Database Status:\")\n        print(\"=\" * 50)\n\n        for name, db_config in databases.items():\n            print(f\"Database: {name}\")\n\n            try:\n                # Test connection creation (don't actually connect)\n                provider = db_config.get(\"provider\")\n                if not provider:\n                    print(\"  \u274c Missing provider\")\n                    continue\n\n                from serv.database.factory import FactoryLoader\n\n                FactoryLoader.load_factory(provider)\n                print(f\"  \u2705 Provider loadable: {provider}\")\n\n                # Check configuration\n                config_style = FactoryLoader.detect_config_style(db_config)\n                print(f\"  \u2139\ufe0f  Config style: {config_style}\")\n\n                # Check for required fields\n                if config_style == \"nested\":\n                    settings = db_config.get(\"settings\", {})\n                    print(f\"  \u2139\ufe0f  Settings: {len(settings)} parameters\")\n                else:\n                    flat_params = {\n                        k: v\n                        for k, v in db_config.items()\n                        if k not in [\"provider\", \"qualifier\"]\n                    }\n                    print(f\"  \u2139\ufe0f  Parameters: {len(flat_params)} flat parameters\")\n\n                qualifier = db_config.get(\"qualifier\", name)\n                print(f\"  \u2139\ufe0f  Qualifier: {qualifier}\")\n\n            except Exception as e:\n                print(f\"  \u274c Configuration error: {e}\")\n\n            print()\n\n        return True\n\n    except Exception as e:\n        logger.error(f\"Error checking database status: {e}\")\n        print(f\"\u274c Error checking database status: {e}\")\n        return False\n</code></pre>"},{"location":"reference/serv/database/cli/#serv.database.cli.handle_database_test_command","title":"handle_database_test_command","text":"<pre><code>handle_database_test_command(args_ns)\n</code></pre> <p>Handles the 'database test' command.</p> Source code in <code>serv/database/cli.py</code> <pre><code>def handle_database_test_command(args_ns):\n    \"\"\"Handles the 'database test' command.\"\"\"\n    import asyncio\n\n    return asyncio.run(_async_database_test_command(args_ns))\n</code></pre>"},{"location":"reference/serv/database/exceptions/","title":"exceptions","text":""},{"location":"reference/serv/database/exceptions/#serv.database.exceptions","title":"serv.database.exceptions","text":"<p>Database-specific exceptions for Serv.</p>"},{"location":"reference/serv/database/exceptions/#serv.database.exceptions.DatabaseConfigurationError","title":"DatabaseConfigurationError","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Configuration-related database errors.</p>"},{"location":"reference/serv/database/exceptions/#serv.database.exceptions.DatabaseConnectionError","title":"DatabaseConnectionError","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Connection-related database errors.</p>"},{"location":"reference/serv/database/exceptions/#serv.database.exceptions.DatabaseError","title":"DatabaseError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for database operations.</p>"},{"location":"reference/serv/database/exceptions/#serv.database.exceptions.DatabaseFactoryError","title":"DatabaseFactoryError","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Factory loading/invocation errors.</p>"},{"location":"reference/serv/database/exceptions/#serv.database.exceptions.DatabaseLifecycleError","title":"DatabaseLifecycleError","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Lifecycle management errors.</p>"},{"location":"reference/serv/database/factory/","title":"factory","text":""},{"location":"reference/serv/database/factory/#serv.database.factory","title":"serv.database.factory","text":"<p>Factory loading system for database providers.</p>"},{"location":"reference/serv/database/factory/#serv.database.factory.FactoryLoader","title":"FactoryLoader","text":"<p>Loads and invokes database factory functions with configuration. Supports both nested settings and flat parameter styles.</p>"},{"location":"reference/serv/database/factory/#serv.database.factory.FactoryLoader.bind_flat_parameters","title":"bind_flat_parameters  <code>staticmethod</code>","text":"<pre><code>bind_flat_parameters(\n    factory: Callable, config: dict[str, Any]\n) -&gt; tuple[tuple, dict]\n</code></pre> <p>Bind flat config parameters to factory signature.</p> <p>Parameters:</p> Name Type Description Default <code>factory</code> <code>Callable</code> <p>Factory function</p> required <code>config</code> <code>dict[str, Any]</code> <p>Configuration dictionary</p> required <p>Returns:</p> Type Description <code>tuple[tuple, dict]</code> <p>Tuple of (args, kwargs) for function call</p> Source code in <code>serv/database/factory.py</code> <pre><code>@staticmethod\ndef bind_flat_parameters(\n    factory: Callable, config: dict[str, Any]\n) -&gt; tuple[tuple, dict]:\n    \"\"\"Bind flat config parameters to factory signature.\n\n    Args:\n        factory: Factory function\n        config: Configuration dictionary\n\n    Returns:\n        Tuple of (args, kwargs) for function call\n    \"\"\"\n    try:\n        sig = inspect.signature(factory)\n        bound_kwargs = {}\n\n        # Skip first parameter (name) as it's handled separately\n        params = list(sig.parameters.values())[1:]\n\n        # Check if function accepts **kwargs\n        has_var_keyword = any(\n            p.kind == inspect.Parameter.VAR_KEYWORD for p in params\n        )\n\n        # Get parameter names (excluding VAR_KEYWORD)\n        param_names = {\n            p.name for p in params if p.kind != inspect.Parameter.VAR_KEYWORD\n        }\n\n        for param in params:\n            # Skip **kwargs parameters\n            if param.kind == inspect.Parameter.VAR_KEYWORD:\n                continue\n\n            if param.name in config:\n                bound_kwargs[param.name] = config[param.name]\n            elif param.default is inspect.Parameter.empty:\n                # Required parameter missing\n                raise DatabaseFactoryError(\n                    f\"Required parameter '{param.name}' missing from config\"\n                )\n\n        # If function accepts **kwargs, pass any extra config parameters\n        if has_var_keyword:\n            for key, value in config.items():\n                if key not in param_names and key not in [\"provider\", \"qualifier\"]:\n                    bound_kwargs[key] = value\n\n        return (), bound_kwargs\n\n    except Exception as e:\n        raise DatabaseFactoryError(\n            f\"Failed to bind parameters for factory: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/database/factory/#serv.database.factory.FactoryLoader.detect_config_style","title":"detect_config_style  <code>staticmethod</code>","text":"<pre><code>detect_config_style(config: dict[str, Any]) -&gt; str\n</code></pre> <p>Detect whether config uses nested settings or flat parameters.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>Configuration dictionary</p> required <p>Returns:</p> Type Description <code>str</code> <p>Either \"nested\" or \"flat\"</p> Source code in <code>serv/database/factory.py</code> <pre><code>@staticmethod\ndef detect_config_style(config: dict[str, Any]) -&gt; str:\n    \"\"\"Detect whether config uses nested settings or flat parameters.\n\n    Args:\n        config: Configuration dictionary\n\n    Returns:\n        Either \"nested\" or \"flat\"\n    \"\"\"\n    return \"nested\" if \"settings\" in config else \"flat\"\n</code></pre>"},{"location":"reference/serv/database/factory/#serv.database.factory.FactoryLoader.invoke_factory","title":"invoke_factory  <code>async</code> <code>staticmethod</code>","text":"<pre><code>invoke_factory(\n    factory: Callable, name: str, config: dict[str, Any]\n) -&gt; Any\n</code></pre> <p>Invoke factory with appropriate parameter style.</p> <p>Parameters:</p> Name Type Description Default <code>factory</code> <code>Callable</code> <p>Factory function to invoke</p> required <code>name</code> <code>str</code> <p>Database name</p> required <code>config</code> <code>dict[str, Any]</code> <p>Configuration for the database</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Database connection instance</p> <p>Raises:</p> Type Description <code>DatabaseFactoryError</code> <p>If factory invocation fails</p> Source code in <code>serv/database/factory.py</code> <pre><code>@staticmethod\nasync def invoke_factory(\n    factory: Callable, name: str, config: dict[str, Any]\n) -&gt; Any:\n    \"\"\"Invoke factory with appropriate parameter style.\n\n    Args:\n        factory: Factory function to invoke\n        name: Database name\n        config: Configuration for the database\n\n    Returns:\n        Database connection instance\n\n    Raises:\n        DatabaseFactoryError: If factory invocation fails\n    \"\"\"\n    try:\n        config_style = FactoryLoader.detect_config_style(config)\n\n        if config_style == \"nested\":\n            # Nested style: factory(name, settings={...})\n            settings = config.get(\"settings\", {})\n            if inspect.iscoroutinefunction(factory):\n                return await factory(name, settings)\n            else:\n                return factory(name, settings)\n        else:\n            # Flat style: factory(name, param1=value1, param2=value2, ...)\n            args, kwargs = FactoryLoader.bind_flat_parameters(factory, config)\n            if inspect.iscoroutinefunction(factory):\n                return await factory(name, *args, **kwargs)\n            else:\n                return factory(name, *args, **kwargs)\n\n    except Exception as e:\n        raise DatabaseFactoryError(\n            f\"Failed to invoke factory for database '{name}': {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/database/factory/#serv.database.factory.FactoryLoader.load_factory","title":"load_factory  <code>staticmethod</code>","text":"<pre><code>load_factory(provider: str) -&gt; Callable\n</code></pre> <p>Load factory function from module path.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>Provider string in format \"module.path:factory_function\"</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The factory function</p> <p>Raises:</p> Type Description <code>DatabaseFactoryError</code> <p>If provider cannot be loaded</p> Source code in <code>serv/database/factory.py</code> <pre><code>@staticmethod\ndef load_factory(provider: str) -&gt; Callable:\n    \"\"\"Load factory function from module path.\n\n    Args:\n        provider: Provider string in format \"module.path:factory_function\"\n\n    Returns:\n        The factory function\n\n    Raises:\n        DatabaseFactoryError: If provider cannot be loaded\n    \"\"\"\n    try:\n        if \":\" not in provider:\n            raise DatabaseFactoryError(\n                f\"Invalid provider format '{provider}'. Expected 'module.path:function'.\"\n            )\n\n        module_path, function_name = provider.split(\":\", 1)\n        module = importlib.import_module(module_path)\n        factory_func = getattr(module, function_name)\n\n        if not callable(factory_func):\n            raise DatabaseFactoryError(f\"Provider '{provider}' is not callable\")\n\n        return factory_func\n\n    except (ImportError, AttributeError) as e:\n        raise DatabaseFactoryError(\n            f\"Failed to load provider '{provider}': {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/database/lifecycle/","title":"lifecycle","text":""},{"location":"reference/serv/database/lifecycle/#serv.database.lifecycle","title":"serv.database.lifecycle","text":"<p>Database connection lifecycle management.</p>"},{"location":"reference/serv/database/lifecycle/#serv.database.lifecycle.DatabaseLifecycle","title":"DatabaseLifecycle","text":"<pre><code>DatabaseLifecycle(\n    manager: DatabaseManager, exit_stack: AsyncExitStack\n)\n</code></pre> <p>Manages database connection lifecycle within app context. Integrates with app startup/shutdown and exit stack management.</p> <p>Initialize lifecycle manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>DatabaseManager</code> <p>DatabaseManager instance</p> required <code>exit_stack</code> <code>AsyncExitStack</code> <p>Async exit stack for cleanup registration</p> required Source code in <code>serv/database/lifecycle.py</code> <pre><code>def __init__(self, manager: \"DatabaseManager\", exit_stack: AsyncExitStack):\n    \"\"\"Initialize lifecycle manager.\n\n    Args:\n        manager: DatabaseManager instance\n        exit_stack: Async exit stack for cleanup registration\n    \"\"\"\n    self.manager = manager\n    self.exit_stack = exit_stack\n</code></pre>"},{"location":"reference/serv/database/lifecycle/#serv.database.lifecycle.DatabaseLifecycle.register_cleanup","title":"register_cleanup","text":"<pre><code>register_cleanup(connection: Any) -&gt; None\n</code></pre> <p>Register connection cleanup with exit stack.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Any</code> <p>Database connection to register for cleanup</p> required Source code in <code>serv/database/lifecycle.py</code> <pre><code>def register_cleanup(self, connection: Any) -&gt; None:\n    \"\"\"Register connection cleanup with exit stack.\n\n    Args:\n        connection: Database connection to register for cleanup\n    \"\"\"\n    if hasattr(connection, \"_cleanup\"):\n        self.exit_stack.push_async_callback(connection._cleanup)\n    elif hasattr(connection, \"close\"):\n        if inspect.iscoroutinefunction(connection.close):\n            self.exit_stack.push_async_callback(connection.close)\n        else:\n            self.exit_stack.callback(connection.close)\n    elif hasattr(connection, \"__aexit__\"):\n        self.exit_stack.push_async_exit(connection)\n</code></pre>"},{"location":"reference/serv/database/lifecycle/#serv.database.lifecycle.DatabaseLifecycle.shutdown_databases","title":"shutdown_databases  <code>async</code>","text":"<pre><code>shutdown_databases() -&gt; None\n</code></pre> <p>Cleanup databases during app shutdown.</p> <p>Raises:</p> Type Description <code>DatabaseLifecycleError</code> <p>If database shutdown fails</p> Source code in <code>serv/database/lifecycle.py</code> <pre><code>async def shutdown_databases(self) -&gt; None:\n    \"\"\"Cleanup databases during app shutdown.\n\n    Raises:\n        DatabaseLifecycleError: If database shutdown fails\n    \"\"\"\n    try:\n        await self.manager.shutdown_databases()\n    except Exception as e:\n        raise DatabaseLifecycleError(\n            f\"Failed to shutdown databases: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/database/lifecycle/#serv.database.lifecycle.DatabaseLifecycle.startup_databases","title":"startup_databases  <code>async</code>","text":"<pre><code>startup_databases() -&gt; None\n</code></pre> <p>Initialize databases during app startup.</p> <p>Raises:</p> Type Description <code>DatabaseLifecycleError</code> <p>If database startup fails</p> Source code in <code>serv/database/lifecycle.py</code> <pre><code>async def startup_databases(self) -&gt; None:\n    \"\"\"Initialize databases during app startup.\n\n    Raises:\n        DatabaseLifecycleError: If database startup fails\n    \"\"\"\n    try:\n        await self.manager.initialize_databases()\n    except Exception as e:\n        raise DatabaseLifecycleError(\n            f\"Failed to startup databases: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/database/manager/","title":"manager","text":""},{"location":"reference/serv/database/manager/#serv.database.manager","title":"serv.database.manager","text":"<p>Database manager for handling multiple database connections.</p>"},{"location":"reference/serv/database/manager/#serv.database.manager.DatabaseManager","title":"DatabaseManager","text":"<pre><code>DatabaseManager(\n    app_config: dict[str, Any], container: Container\n)\n</code></pre> <p>Manages database connections defined in configuration. Handles factory loading, connection lifecycle, and DI registration.</p> <p>Initialize database manager.</p> <p>Parameters:</p> Name Type Description Default <code>app_config</code> <code>dict[str, Any]</code> <p>Application configuration dictionary</p> required <code>container</code> <code>Container</code> <p>Bevy DI container for registering connections</p> required Source code in <code>serv/database/manager.py</code> <pre><code>def __init__(self, app_config: dict[str, Any], container: Container):\n    \"\"\"Initialize database manager.\n\n    Args:\n        app_config: Application configuration dictionary\n        container: Bevy DI container for registering connections\n    \"\"\"\n    self.config = app_config.get(\"databases\", {})\n    self.container = container\n    self.connections: dict[str, Any] = {}\n    self.exit_stack = AsyncExitStack()\n    self.lifecycle = DatabaseLifecycle(self, self.exit_stack)\n</code></pre>"},{"location":"reference/serv/database/manager/#serv.database.manager.DatabaseManager.create_connection","title":"create_connection  <code>async</code>","text":"<pre><code>create_connection(name: str, config: dict[str, Any]) -&gt; Any\n</code></pre> <p>Create single database connection from config with qualifier support.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>config</code> <code>dict[str, Any]</code> <p>Database configuration</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Database connection instance</p> <p>Raises:</p> Type Description <code>DatabaseConfigurationError</code> <p>If configuration is invalid</p> <code>DatabaseConnectionError</code> <p>If connection creation fails</p> Source code in <code>serv/database/manager.py</code> <pre><code>async def create_connection(self, name: str, config: dict[str, Any]) -&gt; Any:\n    \"\"\"Create single database connection from config with qualifier support.\n\n    Args:\n        name: Database name\n        config: Database configuration\n\n    Returns:\n        Database connection instance\n\n    Raises:\n        DatabaseConfigurationError: If configuration is invalid\n        DatabaseConnectionError: If connection creation fails\n    \"\"\"\n    if \"provider\" not in config:\n        raise DatabaseConfigurationError(\n            f\"Database '{name}' missing required 'provider' field\"\n        )\n\n    provider = config[\"provider\"]\n\n    try:\n        # Load factory function\n        factory = FactoryLoader.load_factory(provider)\n\n        # Create connection using factory\n        connection = await FactoryLoader.invoke_factory(factory, name, config)\n\n        return connection\n\n    except Exception as e:\n        raise DatabaseConnectionError(\n            f\"Failed to create connection for database '{name}': {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"reference/serv/database/manager/#serv.database.manager.DatabaseManager.initialize_databases","title":"initialize_databases  <code>async</code>","text":"<pre><code>initialize_databases() -&gt; None\n</code></pre> <p>Initialize all configured database connections.</p> <p>Raises:</p> Type Description <code>DatabaseConfigurationError</code> <p>If configuration is invalid</p> <code>DatabaseConnectionError</code> <p>If connection creation fails</p> Source code in <code>serv/database/manager.py</code> <pre><code>async def initialize_databases(self) -&gt; None:\n    \"\"\"Initialize all configured database connections.\n\n    Raises:\n        DatabaseConfigurationError: If configuration is invalid\n        DatabaseConnectionError: If connection creation fails\n    \"\"\"\n    if not self.config:\n        return  # No databases configured\n\n    for name, db_config in self.config.items():\n        try:\n            connection = await self.create_connection(name, db_config)\n            self.connections[name] = connection\n\n            # Register with DI container\n            self.register_connection(name, connection)\n\n            # Register cleanup\n            self.lifecycle.register_cleanup(connection)\n\n        except Exception as e:\n            raise DatabaseConnectionError(\n                f\"Failed to initialize database '{name}': {str(e)}\"\n            ) from e\n</code></pre>"},{"location":"reference/serv/database/manager/#serv.database.manager.DatabaseManager.register_connection","title":"register_connection","text":"<pre><code>register_connection(name: str, connection: Any) -&gt; None\n</code></pre> <p>Register database connection with dependency injection using Bevy 3.1 qualifiers.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Database name</p> required <code>connection</code> <code>Any</code> <p>Database connection instance</p> required Source code in <code>serv/database/manager.py</code> <pre><code>def register_connection(self, name: str, connection: Any) -&gt; None:\n    \"\"\"Register database connection with dependency injection using Bevy 3.1 qualifiers.\n\n    Args:\n        name: Database name\n        connection: Database connection instance\n    \"\"\"\n    # Register by factory return type with qualifier\n    # This allows multiple instances of the same type (e.g., multiple Ommi instances)\n    self.container.add(type(connection), connection, qualifier=name)\n</code></pre>"},{"location":"reference/serv/database/manager/#serv.database.manager.DatabaseManager.shutdown_databases","title":"shutdown_databases  <code>async</code>","text":"<pre><code>shutdown_databases() -&gt; None\n</code></pre> <p>Shutdown all database connections.</p> Source code in <code>serv/database/manager.py</code> <pre><code>async def shutdown_databases(self) -&gt; None:\n    \"\"\"Shutdown all database connections.\"\"\"\n    await self.exit_stack.aclose()\n    self.connections.clear()\n</code></pre>"},{"location":"reference/serv/di/","title":"di","text":""},{"location":"reference/serv/di/#serv.di","title":"serv.di","text":"<p>Dependency injection layer for Serv - parameter injection, containers, resolvers.</p>"},{"location":"reference/serv/extensions/","title":"extensions","text":""},{"location":"reference/serv/extensions/#serv.extensions","title":"serv.extensions","text":""},{"location":"reference/serv/extensions/#serv.extensions.Context","title":"Context","text":"<pre><code>Context(event_name: str, **kwargs)\n</code></pre> <p>Event context object that acts like a dictionary with additional event metadata.</p> <p>The Context object provides access to all keyword arguments passed to an event emission, while also including the event name for reference.</p> <p>Examples:</p> <p>Accessing event data:</p> <pre><code>class MyListener(Listener):\n    @on(\"user.created\")\n    async def handle_user_created(self, context: Context):\n        user_id = context[\"user_id\"]\n        email = context[\"email\"]\n        print(f\"Event: {context.event_name}, User: {user_id}\")\n</code></pre> <p>Using both context and direct parameters:</p> <pre><code>class MyListener(Listener):\n    @on(\"user.created\")\n    async def handle_user_created(self, user_id: int, context: Context):\n        # user_id is injected directly\n        # context provides access to all parameters and event name\n        print(f\"Event: {context.event_name}, User: {user_id}\")\n        if \"email\" in context:\n            print(f\"Email: {context['email']}\")\n</code></pre> Source code in <code>serv/extensions/extensions.py</code> <pre><code>def __init__(self, event_name: str, **kwargs):\n    self.event_name = event_name\n    self._data = kwargs\n</code></pre>"},{"location":"reference/serv/extensions/#serv.extensions.ExtensionLoader","title":"ExtensionLoader","text":"<pre><code>ExtensionLoader(app: App, extension_loader: Importer)\n</code></pre> <p>Handles loading and management of extensions and middleware.</p> <p>Initialize the ExtensionLoader.</p> <p>Parameters:</p> Name Type Description Default <code>extension_loader</code> <code>Importer</code> <p>Importer instance for loading extension packages</p> required Source code in <code>serv/extensions/loader.py</code> <pre><code>def __init__(self, app: \"App\", extension_loader: \"Importer\"):\n    \"\"\"Initialize the ExtensionLoader.\n\n    Args:\n        extension_loader: Importer instance for loading extension packages\n    \"\"\"\n    self._app = app\n    self._extension_loader = extension_loader\n</code></pre>"},{"location":"reference/serv/extensions/#serv.extensions.ExtensionLoader.load_extension","title":"load_extension","text":"<pre><code>load_extension(\n    extension_import: str,\n    app_extension_settings: dict[str, Any] | None = None,\n) -&gt; tuple[ExtensionSpec | None, list[Exception]]\n</code></pre> <p>Load a single extension.</p> <p>Parameters:</p> Name Type Description Default <code>extension_import</code> <code>str</code> <p>Dot-separated import path to the extension</p> required <p>Returns:</p> Type Description <code>tuple[ExtensionSpec | None, list[Exception]]</code> <p>Tuple of (extension_spec, exceptions)</p> Source code in <code>serv/extensions/loader.py</code> <pre><code>def load_extension(\n    self,\n    extension_import: str,\n    app_extension_settings: dict[str, Any] | None = None,\n) -&gt; tuple[ExtensionSpec | None, list[Exception]]:\n    \"\"\"Load a single extension.\n\n    Args:\n        extension_import: Dot-separated import path to the extension\n\n    Returns:\n        Tuple of (extension_spec, exceptions)\n    \"\"\"\n    exceptions = []\n    try:\n        extension_spec = self._load_extension_spec(\n            extension_import, app_extension_settings or {}\n        )\n    except Exception as e:\n        e.add_note(f\" - Failed to load extension spec for {extension_import}\")\n        exceptions.append(e)\n        return None, exceptions\n\n    try:\n        _, failed_listeners = self._load_extension_listeners(\n            extension_spec.listeners, extension_import\n        )\n    except Exception as e:\n        e.add_note(f\" - Failed while loading listeners for {extension_import}\")\n        exceptions.append(e)\n    else:\n        exceptions.extend(failed_listeners)\n\n    try:\n        _, failed_middleware = self._load_extension_middleware(\n            extension_spec.middleware, extension_import\n        )\n    except Exception as e:\n        e.add_note(f\" - Failed while loading middleware for {extension_import}\")\n        exceptions.append(e)\n    else:\n        exceptions.extend(failed_middleware)\n\n    try:\n        self._setup_router_extension(extension_spec)\n    except Exception as e:\n        e.add_note(\n            f\" - Failed while setting up router extension for {extension_import}\"\n        )\n        exceptions.append(e)\n\n    logger.info(f\"Loaded extension {extension_spec.name!r}\")\n    return extension_spec, exceptions\n</code></pre>"},{"location":"reference/serv/extensions/#serv.extensions.ExtensionLoader.load_extensions","title":"load_extensions","text":"<pre><code>load_extensions(\n    extensions_config: list[dict[str, Any]],\n) -&gt; tuple[\n    list[Listener], list[Callable[[], AsyncIterator[None]]]\n]\n</code></pre> <p>Load extensions from a list of extension configs.</p> <p>Parameters:</p> Name Type Description Default <code>extensions_config</code> <code>list[dict[str, Any]]</code> <p>List of extension configs (usually from serv.config.yaml)</p> required <p>Returns:</p> Type Description <code>tuple[list[Listener], list[Callable[[], AsyncIterator[None]]]]</code> <p>Tuple of (Extension specs, Middleware iterators)</p> <p>Raises:</p> Type Description <code>ExceptionGroup</code> <p>If any errors occurred during loading</p> Source code in <code>serv/extensions/loader.py</code> <pre><code>def load_extensions(\n    self, extensions_config: list[dict[str, Any]]\n) -&gt; \"tuple[list[p.Listener], list[Callable[[], AsyncIterator[None]]]]\":\n    \"\"\"Load extensions from a list of extension configs.\n\n    Args:\n        extensions_config: List of extension configs (usually from serv.config.yaml)\n\n    Returns:\n        Tuple of (Extension specs, Middleware iterators)\n\n    Raises:\n        ExceptionGroup: If any errors occurred during loading\n    \"\"\"\n    exceptions = []\n    loaded_extensions = []\n    middleware_list = []\n    for extension_settings in extensions_config:\n        try:\n            extension_import, settings = self._process_app_extension_settings(\n                extension_settings\n            )\n            extension_spec, extension_exceptions = self.load_extension(\n                extension_import, settings\n            )\n\n        except Exception as e:\n            e.add_note(f\" - Failed to load extension {extension_settings}\")\n            exceptions.append(e)\n            continue\n        else:\n            if extension_spec:\n                known_extensions[extension_spec.path] = extension_spec\n                loaded_extensions.append(extension_spec)\n                middleware_list.extend(extension_spec.middleware)\n\n            if extension_exceptions:\n                exceptions.extend(extension_exceptions)\n\n    if exceptions:\n        logger.warning(\n            f\"Encountered {len(exceptions)} errors during extension and middleware loading.\"\n        )\n        raise ExceptionGroup(\n            \"Exceptions raised while loading extensions and middleware\", exceptions\n        )\n\n    return loaded_extensions, middleware_list\n</code></pre>"},{"location":"reference/serv/extensions/#serv.extensions.Listener","title":"Listener","text":"<pre><code>Listener(\n    *,\n    extension_spec: ExtensionSpec | None = None,\n    stand_alone: bool = False,\n)\n</code></pre> <p>Base class for creating Serv event listeners.</p> <p>Listeners extend the functionality of Serv applications by responding to events that occur during the application lifecycle. They can handle application events, modify requests/responses, and integrate with external services.</p> <p>Listener classes automatically register event handlers based on method names following the pattern <code>on_{event_name}</code> or <code>{prefix}_on_{event_name}</code>. This allows for readable method names and automatic event subscription.</p> <p>Common Events: - <code>app_startup</code>: Application is starting up - <code>app_shutdown</code>: Application is shutting down - <code>app_request_begin</code>: New request is being processed - <code>app_request_end</code>: Request processing is complete - <code>extension_loaded</code>: Extension has been loaded - Custom events emitted by your application</p> <p>Examples:</p> <p>Basic listener with event handlers:</p> <pre><code>from serv.extensions import Listener\nfrom serv._routing import Router\nfrom bevy import injectable, Inject\n\nclass MyListener(Listener):\n    async def on_app_startup(self):\n        print(\"Application is starting!\")\n\n    @injectable\n    async def on_app_request_begin(self, router: Inject[Router]):\n        # Add routes when app starts handling requests\n        router.add_route(\"/hello\", self.hello_handler, [\"GET\"])\n\n    @injectable\n    async def hello_handler(self, response: Inject[ResponseBuilder]):\n        response.body(\"Hello from my listener!\")\n\n    async def on_app_shutdown(self):\n        print(\"Application is shutting down!\")\n</code></pre> <p>Listener with custom event handlers:</p> <pre><code>class UserListener(Listener):\n    async def on_user_created(self, user_id: int):\n        print(f\"User {user_id} was created!\")\n\n    async def send_email_on_user_created(self, user_id: int, email: str):\n        # Send welcome email\n        await self.send_welcome_email(email)\n\n    async def on_user_deleted(self, user_id: int):\n        # Cleanup user data\n        await self.cleanup_user_data(user_id)\n</code></pre> <p>Listener with dependency injection:</p> <pre><code>from serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import injectable, Inject\n\nclass AuthListener(Listener):\n    @injectable\n    async def on_app_request_begin(\n        self,\n        request: Inject[Request],\n        response: Inject[ResponseBuilder]\n    ):\n        # Check authentication for protected routes\n        if request.path.startswith(\"/admin/\"):\n            auth_header = request.headers.get(\"authorization\")\n            if not auth_header:\n                response.set_status(401)\n                response.body(\"Authentication required\")\n                return\n</code></pre> <p>Listener configuration:</p> <pre><code>class DatabaseListener(Listener):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # Access extension configuration from extension.yaml\n        config = self.__extension_spec__.config\n        self.db_url = config.get(\"database_url\", \"sqlite:///app.db\")\n        self.pool_size = config.get(\"pool_size\", 10)\n\n    async def on_app_startup(self):\n        # Initialize database connection\n        self.db_pool = await create_db_pool(self.db_url, self.pool_size)\n</code></pre> Note <p>Listener methods that handle events can use dependency injection to access request/response objects, the router, and other services. The extension system automatically manages the lifecycle and ensures proper cleanup.</p> <p>Initialize the listener.</p> <p>Loads extension configuration and sets up any defined routers and routes if they are configured in the extension.yaml file.</p> <p>Parameters:</p> Name Type Description Default <code>extension_spec</code> <code>ExtensionSpec | None</code> <p>Extension specification (preferred)</p> <code>None</code> <code>extension_spec</code> <code>ExtensionSpec | None</code> <p>Extension specification (backward compatibility)</p> <code>None</code> <code>stand_alone</code> <code>bool</code> <p>If True, don't attempt to load extension.yaml</p> <code>False</code> Source code in <code>serv/extensions/extensions.py</code> <pre><code>def __init__(\n    self,\n    *,\n    extension_spec: \"pl.ExtensionSpec | None\" = None,\n    stand_alone: bool = False,\n):\n    \"\"\"Initialize the listener.\n\n    Loads extension configuration and sets up any defined routers and routes\n    if they are configured in the extension.yaml file.\n\n    Args:\n        extension_spec: Extension specification (preferred)\n        extension_spec: Extension specification (backward compatibility)\n        stand_alone: If True, don't attempt to load extension.yaml\n    \"\"\"\n    self._stand_alone = stand_alone\n\n    spec = None\n    if extension_spec:\n        spec = extension_spec\n\n    elif not stand_alone:\n        module = sys.modules[self.__module__]\n        if not hasattr(module, \"__extension_spec__\") and not hasattr(\n            module, \"__extension_spec__\"\n        ):\n            raise Exception(\n                f\"Listener {self.__class__.__name__} does not exist in an extension package. No extension.yaml found in \"\n                f\"parent directories.\"\n            )\n        # Try extension_spec first, then extension_spec for backward compatibility\n        spec = getattr(module, \"__extension_spec__\", None) or getattr(\n            module, \"__extension_spec__\", None\n        )\n\n    self.__extension_spec__ = spec\n</code></pre>"},{"location":"reference/serv/extensions/#serv.extensions.Listener.on","title":"on  <code>async</code>","text":"<pre><code>on(\n    event_name: str,\n    container: Container | None = None,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Receives event notifications.</p> <p>This method will be called by the application when an event occurs that this listener is registered for. Handlers are called with keyword arguments only, and Context objects are injected for parameters with Context type annotation.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>The name of the event that occurred.</p> required <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments associated with the event.</p> <code>{}</code> Source code in <code>serv/extensions/extensions.py</code> <pre><code>async def on(\n    self,\n    event_name: str,\n    container: Container | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Receives event notifications.\n\n    This method will be called by the application when an event occurs that this\n    listener is registered for. Handlers are called with keyword arguments only,\n    and Context objects are injected for parameters with Context type annotation.\n\n    Args:\n        event_name: The name of the event that occurred.\n        **kwargs: Arbitrary keyword arguments associated with the event.\n    \"\"\"\n    # Find handlers for this exact event name\n    if event_name not in self.__listeners__:\n        return  # No handlers for this event\n\n    for listener_handler_name in self.__listeners__[event_name]:\n        callback = getattr(self, listener_handler_name)\n\n        # Prepare arguments for the handler\n        handler_kwargs = await self._prepare_handler_arguments(\n            callback, event_name, kwargs, container\n        )\n\n        # Create a branched container with event arguments for injection\n        execution_container = get_container(container).branch()\n\n        # Add event arguments to the container so they can be injected\n        for arg_name, arg_value in kwargs.items():\n            if arg_value is not None:\n                execution_container.add(type(arg_value), arg_value)\n\n        # Ensure Router is available in the execution container\n        from serv._routing import Router\n        from serv.requests import Request\n        from serv.responses import ResponseBuilder\n        from bevy.containers import Container\n\n        parent_container = get_container(container)\n        # Copy essential dependencies from parent to child if missing\n        essential_types = [Router, Request, ResponseBuilder, Container]\n        for dep_type in essential_types:\n            try:\n                parent_instance = parent_container.get(dep_type)\n                # Try to get from execution container to see if it's already there\n                try:\n                    execution_container.get(dep_type)\n                except:\n                    # Not found in execution container, add it\n                    execution_container.add(dep_type, parent_instance)\n            except:\n                # Parent doesn't have it, skip\n                pass\n\n        # Also copy any custom types that were added to the parent container\n        # This handles test-specific dependencies like _TestUser\n        if hasattr(parent_container, \"instances\"):\n            for instance_key, instance_value in parent_container.instances.items():\n                if (\n                    instance_key not in essential_types\n                ):  # Don't duplicate essential types\n                    try:\n                        # Check if it's already in execution container\n                        execution_container.get(instance_key)\n                    except:\n                        # Not found in execution container, add it\n                        execution_container.add(instance_key, instance_value)\n\n        result = execution_container.call(callback, **handler_kwargs)\n        if isawaitable(result):\n            await result\n</code></pre>"},{"location":"reference/serv/extensions/#serv.extensions.ServMiddleware","title":"ServMiddleware","text":"<pre><code>ServMiddleware(\n    container: Inject[Container], config: dict | None = None\n)\n</code></pre> <p>Base class for Serv middleware, providing enter, leave, and on_error hooks.</p> Source code in <code>serv/extensions/middleware.py</code> <pre><code>@injectable\ndef __init__(self, container: Inject[Container], config: dict | None = None):\n    self._container = container\n    self._config = config\n</code></pre>"},{"location":"reference/serv/extensions/#serv.extensions.ServMiddleware.enter","title":"enter  <code>async</code>","text":"<pre><code>enter()\n</code></pre> <p>Called before the request is processed further. Override to inspect/modify the request or return an early response.</p> Source code in <code>serv/extensions/middleware.py</code> <pre><code>async def enter(self):\n    \"\"\"\n    Called before the request is processed further.\n    Override to inspect/modify the request or return an early response.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/serv/extensions/#serv.extensions.ServMiddleware.leave","title":"leave  <code>async</code>","text":"<pre><code>leave()\n</code></pre> <p>Called after the request has been processed and a response is available. Override to inspect/modify the response. This is not called if an exception occurred during request processing.</p> Source code in <code>serv/extensions/middleware.py</code> <pre><code>async def leave(self):\n    \"\"\"\n    Called after the request has been processed and a response is available.\n    Override to inspect/modify the response. This is not called if an exception occurred\n    during request processing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/serv/extensions/#serv.extensions.ServMiddleware.on_error","title":"on_error  <code>async</code>","text":"<pre><code>on_error(exc: Exception)\n</code></pre> <p>Called if an exception occurs during request processing after 'enter'. Override to handle errors and optionally return a custom error response.</p> <p>The base implementation raises the exception again.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>Exception</code> <p>The exception that occurred.</p> required Source code in <code>serv/extensions/middleware.py</code> <pre><code>async def on_error(self, exc: Exception):\n    \"\"\"\n    Called if an exception occurs during request processing after 'enter'.\n    Override to handle errors and optionally return a custom error response.\n\n    The base implementation raises the exception again.\n\n    Args:\n        exc: The exception that occurred.\n    \"\"\"\n    raise exc\n</code></pre>"},{"location":"reference/serv/extensions/#serv.extensions.on","title":"on","text":"<pre><code>on(event_name: str) -&gt; _OnDecorator\n</code></pre> <p>Decorator for marking event handler methods.</p> <p>This decorator replaces the naming-based event detection with explicit event name specification.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>The name of the event to listen for (e.g., \"app.request.begin\")</p> required <p>Examples:</p> <p>Basic event handler:</p> <pre><code>class MyListener(Listener):\n    @on(\"app.request.begin\")\n    @injectable\n    async def setup_request(self, router: Inject[Router]):\n        # Handle app request begin event\n        pass\n</code></pre> <p>Handler for multiple events:</p> <pre><code>class MyListener(Listener):\n    @on(\"user.created\") | on(\"user.updated\")\n    async def handle_user_changes(self, user_id: int):\n        # Handle both user created and updated events\n        pass\n</code></pre> <p>Handler with context:</p> <pre><code>class MyListener(Listener):\n    @on(\"order.processed\")\n    async def handle_order(self, context: Context):\n        order_id = context[\"order_id\"]\n        print(f\"Processing order {order_id} for event {context.event_name}\")\n</code></pre> Source code in <code>serv/extensions/extensions.py</code> <pre><code>def on(event_name: str) -&gt; _OnDecorator:\n    \"\"\"Decorator for marking event handler methods.\n\n    This decorator replaces the naming-based event detection with explicit\n    event name specification.\n\n    Args:\n        event_name: The name of the event to listen for (e.g., \"app.request.begin\")\n\n    Examples:\n        Basic event handler:\n\n        ```python\n        class MyListener(Listener):\n            @on(\"app.request.begin\")\n            @injectable\n            async def setup_request(self, router: Inject[Router]):\n                # Handle app request begin event\n                pass\n        ```\n\n        Handler for multiple events:\n\n        ```python\n        class MyListener(Listener):\n            @on(\"user.created\") | on(\"user.updated\")\n            async def handle_user_changes(self, user_id: int):\n                # Handle both user created and updated events\n                pass\n        ```\n\n        Handler with context:\n\n        ```python\n        class MyListener(Listener):\n            @on(\"order.processed\")\n            async def handle_order(self, context: Context):\n                order_id = context[\"order_id\"]\n                print(f\"Processing order {order_id} for event {context.event_name}\")\n        ```\n    \"\"\"\n    return _OnDecorator({event_name})\n</code></pre>"},{"location":"reference/serv/extensions/extensions/","title":"extensions","text":""},{"location":"reference/serv/extensions/extensions/#serv.extensions.extensions","title":"serv.extensions.extensions","text":"<p>Defines a base type that can observe events happening in the Serv app. Handlers are defined as methods on the class with names following the format '[optional_]on_{event_name}'. This gives the author the ability to make readable function names like 'set_role_on_user_create' or 'create_annotations_on_form_submit'.</p>"},{"location":"reference/serv/extensions/extensions/#serv.extensions.extensions.Context","title":"Context","text":"<pre><code>Context(event_name: str, **kwargs)\n</code></pre> <p>Event context object that acts like a dictionary with additional event metadata.</p> <p>The Context object provides access to all keyword arguments passed to an event emission, while also including the event name for reference.</p> <p>Examples:</p> <p>Accessing event data:</p> <pre><code>class MyListener(Listener):\n    @on(\"user.created\")\n    async def handle_user_created(self, context: Context):\n        user_id = context[\"user_id\"]\n        email = context[\"email\"]\n        print(f\"Event: {context.event_name}, User: {user_id}\")\n</code></pre> <p>Using both context and direct parameters:</p> <pre><code>class MyListener(Listener):\n    @on(\"user.created\")\n    async def handle_user_created(self, user_id: int, context: Context):\n        # user_id is injected directly\n        # context provides access to all parameters and event name\n        print(f\"Event: {context.event_name}, User: {user_id}\")\n        if \"email\" in context:\n            print(f\"Email: {context['email']}\")\n</code></pre> Source code in <code>serv/extensions/extensions.py</code> <pre><code>def __init__(self, event_name: str, **kwargs):\n    self.event_name = event_name\n    self._data = kwargs\n</code></pre>"},{"location":"reference/serv/extensions/extensions/#serv.extensions.extensions.Listener","title":"Listener","text":"<pre><code>Listener(\n    *,\n    extension_spec: ExtensionSpec | None = None,\n    stand_alone: bool = False,\n)\n</code></pre> <p>Base class for creating Serv event listeners.</p> <p>Listeners extend the functionality of Serv applications by responding to events that occur during the application lifecycle. They can handle application events, modify requests/responses, and integrate with external services.</p> <p>Listener classes automatically register event handlers based on method names following the pattern <code>on_{event_name}</code> or <code>{prefix}_on_{event_name}</code>. This allows for readable method names and automatic event subscription.</p> <p>Common Events: - <code>app_startup</code>: Application is starting up - <code>app_shutdown</code>: Application is shutting down - <code>app_request_begin</code>: New request is being processed - <code>app_request_end</code>: Request processing is complete - <code>extension_loaded</code>: Extension has been loaded - Custom events emitted by your application</p> <p>Examples:</p> <p>Basic listener with event handlers:</p> <pre><code>from serv.extensions import Listener\nfrom serv._routing import Router\nfrom bevy import injectable, Inject\n\nclass MyListener(Listener):\n    async def on_app_startup(self):\n        print(\"Application is starting!\")\n\n    @injectable\n    async def on_app_request_begin(self, router: Inject[Router]):\n        # Add routes when app starts handling requests\n        router.add_route(\"/hello\", self.hello_handler, [\"GET\"])\n\n    @injectable\n    async def hello_handler(self, response: Inject[ResponseBuilder]):\n        response.body(\"Hello from my listener!\")\n\n    async def on_app_shutdown(self):\n        print(\"Application is shutting down!\")\n</code></pre> <p>Listener with custom event handlers:</p> <pre><code>class UserListener(Listener):\n    async def on_user_created(self, user_id: int):\n        print(f\"User {user_id} was created!\")\n\n    async def send_email_on_user_created(self, user_id: int, email: str):\n        # Send welcome email\n        await self.send_welcome_email(email)\n\n    async def on_user_deleted(self, user_id: int):\n        # Cleanup user data\n        await self.cleanup_user_data(user_id)\n</code></pre> <p>Listener with dependency injection:</p> <pre><code>from serv.requests import Request\nfrom serv.responses import ResponseBuilder\nfrom bevy import injectable, Inject\n\nclass AuthListener(Listener):\n    @injectable\n    async def on_app_request_begin(\n        self,\n        request: Inject[Request],\n        response: Inject[ResponseBuilder]\n    ):\n        # Check authentication for protected routes\n        if request.path.startswith(\"/admin/\"):\n            auth_header = request.headers.get(\"authorization\")\n            if not auth_header:\n                response.set_status(401)\n                response.body(\"Authentication required\")\n                return\n</code></pre> <p>Listener configuration:</p> <pre><code>class DatabaseListener(Listener):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # Access extension configuration from extension.yaml\n        config = self.__extension_spec__.config\n        self.db_url = config.get(\"database_url\", \"sqlite:///app.db\")\n        self.pool_size = config.get(\"pool_size\", 10)\n\n    async def on_app_startup(self):\n        # Initialize database connection\n        self.db_pool = await create_db_pool(self.db_url, self.pool_size)\n</code></pre> Note <p>Listener methods that handle events can use dependency injection to access request/response objects, the router, and other services. The extension system automatically manages the lifecycle and ensures proper cleanup.</p> <p>Initialize the listener.</p> <p>Loads extension configuration and sets up any defined routers and routes if they are configured in the extension.yaml file.</p> <p>Parameters:</p> Name Type Description Default <code>extension_spec</code> <code>ExtensionSpec | None</code> <p>Extension specification (preferred)</p> <code>None</code> <code>extension_spec</code> <code>ExtensionSpec | None</code> <p>Extension specification (backward compatibility)</p> <code>None</code> <code>stand_alone</code> <code>bool</code> <p>If True, don't attempt to load extension.yaml</p> <code>False</code> Source code in <code>serv/extensions/extensions.py</code> <pre><code>def __init__(\n    self,\n    *,\n    extension_spec: \"pl.ExtensionSpec | None\" = None,\n    stand_alone: bool = False,\n):\n    \"\"\"Initialize the listener.\n\n    Loads extension configuration and sets up any defined routers and routes\n    if they are configured in the extension.yaml file.\n\n    Args:\n        extension_spec: Extension specification (preferred)\n        extension_spec: Extension specification (backward compatibility)\n        stand_alone: If True, don't attempt to load extension.yaml\n    \"\"\"\n    self._stand_alone = stand_alone\n\n    spec = None\n    if extension_spec:\n        spec = extension_spec\n\n    elif not stand_alone:\n        module = sys.modules[self.__module__]\n        if not hasattr(module, \"__extension_spec__\") and not hasattr(\n            module, \"__extension_spec__\"\n        ):\n            raise Exception(\n                f\"Listener {self.__class__.__name__} does not exist in an extension package. No extension.yaml found in \"\n                f\"parent directories.\"\n            )\n        # Try extension_spec first, then extension_spec for backward compatibility\n        spec = getattr(module, \"__extension_spec__\", None) or getattr(\n            module, \"__extension_spec__\", None\n        )\n\n    self.__extension_spec__ = spec\n</code></pre>"},{"location":"reference/serv/extensions/extensions/#serv.extensions.extensions.Listener.on","title":"on  <code>async</code>","text":"<pre><code>on(\n    event_name: str,\n    container: Container | None = None,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Receives event notifications.</p> <p>This method will be called by the application when an event occurs that this listener is registered for. Handlers are called with keyword arguments only, and Context objects are injected for parameters with Context type annotation.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>The name of the event that occurred.</p> required <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments associated with the event.</p> <code>{}</code> Source code in <code>serv/extensions/extensions.py</code> <pre><code>async def on(\n    self,\n    event_name: str,\n    container: Container | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Receives event notifications.\n\n    This method will be called by the application when an event occurs that this\n    listener is registered for. Handlers are called with keyword arguments only,\n    and Context objects are injected for parameters with Context type annotation.\n\n    Args:\n        event_name: The name of the event that occurred.\n        **kwargs: Arbitrary keyword arguments associated with the event.\n    \"\"\"\n    # Find handlers for this exact event name\n    if event_name not in self.__listeners__:\n        return  # No handlers for this event\n\n    for listener_handler_name in self.__listeners__[event_name]:\n        callback = getattr(self, listener_handler_name)\n\n        # Prepare arguments for the handler\n        handler_kwargs = await self._prepare_handler_arguments(\n            callback, event_name, kwargs, container\n        )\n\n        # Create a branched container with event arguments for injection\n        execution_container = get_container(container).branch()\n\n        # Add event arguments to the container so they can be injected\n        for arg_name, arg_value in kwargs.items():\n            if arg_value is not None:\n                execution_container.add(type(arg_value), arg_value)\n\n        # Ensure Router is available in the execution container\n        from serv._routing import Router\n        from serv.requests import Request\n        from serv.responses import ResponseBuilder\n        from bevy.containers import Container\n\n        parent_container = get_container(container)\n        # Copy essential dependencies from parent to child if missing\n        essential_types = [Router, Request, ResponseBuilder, Container]\n        for dep_type in essential_types:\n            try:\n                parent_instance = parent_container.get(dep_type)\n                # Try to get from execution container to see if it's already there\n                try:\n                    execution_container.get(dep_type)\n                except:\n                    # Not found in execution container, add it\n                    execution_container.add(dep_type, parent_instance)\n            except:\n                # Parent doesn't have it, skip\n                pass\n\n        # Also copy any custom types that were added to the parent container\n        # This handles test-specific dependencies like _TestUser\n        if hasattr(parent_container, \"instances\"):\n            for instance_key, instance_value in parent_container.instances.items():\n                if (\n                    instance_key not in essential_types\n                ):  # Don't duplicate essential types\n                    try:\n                        # Check if it's already in execution container\n                        execution_container.get(instance_key)\n                    except:\n                        # Not found in execution container, add it\n                        execution_container.add(instance_key, instance_value)\n\n        result = execution_container.call(callback, **handler_kwargs)\n        if isawaitable(result):\n            await result\n</code></pre>"},{"location":"reference/serv/extensions/extensions/#serv.extensions.extensions.on","title":"on","text":"<pre><code>on(event_name: str) -&gt; _OnDecorator\n</code></pre> <p>Decorator for marking event handler methods.</p> <p>This decorator replaces the naming-based event detection with explicit event name specification.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>The name of the event to listen for (e.g., \"app.request.begin\")</p> required <p>Examples:</p> <p>Basic event handler:</p> <pre><code>class MyListener(Listener):\n    @on(\"app.request.begin\")\n    @injectable\n    async def setup_request(self, router: Inject[Router]):\n        # Handle app request begin event\n        pass\n</code></pre> <p>Handler for multiple events:</p> <pre><code>class MyListener(Listener):\n    @on(\"user.created\") | on(\"user.updated\")\n    async def handle_user_changes(self, user_id: int):\n        # Handle both user created and updated events\n        pass\n</code></pre> <p>Handler with context:</p> <pre><code>class MyListener(Listener):\n    @on(\"order.processed\")\n    async def handle_order(self, context: Context):\n        order_id = context[\"order_id\"]\n        print(f\"Processing order {order_id} for event {context.event_name}\")\n</code></pre> Source code in <code>serv/extensions/extensions.py</code> <pre><code>def on(event_name: str) -&gt; _OnDecorator:\n    \"\"\"Decorator for marking event handler methods.\n\n    This decorator replaces the naming-based event detection with explicit\n    event name specification.\n\n    Args:\n        event_name: The name of the event to listen for (e.g., \"app.request.begin\")\n\n    Examples:\n        Basic event handler:\n\n        ```python\n        class MyListener(Listener):\n            @on(\"app.request.begin\")\n            @injectable\n            async def setup_request(self, router: Inject[Router]):\n                # Handle app request begin event\n                pass\n        ```\n\n        Handler for multiple events:\n\n        ```python\n        class MyListener(Listener):\n            @on(\"user.created\") | on(\"user.updated\")\n            async def handle_user_changes(self, user_id: int):\n                # Handle both user created and updated events\n                pass\n        ```\n\n        Handler with context:\n\n        ```python\n        class MyListener(Listener):\n            @on(\"order.processed\")\n            async def handle_order(self, context: Context):\n                order_id = context[\"order_id\"]\n                print(f\"Processing order {order_id} for event {context.event_name}\")\n        ```\n    \"\"\"\n    return _OnDecorator({event_name})\n</code></pre>"},{"location":"reference/serv/extensions/importer/","title":"importer","text":""},{"location":"reference/serv/extensions/importer/#serv.extensions.importer","title":"serv.extensions.importer","text":"<p>Package importer utility for Serv.</p> <p>This module provides functionality to load packages from directories without modifying sys.path. Packages are loaded and namespaced with their respective folder names.</p>"},{"location":"reference/serv/extensions/importer/#serv.extensions.importer.Importer","title":"Importer","text":"<pre><code>Importer(directory: Path | str, dotpath: str | None = None)\n</code></pre> <p>Loader for Serv packages.</p> <p>This class provides functionality to load packages/modules from a given package directory without modifying sys.path.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path | str</code> <p>Directory to search for packages</p> required Source code in <code>serv/extensions/importer.py</code> <pre><code>def __init__(self, directory: Path | str, dotpath: str | None = None):\n    \"\"\"\n    Args:\n        directory: Directory to search for packages\n    \"\"\"\n    self.directory = Path(directory).resolve()\n    self._dotpath = dotpath\n    if not dotpath:\n        self._dotpath = self.directory.name\n        ImporterMetaPathFinder.inject(self.directory)\n</code></pre>"},{"location":"reference/serv/extensions/importer/#serv.extensions.importer.Importer.load_module","title":"load_module","text":"<pre><code>load_module(module_path: DottedPath) -&gt; ModuleType\n</code></pre> <p>Imports a module from inside of the search directory package. This assumes that the dotted path directly correlates with the file structure and that the path is for a python file.</p> Source code in <code>serv/extensions/importer.py</code> <pre><code>def load_module(self, module_path: DottedPath) -&gt; ModuleType:\n    \"\"\"Imports a module from inside of the search directory package. This assumes that\n    the dotted path directly correlates with the file structure and that the path is\n    for a python file.\"\"\"\n    return importlib.import_module(f\"{self._dotpath}.{module_path}\")\n</code></pre>"},{"location":"reference/serv/extensions/loader/","title":"loader","text":""},{"location":"reference/serv/extensions/loader/#serv.extensions.loader","title":"serv.extensions.loader","text":""},{"location":"reference/serv/extensions/loader/#serv.extensions.loader.ExtensionLoader","title":"ExtensionLoader","text":"<pre><code>ExtensionLoader(app: App, extension_loader: Importer)\n</code></pre> <p>Handles loading and management of extensions and middleware.</p> <p>Initialize the ExtensionLoader.</p> <p>Parameters:</p> Name Type Description Default <code>extension_loader</code> <code>Importer</code> <p>Importer instance for loading extension packages</p> required Source code in <code>serv/extensions/loader.py</code> <pre><code>def __init__(self, app: \"App\", extension_loader: \"Importer\"):\n    \"\"\"Initialize the ExtensionLoader.\n\n    Args:\n        extension_loader: Importer instance for loading extension packages\n    \"\"\"\n    self._app = app\n    self._extension_loader = extension_loader\n</code></pre>"},{"location":"reference/serv/extensions/loader/#serv.extensions.loader.ExtensionLoader.load_extension","title":"load_extension","text":"<pre><code>load_extension(\n    extension_import: str,\n    app_extension_settings: dict[str, Any] | None = None,\n) -&gt; tuple[ExtensionSpec | None, list[Exception]]\n</code></pre> <p>Load a single extension.</p> <p>Parameters:</p> Name Type Description Default <code>extension_import</code> <code>str</code> <p>Dot-separated import path to the extension</p> required <p>Returns:</p> Type Description <code>tuple[ExtensionSpec | None, list[Exception]]</code> <p>Tuple of (extension_spec, exceptions)</p> Source code in <code>serv/extensions/loader.py</code> <pre><code>def load_extension(\n    self,\n    extension_import: str,\n    app_extension_settings: dict[str, Any] | None = None,\n) -&gt; tuple[ExtensionSpec | None, list[Exception]]:\n    \"\"\"Load a single extension.\n\n    Args:\n        extension_import: Dot-separated import path to the extension\n\n    Returns:\n        Tuple of (extension_spec, exceptions)\n    \"\"\"\n    exceptions = []\n    try:\n        extension_spec = self._load_extension_spec(\n            extension_import, app_extension_settings or {}\n        )\n    except Exception as e:\n        e.add_note(f\" - Failed to load extension spec for {extension_import}\")\n        exceptions.append(e)\n        return None, exceptions\n\n    try:\n        _, failed_listeners = self._load_extension_listeners(\n            extension_spec.listeners, extension_import\n        )\n    except Exception as e:\n        e.add_note(f\" - Failed while loading listeners for {extension_import}\")\n        exceptions.append(e)\n    else:\n        exceptions.extend(failed_listeners)\n\n    try:\n        _, failed_middleware = self._load_extension_middleware(\n            extension_spec.middleware, extension_import\n        )\n    except Exception as e:\n        e.add_note(f\" - Failed while loading middleware for {extension_import}\")\n        exceptions.append(e)\n    else:\n        exceptions.extend(failed_middleware)\n\n    try:\n        self._setup_router_extension(extension_spec)\n    except Exception as e:\n        e.add_note(\n            f\" - Failed while setting up router extension for {extension_import}\"\n        )\n        exceptions.append(e)\n\n    logger.info(f\"Loaded extension {extension_spec.name!r}\")\n    return extension_spec, exceptions\n</code></pre>"},{"location":"reference/serv/extensions/loader/#serv.extensions.loader.ExtensionLoader.load_extensions","title":"load_extensions","text":"<pre><code>load_extensions(\n    extensions_config: list[dict[str, Any]],\n) -&gt; tuple[\n    list[Listener], list[Callable[[], AsyncIterator[None]]]\n]\n</code></pre> <p>Load extensions from a list of extension configs.</p> <p>Parameters:</p> Name Type Description Default <code>extensions_config</code> <code>list[dict[str, Any]]</code> <p>List of extension configs (usually from serv.config.yaml)</p> required <p>Returns:</p> Type Description <code>tuple[list[Listener], list[Callable[[], AsyncIterator[None]]]]</code> <p>Tuple of (Extension specs, Middleware iterators)</p> <p>Raises:</p> Type Description <code>ExceptionGroup</code> <p>If any errors occurred during loading</p> Source code in <code>serv/extensions/loader.py</code> <pre><code>def load_extensions(\n    self, extensions_config: list[dict[str, Any]]\n) -&gt; \"tuple[list[p.Listener], list[Callable[[], AsyncIterator[None]]]]\":\n    \"\"\"Load extensions from a list of extension configs.\n\n    Args:\n        extensions_config: List of extension configs (usually from serv.config.yaml)\n\n    Returns:\n        Tuple of (Extension specs, Middleware iterators)\n\n    Raises:\n        ExceptionGroup: If any errors occurred during loading\n    \"\"\"\n    exceptions = []\n    loaded_extensions = []\n    middleware_list = []\n    for extension_settings in extensions_config:\n        try:\n            extension_import, settings = self._process_app_extension_settings(\n                extension_settings\n            )\n            extension_spec, extension_exceptions = self.load_extension(\n                extension_import, settings\n            )\n\n        except Exception as e:\n            e.add_note(f\" - Failed to load extension {extension_settings}\")\n            exceptions.append(e)\n            continue\n        else:\n            if extension_spec:\n                known_extensions[extension_spec.path] = extension_spec\n                loaded_extensions.append(extension_spec)\n                middleware_list.extend(extension_spec.middleware)\n\n            if extension_exceptions:\n                exceptions.extend(extension_exceptions)\n\n    if exceptions:\n        logger.warning(\n            f\"Encountered {len(exceptions)} errors during extension and middleware loading.\"\n        )\n        raise ExceptionGroup(\n            \"Exceptions raised while loading extensions and middleware\", exceptions\n        )\n\n    return loaded_extensions, middleware_list\n</code></pre>"},{"location":"reference/serv/extensions/loader/#serv.extensions.loader.ExtensionSpec","title":"ExtensionSpec","text":"<pre><code>ExtensionSpec(\n    config: ExtensionConfig,\n    path: Path,\n    override_settings: dict[str, Any],\n    importer: Importer,\n)\n</code></pre> Source code in <code>serv/extensions/loader.py</code> <pre><code>def __init__(\n    self,\n    config: ExtensionConfig,\n    path: Path,\n    override_settings: dict[str, Any],\n    importer: \"Importer\",\n):\n    self.name = config[\"name\"]\n    self.version = config[\"version\"]\n    self._config = config\n    # Support both new 'listeners' and legacy 'entry_points' keys\n    self._listeners = config.get(\"listeners\", config.get(\"entry_points\", []))\n    self._middleware = config.get(\"middleware\", [])\n    self._override_settings = override_settings\n    self._path = path\n    self._routers = config.get(\"routers\", [])\n    self._importer = importer\n</code></pre>"},{"location":"reference/serv/extensions/loader/#serv.extensions.loader.ExtensionSpec.entry_points","title":"entry_points  <code>property</code>","text":"<pre><code>entry_points\n</code></pre> <p>Backward compatibility property.</p>"},{"location":"reference/serv/extensions/loader/#serv.extensions.loader.get_package_location","title":"get_package_location","text":"<pre><code>get_package_location(package_name: str) -&gt; Path\n</code></pre> <p>Retrieves the filesystem path of a Python package/module without importing it.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>Dot-separated module/package name (e.g., \"numpy\" or \"my_package.submodule\")</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Absolute path to the package directory (for packages) or module file (for single-file modules)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the package/module isn't found or is a built-in</p> Source code in <code>serv/extensions/loader.py</code> <pre><code>def get_package_location(package_name: str) -&gt; Path:\n    \"\"\"\n    Retrieves the filesystem path of a Python package/module without importing it.\n\n    Args:\n        package_name: Dot-separated module/package name (e.g., \"numpy\" or \"my_package.submodule\")\n\n    Returns:\n        Absolute path to the package directory (for packages) or module file (for single-file modules)\n\n    Raises:\n        ValueError: If the package/module isn't found or is a built-in\n    \"\"\"\n    spec = importlib.util.find_spec(package_name)\n\n    if not spec:\n        raise ValueError(f\"'{package_name}' not found in Python path\")\n    if not spec.origin:\n        raise ValueError(f\"'{package_name}' is a built-in module with no file location\")\n\n    # Handle packages (multi-file)\n    if spec.submodule_search_locations:\n        return Path(spec.submodule_search_locations[0])\n\n    # Handle single-file modules\n    return Path(spec.origin).parent\n</code></pre>"},{"location":"reference/serv/extensions/middleware/","title":"middleware","text":""},{"location":"reference/serv/extensions/middleware/#serv.extensions.middleware","title":"serv.extensions.middleware","text":""},{"location":"reference/serv/extensions/middleware/#serv.extensions.middleware.ServMiddleware","title":"ServMiddleware","text":"<pre><code>ServMiddleware(\n    container: Inject[Container], config: dict | None = None\n)\n</code></pre> <p>Base class for Serv middleware, providing enter, leave, and on_error hooks.</p> Source code in <code>serv/extensions/middleware.py</code> <pre><code>@injectable\ndef __init__(self, container: Inject[Container], config: dict | None = None):\n    self._container = container\n    self._config = config\n</code></pre>"},{"location":"reference/serv/extensions/middleware/#serv.extensions.middleware.ServMiddleware.enter","title":"enter  <code>async</code>","text":"<pre><code>enter()\n</code></pre> <p>Called before the request is processed further. Override to inspect/modify the request or return an early response.</p> Source code in <code>serv/extensions/middleware.py</code> <pre><code>async def enter(self):\n    \"\"\"\n    Called before the request is processed further.\n    Override to inspect/modify the request or return an early response.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/serv/extensions/middleware/#serv.extensions.middleware.ServMiddleware.leave","title":"leave  <code>async</code>","text":"<pre><code>leave()\n</code></pre> <p>Called after the request has been processed and a response is available. Override to inspect/modify the response. This is not called if an exception occurred during request processing.</p> Source code in <code>serv/extensions/middleware.py</code> <pre><code>async def leave(self):\n    \"\"\"\n    Called after the request has been processed and a response is available.\n    Override to inspect/modify the response. This is not called if an exception occurred\n    during request processing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/serv/extensions/middleware/#serv.extensions.middleware.ServMiddleware.on_error","title":"on_error  <code>async</code>","text":"<pre><code>on_error(exc: Exception)\n</code></pre> <p>Called if an exception occurs during request processing after 'enter'. Override to handle errors and optionally return a custom error response.</p> <p>The base implementation raises the exception again.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>Exception</code> <p>The exception that occurred.</p> required Source code in <code>serv/extensions/middleware.py</code> <pre><code>async def on_error(self, exc: Exception):\n    \"\"\"\n    Called if an exception occurs during request processing after 'enter'.\n    Override to handle errors and optionally return a custom error response.\n\n    The base implementation raises the exception again.\n\n    Args:\n        exc: The exception that occurred.\n    \"\"\"\n    raise exc\n</code></pre>"},{"location":"reference/serv/extensions/router_extension/","title":"router_extension","text":""},{"location":"reference/serv/extensions/router_extension/#serv.extensions.router_extension","title":"serv.extensions.router_extension","text":""},{"location":"reference/serv/extensions/router_extension/#serv.extensions.router_extension.RouterExtension","title":"RouterExtension","text":"<pre><code>RouterExtension(\n    *,\n    extension_spec: ExtensionSpec,\n    stand_alone: bool = False,\n)\n</code></pre> <p>               Bases: <code>Listener</code></p> Source code in <code>serv/extensions/router_extension.py</code> <pre><code>def __init__(self, *, extension_spec: \"ExtensionSpec\", stand_alone: bool = False):\n    super().__init__(extension_spec=extension_spec, stand_alone=stand_alone)\n    self._routers: dict[str, RouterBuilder] = dict(\n        self._setup_routers(extension_spec.routers)\n    )\n</code></pre>"},{"location":"reference/serv/extensions/router_extension/#serv.extensions.router_extension.RouterExtension.setup_websocket_routes","title":"setup_websocket_routes  <code>async</code>","text":"<pre><code>setup_websocket_routes(main_router: Inject[Router]) -&gt; None\n</code></pre> <p>Set up routes for WebSocket connections.</p> <p>WebSocket connections use a fresh router instance, so we need to register routes during the websocket.begin event as well.</p> Source code in <code>serv/extensions/router_extension.py</code> <pre><code>@on(\"app.websocket.begin\")\nasync def setup_websocket_routes(self, main_router: Inject[\"r.Router\"]) -&gt; None:\n    \"\"\"Set up routes for WebSocket connections.\n\n    WebSocket connections use a fresh router instance, so we need to register\n    routes during the websocket.begin event as well.\n    \"\"\"\n    for router_builder in self._routers.values():\n        router_builder.build(main_router)\n</code></pre>"},{"location":"reference/serv/http/","title":"http","text":""},{"location":"reference/serv/http/#serv.http","title":"serv.http","text":"<p>HTTP layer for Serv - request/response handling, forms, validation.</p>"},{"location":"reference/serv/http/#serv.http.DeleteRequest","title":"DeleteRequest","text":"<pre><code>DeleteRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP DELETE request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/#serv.http.FileUpload","title":"FileUpload  <code>dataclass</code>","text":"<pre><code>FileUpload(\n    filename: str | None,\n    content_type: str | None,\n    headers: dict[str, str],\n    file: IOBase,\n)\n</code></pre> <p>Represents an uploaded file from a multipart form.</p> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str | None</code> <p>Original filename from the client, if provided</p> <code>content_type</code> <code>str | None</code> <p>MIME type of the uploaded file</p> <code>headers</code> <code>dict[str, str]</code> <p>Additional headers from the multipart section</p> <code>file</code> <code>IOBase</code> <p>File-like object containing the uploaded data</p>"},{"location":"reference/serv/http/#serv.http.FileUpload.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the file handle.</p> Source code in <code>serv/http/forms.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the file handle.\"\"\"\n    return self.file.close()\n</code></pre>"},{"location":"reference/serv/http/#serv.http.FileUpload.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; bytes\n</code></pre> <p>Read the entire content of the uploaded file.</p> Source code in <code>serv/http/forms.py</code> <pre><code>async def read(self) -&gt; bytes:\n    \"\"\"Read the entire content of the uploaded file.\"\"\"\n    return self.file.read()\n</code></pre>"},{"location":"reference/serv/http/#serv.http.FileUpload.seek","title":"seek  <code>async</code>","text":"<pre><code>seek(offset: int) -&gt; int\n</code></pre> <p>Seek to a specific position in the file.</p> Source code in <code>serv/http/forms.py</code> <pre><code>async def seek(self, offset: int) -&gt; int:\n    \"\"\"Seek to a specific position in the file.\"\"\"\n    return self.file.seek(offset)\n</code></pre>"},{"location":"reference/serv/http/#serv.http.Form","title":"Form","text":"<p>Base class for defining form models with automatic validation.</p> <p>Form classes define the expected structure and types of form data. They provide validation and type checking capabilities for HTTP form submissions.</p> <p>Attributes:</p> Name Type Description <code>__form_method__</code> <p>HTTP method this form accepts (defaults to \"POST\")</p> <p>Examples:</p> <p>Basic form definition:</p> <pre><code>from serv.http.forms import Form\n\nclass ContactForm(Form):\n    name: str\n    email: str\n    message: str\n    newsletter: bool = False  # Optional field\n</code></pre> <p>Form with custom method:</p> <pre><code>class SearchForm(Form):\n    __form_method__ = \"GET\"\n\n    query: str\n    category: str | None = None\n</code></pre>"},{"location":"reference/serv/http/#serv.http.Form.matches_form_data","title":"matches_form_data  <code>classmethod</code>","text":"<pre><code>matches_form_data(form_data: dict[str, Any]) -&gt; bool\n</code></pre> <p>Check if form data matches this form's structure and types.</p> <p>Parameters:</p> Name Type Description Default <code>form_data</code> <code>dict[str, Any]</code> <p>Dictionary of form field names to values</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the form data is valid for this form class</p> Source code in <code>serv/http/forms.py</code> <pre><code>@classmethod\ndef matches_form_data(cls, form_data: dict[str, Any]) -&gt; bool:\n    \"\"\"Check if form data matches this form's structure and types.\n\n    Args:\n        form_data: Dictionary of form field names to values\n\n    Returns:\n        True if the form data is valid for this form class\n    \"\"\"\n    annotations = get_annotations(cls)\n\n    allowed_keys = set(annotations.keys())\n    required_keys = {\n        key for key, value in annotations.items() if not is_optional(value)\n    }\n\n    form_data_keys = set(form_data.keys())\n    has_missing_required_keys = required_keys - form_data_keys\n    has_extra_keys = form_data_keys &gt; allowed_keys\n    if has_missing_required_keys or has_extra_keys:\n        return False  # Form data keys do not match the expected keys\n\n    for key, value in annotations.items():\n        optional = key not in required_keys\n        if key not in form_data and not optional:\n            return False\n\n        allowed_types = get_args(value)\n        if not allowed_types:\n            allowed_types = [value]\n\n        if get_origin(value) is list and not all(\n            _is_valid_type(item, allowed_types) for item in form_data[key]\n        ):\n            return False\n\n        if key in form_data and not _is_valid_type(\n            form_data[key][0], allowed_types\n        ):\n            return False\n\n    return True  # All fields match\n</code></pre>"},{"location":"reference/serv/http/#serv.http.GetRequest","title":"GetRequest","text":"<pre><code>GetRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP GET request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/#serv.http.PatchRequest","title":"PatchRequest","text":"<pre><code>PatchRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP PATCH request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/#serv.http.PostRequest","title":"PostRequest","text":"<pre><code>PostRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP POST request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/#serv.http.PutRequest","title":"PutRequest","text":"<pre><code>PutRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP PUT request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/#serv.http.ResponseBuilder","title":"ResponseBuilder","text":"<pre><code>ResponseBuilder(send_callable)\n</code></pre> <p>Builder for constructing HTTP responses in Serv applications.</p> <pre><code>The ResponseBuilder provides a fluent interface for building HTTP responses,\nincluding setting status codes, headers, cookies, and response bodies. It\nsupports streaming responses, various content types, and automatic encoding.\n\nThe ResponseBuilder is automatically injected into route handlers and middleware\nthrough the dependency injection system, so you typically don't need to\ninstantiate it directly.\n\nFeatures:\n- Fluent API for chaining method calls\n- Automatic content-type detection and encoding\n- Cookie management (set, delete)\n- Header manipulation\n- Streaming response support\n- Redirect helpers\n- Multiple body content types (str, bytes, iterables, async iterables)\n\nExamples:\n    Basic response:\n\n    ```python\n    from serv.http.responses import ResponseBuilder\n    from bevy import injectable, Inject\n\n    @injectable\n    async def my_handler(response: Inject[ResponseBuilder]):\n        response.set_status(200)\n        response.content_type(\"text/plain\")\n        response.body(\"Hello, World!\")\n    ```\n\n    JSON response:\n\n    ```python\n    import json\n\n    @injectable\n    async def api_handler(response: Inject[ResponseBuilder]):\n        data = {\"message\": \"Hello\", \"status\": \"success\"}\n        response.set_status(200)\n        response.content_type(\"application/json\")\n        response.body(json.dumps(data))\n    ```\n\n    HTML response with headers:\n\n    ```python\n    @injectable\n    async def html_handler(response: Inject[ResponseBuilder]):\n        html = \"&lt;h1&gt;Welcome&lt;/h1&gt;&lt;p&gt;This is a test page.&lt;/p&gt;\"\n        response.set_status(200)\n        response.content_type(\"text/html\")\n        response.add_header(\"X-Custom-Header\", \"MyValue\")\n        response.body(html)\n    ```\n\n    Redirect response:\n\n    ```python\n    @injectable\n    async def redirect_handler(response: Inject[ResponseBuilder]):\n        response.redirect(\"/new-location\", status_code=301)\n    ```\n\n    Cookie management:\n\n    ```python\n    @injectable\n    async def cookie_handler(response: Inject[ResponseBuilder]):\n        response.set_cookie(\"session_id\", \"abc123\", max_age=3600, httponly=True)\n        response.set_cookie(\"theme\", \"dark\", path=\"/\", secure=True)\n        response.body(\"Cookies set!\")\n    ```\n\n    Streaming response:\n\n    ```python\n    @injectable\n    async def stream_handler(response: Inject[ResponseBuilder]):\n        response.content_type(\"text/plain\")\n\n        # Add multiple body components\n        response.body(\"Starting stream...\n</code></pre> <p>\")             response.body(\"Processing data... \")</p> <pre><code>        # Add async iterable\n        async def data_generator():\n            for i in range(5):\n                yield f\"Item {i}\n</code></pre> <p>\"                     await asyncio.sleep(0.1)</p> <pre><code>        response.body(data_generator())\n        response.body(\"Stream complete!\")\n    ```\n\n    Chained method calls:\n\n    ```python\n    @injectable\n    async def chained_handler(response: Inject[ResponseBuilder]):\n        (response\n            .set_status(201)\n            .content_type(\"application/json\")\n            .add_header(\"Location\", \"/api/users/123\")\n            .set_cookie(\"last_action\", \"create_user\")\n            .body('{\"id\": 123, \"name\": \"John Doe\"}'))\n    ```\n\nNote:\n    The ResponseBuilder automatically handles encoding, content-length calculation,\n    and proper ASGI message formatting. Once `send_response()` is called (which\n    happens automatically at the end of request processing), no further\n    modifications can be made to the response.\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def __init__(self, send_callable):\n    self._send = send_callable\n\n    self._status = 200\n    self._headers = []  # List of (name_bytes, value_bytes)\n    self._body_components = []\n    self._headers_sent = False\n    self._default_encoding = \"utf-8\"\n    self._has_content_type = False\n</code></pre>"},{"location":"reference/serv/http/#serv.http.ResponseBuilder.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clears the response body and headers. This is useful for error handlers. It cannot change anything that has already been sent, it only affects future sends and is intended to be used before send_response() has been called.</p> Source code in <code>serv/http/responses.py</code> <pre><code>def clear(self):\n    \"\"\"Clears the response body and headers. This is useful for error handlers. It cannot change\n    anything that has already been sent, it only affects future sends and is intended to be used\n    before send_response() has been called.\"\"\"\n    self._body_components = []\n    self._headers = []\n    self._status = 200\n    return self\n</code></pre>"},{"location":"reference/serv/http/#serv.http.ResponseBuilder.content_type","title":"content_type","text":"<pre><code>content_type(ctype: str, charset: str | None = None)\n</code></pre> <p>Set the Content-Type header for the response.</p> <p>Parameters:</p> Name Type Description Default <code>ctype</code> <code>str</code> <p>MIME type (e.g., \"text/html\", \"application/json\").</p> required <code>charset</code> <code>str | None</code> <p>Character encoding. Defaults to \"utf-8\" if not specified.</p> <code>None</code> <p>Returns:</p> Type Description <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If headers have already been sent.</p> <p>Examples:</p> <pre><code>response.content_type(\"text/html\")\nresponse.content_type(\"application/json\")\nresponse.content_type(\"text/plain\", charset=\"iso-8859-1\")\nresponse.content_type(\"image/png\")  # No charset for binary content\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def content_type(self, ctype: str, charset: str | None = None):\n    \"\"\"Set the Content-Type header for the response.\n\n    Args:\n        ctype: MIME type (e.g., \"text/html\", \"application/json\").\n        charset: Character encoding. Defaults to \"utf-8\" if not specified.\n\n    Returns:\n        Self for method chaining.\n\n    Raises:\n        RuntimeError: If headers have already been sent.\n\n    Examples:\n        ```python\n        response.content_type(\"text/html\")\n        response.content_type(\"application/json\")\n        response.content_type(\"text/plain\", charset=\"iso-8859-1\")\n        response.content_type(\"image/png\")  # No charset for binary content\n        ```\n    \"\"\"\n    if self._headers_sent:\n        raise RuntimeError(\"Cannot set content_type after headers have been sent.\")\n    if charset is None:\n        charset = self._default_encoding\n    # Remove existing Content-Type headers before adding the new one to avoid duplicates\n    self._headers = [h for h in self._headers if h[0] != b\"content-type\"]\n    self.add_header(\"Content-Type\", f\"{ctype}; charset={charset}\")\n    self._has_content_type = True  # Explicitly set true by this method\n    return self\n</code></pre>"},{"location":"reference/serv/http/#serv.http.ResponseBuilder.delete_cookie","title":"delete_cookie","text":"<pre><code>delete_cookie(\n    key: str,\n    path: str = \"/\",\n    domain: str | None = None,\n    secure: bool = False,\n    httponly: bool = False,\n    samesite: str = \"lax\",\n)\n</code></pre> <p>Instructs the client to delete a cookie by setting its Max-Age to 0 and an expiry date in the past.</p> Source code in <code>serv/http/responses.py</code> <pre><code>def delete_cookie(\n    self,\n    key: str,\n    path: str = \"/\",\n    domain: str | None = None,\n    secure: bool = False,\n    httponly: bool = False,\n    samesite: str = \"lax\",\n):\n    \"\"\"Instructs the client to delete a cookie by setting its Max-Age to 0 and an expiry date in the past.\"\"\"\n    # Setting Max-Age=0 is the primary method. Expires is a fallback.\n    # Use a known past date string for Expires for robustness.\n    past_expiry_date = \"Thu, 01 Jan 1970 00:00:00 GMT\"\n    self.set_cookie(\n        key,\n        value=\"\",\n        max_age=0,\n        path=path,\n        domain=domain,\n        expires=past_expiry_date,\n        secure=secure,\n        httponly=httponly,\n        samesite=samesite,\n    )\n    return self\n</code></pre>"},{"location":"reference/serv/http/#serv.http.ResponseBuilder.set_status","title":"set_status","text":"<pre><code>set_status(status_code: int)\n</code></pre> <p>Set the HTTP status code for the response.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int</code> <p>HTTP status code (e.g., 200, 404, 500).</p> required <p>Returns:</p> Type Description <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If headers have already been sent.</p> <p>Examples:</p> <pre><code>response.set_status(200)  # OK\nresponse.set_status(404)  # Not Found\nresponse.set_status(500)  # Internal Server Error\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def set_status(self, status_code: int):\n    \"\"\"Set the HTTP status code for the response.\n\n    Args:\n        status_code: HTTP status code (e.g., 200, 404, 500).\n\n    Returns:\n        Self for method chaining.\n\n    Raises:\n        RuntimeError: If headers have already been sent.\n\n    Examples:\n        ```python\n        response.set_status(200)  # OK\n        response.set_status(404)  # Not Found\n        response.set_status(500)  # Internal Server Error\n        ```\n    \"\"\"\n    if self._headers_sent:\n        raise RuntimeError(\"Cannot set status after headers have been sent.\")\n    self._status = status_code\n    return self\n</code></pre>"},{"location":"reference/serv/http/forms/","title":"forms","text":""},{"location":"reference/serv/http/forms/#serv.http.forms","title":"serv.http.forms","text":"<p>Form processing utilities for HTTP requests.</p>"},{"location":"reference/serv/http/forms/#serv.http.forms.FileUpload","title":"FileUpload  <code>dataclass</code>","text":"<pre><code>FileUpload(\n    filename: str | None,\n    content_type: str | None,\n    headers: dict[str, str],\n    file: IOBase,\n)\n</code></pre> <p>Represents an uploaded file from a multipart form.</p> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str | None</code> <p>Original filename from the client, if provided</p> <code>content_type</code> <code>str | None</code> <p>MIME type of the uploaded file</p> <code>headers</code> <code>dict[str, str]</code> <p>Additional headers from the multipart section</p> <code>file</code> <code>IOBase</code> <p>File-like object containing the uploaded data</p>"},{"location":"reference/serv/http/forms/#serv.http.forms.FileUpload.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the file handle.</p> Source code in <code>serv/http/forms.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the file handle.\"\"\"\n    return self.file.close()\n</code></pre>"},{"location":"reference/serv/http/forms/#serv.http.forms.FileUpload.read","title":"read  <code>async</code>","text":"<pre><code>read() -&gt; bytes\n</code></pre> <p>Read the entire content of the uploaded file.</p> Source code in <code>serv/http/forms.py</code> <pre><code>async def read(self) -&gt; bytes:\n    \"\"\"Read the entire content of the uploaded file.\"\"\"\n    return self.file.read()\n</code></pre>"},{"location":"reference/serv/http/forms/#serv.http.forms.FileUpload.seek","title":"seek  <code>async</code>","text":"<pre><code>seek(offset: int) -&gt; int\n</code></pre> <p>Seek to a specific position in the file.</p> Source code in <code>serv/http/forms.py</code> <pre><code>async def seek(self, offset: int) -&gt; int:\n    \"\"\"Seek to a specific position in the file.\"\"\"\n    return self.file.seek(offset)\n</code></pre>"},{"location":"reference/serv/http/forms/#serv.http.forms.Form","title":"Form","text":"<p>Base class for defining form models with automatic validation.</p> <p>Form classes define the expected structure and types of form data. They provide validation and type checking capabilities for HTTP form submissions.</p> <p>Attributes:</p> Name Type Description <code>__form_method__</code> <p>HTTP method this form accepts (defaults to \"POST\")</p> <p>Examples:</p> <p>Basic form definition:</p> <pre><code>from serv.http.forms import Form\n\nclass ContactForm(Form):\n    name: str\n    email: str\n    message: str\n    newsletter: bool = False  # Optional field\n</code></pre> <p>Form with custom method:</p> <pre><code>class SearchForm(Form):\n    __form_method__ = \"GET\"\n\n    query: str\n    category: str | None = None\n</code></pre>"},{"location":"reference/serv/http/forms/#serv.http.forms.Form.matches_form_data","title":"matches_form_data  <code>classmethod</code>","text":"<pre><code>matches_form_data(form_data: dict[str, Any]) -&gt; bool\n</code></pre> <p>Check if form data matches this form's structure and types.</p> <p>Parameters:</p> Name Type Description Default <code>form_data</code> <code>dict[str, Any]</code> <p>Dictionary of form field names to values</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the form data is valid for this form class</p> Source code in <code>serv/http/forms.py</code> <pre><code>@classmethod\ndef matches_form_data(cls, form_data: dict[str, Any]) -&gt; bool:\n    \"\"\"Check if form data matches this form's structure and types.\n\n    Args:\n        form_data: Dictionary of form field names to values\n\n    Returns:\n        True if the form data is valid for this form class\n    \"\"\"\n    annotations = get_annotations(cls)\n\n    allowed_keys = set(annotations.keys())\n    required_keys = {\n        key for key, value in annotations.items() if not is_optional(value)\n    }\n\n    form_data_keys = set(form_data.keys())\n    has_missing_required_keys = required_keys - form_data_keys\n    has_extra_keys = form_data_keys &gt; allowed_keys\n    if has_missing_required_keys or has_extra_keys:\n        return False  # Form data keys do not match the expected keys\n\n    for key, value in annotations.items():\n        optional = key not in required_keys\n        if key not in form_data and not optional:\n            return False\n\n        allowed_types = get_args(value)\n        if not allowed_types:\n            allowed_types = [value]\n\n        if get_origin(value) is list and not all(\n            _is_valid_type(item, allowed_types) for item in form_data[key]\n        ):\n            return False\n\n        if key in form_data and not _is_valid_type(\n            form_data[key][0], allowed_types\n        ):\n            return False\n\n    return True  # All fields match\n</code></pre>"},{"location":"reference/serv/http/forms/#serv.http.forms.is_optional","title":"is_optional","text":"<pre><code>is_optional(annotation: Any) -&gt; bool\n</code></pre> <p>Check if a type annotation represents an optional field.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Any</code> <p>Type annotation to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the annotation is optional (Union with None or list)</p> Source code in <code>serv/http/forms.py</code> <pre><code>def is_optional(annotation: Any) -&gt; bool:\n    \"\"\"Check if a type annotation represents an optional field.\n\n    Args:\n        annotation: Type annotation to check\n\n    Returns:\n        True if the annotation is optional (Union with None or list)\n    \"\"\"\n    origin = normalized_origin(annotation)\n    if origin is list:\n        return True\n\n    if origin is Union and NoneType in get_args(annotation):\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/serv/http/forms/#serv.http.forms.normalized_origin","title":"normalized_origin","text":"<pre><code>normalized_origin(annotation: Any) -&gt; Any\n</code></pre> <p>Normalize type annotation origin for consistent handling.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Any</code> <p>Type annotation to normalize</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Normalized type origin</p> Source code in <code>serv/http/forms.py</code> <pre><code>def normalized_origin(annotation: Any) -&gt; Any:\n    \"\"\"Normalize type annotation origin for consistent handling.\n\n    Args:\n        annotation: Type annotation to normalize\n\n    Returns:\n        Normalized type origin\n    \"\"\"\n    origin = get_origin(annotation)\n    if origin is UnionType:\n        return Union\n    return origin\n</code></pre>"},{"location":"reference/serv/http/requests/","title":"requests","text":""},{"location":"reference/serv/http/requests/#serv.http.requests","title":"serv.http.requests","text":"<p>HTTP request classes and request handling utilities.</p>"},{"location":"reference/serv/http/requests/#serv.http.requests.DeleteRequest","title":"DeleteRequest","text":"<pre><code>DeleteRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP DELETE request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/requests/#serv.http.requests.GetRequest","title":"GetRequest","text":"<pre><code>GetRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP GET request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/requests/#serv.http.requests.HeadRequest","title":"HeadRequest","text":"<pre><code>HeadRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP HEAD request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/requests/#serv.http.requests.OptionsRequest","title":"OptionsRequest","text":"<pre><code>OptionsRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP OPTIONS request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/requests/#serv.http.requests.PatchRequest","title":"PatchRequest","text":"<pre><code>PatchRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP PATCH request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/requests/#serv.http.requests.PostRequest","title":"PostRequest","text":"<pre><code>PostRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP POST request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/requests/#serv.http.requests.PutRequest","title":"PutRequest","text":"<pre><code>PutRequest(scope, receive)\n</code></pre> <p>               Bases: <code>Request</code></p> <p>HTTP PUT request type marker for dependency injection and route handling.</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/requests/#serv.http.requests.Request","title":"Request","text":"<pre><code>Request(scope, receive)\n</code></pre> <p>HTTP request object providing access to request data and parsing utilities.</p> <p>The Request class encapsulates all information about an incoming HTTP request, including headers, body, query parameters, cookies, and provides methods for parsing different content types like JSON, form data, and file uploads.</p> <p>This class is automatically injected into route handlers through the dependency injection system, so you typically don't need to instantiate it directly.</p> <p>Examples:</p> <p>Basic request handling:</p> <pre><code>from serv.routes import Route, GetRequest, PostRequest\nfrom serv.responses import JsonResponse\nfrom typing import Annotated\n\nclass ApiRoute(Route):\n    async def handle_get(self, request: GetRequest) -&gt; Annotated[dict, JsonResponse]:\n        # Access query parameters\n        user_id = request.query_params.get(\"user_id\")\n        page = int(request.query_params.get(\"page\", \"1\"))\n\n        # Access headers\n        auth_token = request.headers.get(\"authorization\")\n\n        return {\"user_id\": user_id, \"page\": page}\n\n    async def handle_post(self, request: PostRequest) -&gt; Annotated[dict, JsonResponse]:\n        # Parse JSON body\n        data = await request.json()\n\n        # Access cookies\n        session_id = request.cookies.get(\"session_id\")\n\n        return {\"received\": data, \"session\": session_id}\n</code></pre> <p>Form data handling:</p> <pre><code>from serv.routes import Form\n\nclass UserForm(Form):\n    name: str\n    email: str\n    age: int\n\nclass UserRoute(Route):\n    async def handle_post(self, request: PostRequest):\n        # Parse form data into a model\n        form_data = await request.form(UserForm)\n\n        # Access typed form fields\n        print(f\"Name: {form_data.name}, Age: {form_data.age}\")\n\n        return {\"status\": \"success\"}\n</code></pre> <p>File upload handling:</p> <pre><code>class UploadRoute(Route):\n    async def handle_post(self, request: PostRequest):\n        # Parse multipart form data\n        form_data = await request.form()\n\n        # Access uploaded files\n        if \"avatar\" in form_data:\n            file_upload = form_data[\"avatar\"]\n            filename = file_upload.filename\n            content = await file_upload.read()\n\n            # Save file or process content\n            with open(f\"uploads/{filename}\", \"wb\") as f:\n                f.write(content)\n\n        return {\"status\": \"uploaded\"}\n</code></pre> <p>Raw body access:</p> <pre><code>class WebhookRoute(Route):\n    async def handle_post(self, request: PostRequest):\n        # Get raw body bytes\n        raw_body = await request.body()\n\n        # Or stream large bodies\n        chunks = []\n        async for chunk in request.read(max_size=1024*1024):  # 1MB chunks\n            chunks.append(chunk)\n\n        return {\"received_bytes\": len(raw_body)}\n</code></pre> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>HTTP method (GET, POST, etc.)</p> <code>path</code> <code>str</code> <p>Request path without query string</p> <code>query_string</code> <code>str</code> <p>Raw query string</p> <code>query_params</code> <code>dict</code> <p>Parsed query parameters as dict</p> <code>headers</code> <code>dict</code> <p>Request headers as dict (lowercase keys)</p> <code>cookies</code> <code>dict</code> <p>Parsed cookies as dict</p> <code>scheme</code> <code>str</code> <p>URL scheme (http, https)</p> <code>client</code> <p>Client address information</p> <code>server</code> <p>Server address information</p> <code>http_version</code> <code>str</code> <p>HTTP version string</p> Source code in <code>serv/requests.py</code> <pre><code>def __init__(self, scope, receive):\n    if scope[\"type\"] != \"http\":\n        raise RuntimeError(\"Request only supports HTTP scope\")\n\n    self.scope = scope\n    self._receive = receive\n\n    self._body_consumed = False\n    self._buffer = bytearray()\n</code></pre>"},{"location":"reference/serv/http/requests/#serv.http.requests.Request.body","title":"body  <code>async</code>","text":"<pre><code>body(max_size: int = 10 * 1024 * 1024) -&gt; bytes\n</code></pre> <p>Returns the request body as bytes up to max_size (default 10MB). Aggregates chunks from the read() stream.</p> Source code in <code>serv/requests.py</code> <pre><code>async def body(self, max_size: int = 10 * 1024 * 1024) -&gt; bytes:\n    \"\"\"\n    Returns the request body as bytes up to max_size (default 10MB).\n    Aggregates chunks from the read() stream.\n    \"\"\"\n    body_bytes = bytearray()\n    async for chunk in self.read(max_size=max_size):\n        body_bytes.extend(chunk)\n    return bytes(body_bytes)\n</code></pre>"},{"location":"reference/serv/http/requests/#serv.http.requests.Request.read","title":"read  <code>async</code>","text":"<pre><code>read(max_size: int = -1)\n</code></pre> <p>Async generator yielding chunks of the request body as bytes.</p> <p>Stops when no more chunks are available. If max_size is set, it only yields that many bytes across all yielded chunks.</p> <p>This method raises a RuntimeError if the body has been fully consumed.</p> Source code in <code>serv/requests.py</code> <pre><code>async def read(self, max_size: int = -1):\n    \"\"\"\n    Async generator yielding chunks of the request body as bytes.\n\n    Stops when no more chunks are available. If max_size is set, it only yields that many bytes\n    across all yielded chunks.\n\n    This method raises a RuntimeError if the body has been fully consumed.\n    \"\"\"\n    if self._body_consumed and not self._buffer:\n        raise RuntimeError(\"Request body already consumed\")\n\n    total_read = 0\n    while not self._body_consumed or self._buffer:\n        if not self._body_consumed and (\n            not self._buffer or total_read + len(self._buffer) &lt; max_size\n            if max_size &gt; 0\n            else True\n        ):\n            message = await self._receive()\n            if message[\"type\"] != \"http.request\":\n                break\n\n            self._buffer.extend(message.get(\"body\", b\"\"))\n            self._body_consumed = not message.get(\"more_body\", False)\n\n        if max_size &lt;= 0 or total_read + len(self._buffer) &lt;= max_size:\n            yield self._buffer\n            total_read += len(self._buffer)\n            self._buffer.clear()\n        else:  # max_size &gt; 0 and total_read + len(self._buffer) &gt; max_size\n            can_yield = max_size - total_read\n            yield self._buffer[:can_yield]\n            self._buffer = self._buffer[can_yield:]\n            total_read = max_size  # or total_read += can_yield\n            break\n</code></pre>"},{"location":"reference/serv/http/responses/","title":"responses","text":""},{"location":"reference/serv/http/responses/#serv.http.responses","title":"serv.http.responses","text":"<p>HTTP response classes and response building utilities.</p>"},{"location":"reference/serv/http/responses/#serv.http.responses.ResponseBuilder","title":"ResponseBuilder","text":"<pre><code>ResponseBuilder(send_callable)\n</code></pre> <p>Builder for constructing HTTP responses in Serv applications.</p> <pre><code>The ResponseBuilder provides a fluent interface for building HTTP responses,\nincluding setting status codes, headers, cookies, and response bodies. It\nsupports streaming responses, various content types, and automatic encoding.\n\nThe ResponseBuilder is automatically injected into route handlers and middleware\nthrough the dependency injection system, so you typically don't need to\ninstantiate it directly.\n\nFeatures:\n- Fluent API for chaining method calls\n- Automatic content-type detection and encoding\n- Cookie management (set, delete)\n- Header manipulation\n- Streaming response support\n- Redirect helpers\n- Multiple body content types (str, bytes, iterables, async iterables)\n\nExamples:\n    Basic response:\n\n    ```python\n    from serv.http.responses import ResponseBuilder\n    from bevy import injectable, Inject\n\n    @injectable\n    async def my_handler(response: Inject[ResponseBuilder]):\n        response.set_status(200)\n        response.content_type(\"text/plain\")\n        response.body(\"Hello, World!\")\n    ```\n\n    JSON response:\n\n    ```python\n    import json\n\n    @injectable\n    async def api_handler(response: Inject[ResponseBuilder]):\n        data = {\"message\": \"Hello\", \"status\": \"success\"}\n        response.set_status(200)\n        response.content_type(\"application/json\")\n        response.body(json.dumps(data))\n    ```\n\n    HTML response with headers:\n\n    ```python\n    @injectable\n    async def html_handler(response: Inject[ResponseBuilder]):\n        html = \"&lt;h1&gt;Welcome&lt;/h1&gt;&lt;p&gt;This is a test page.&lt;/p&gt;\"\n        response.set_status(200)\n        response.content_type(\"text/html\")\n        response.add_header(\"X-Custom-Header\", \"MyValue\")\n        response.body(html)\n    ```\n\n    Redirect response:\n\n    ```python\n    @injectable\n    async def redirect_handler(response: Inject[ResponseBuilder]):\n        response.redirect(\"/new-location\", status_code=301)\n    ```\n\n    Cookie management:\n\n    ```python\n    @injectable\n    async def cookie_handler(response: Inject[ResponseBuilder]):\n        response.set_cookie(\"session_id\", \"abc123\", max_age=3600, httponly=True)\n        response.set_cookie(\"theme\", \"dark\", path=\"/\", secure=True)\n        response.body(\"Cookies set!\")\n    ```\n\n    Streaming response:\n\n    ```python\n    @injectable\n    async def stream_handler(response: Inject[ResponseBuilder]):\n        response.content_type(\"text/plain\")\n\n        # Add multiple body components\n        response.body(\"Starting stream...\n</code></pre> <p>\")             response.body(\"Processing data... \")</p> <pre><code>        # Add async iterable\n        async def data_generator():\n            for i in range(5):\n                yield f\"Item {i}\n</code></pre> <p>\"                     await asyncio.sleep(0.1)</p> <pre><code>        response.body(data_generator())\n        response.body(\"Stream complete!\")\n    ```\n\n    Chained method calls:\n\n    ```python\n    @injectable\n    async def chained_handler(response: Inject[ResponseBuilder]):\n        (response\n            .set_status(201)\n            .content_type(\"application/json\")\n            .add_header(\"Location\", \"/api/users/123\")\n            .set_cookie(\"last_action\", \"create_user\")\n            .body('{\"id\": 123, \"name\": \"John Doe\"}'))\n    ```\n\nNote:\n    The ResponseBuilder automatically handles encoding, content-length calculation,\n    and proper ASGI message formatting. Once `send_response()` is called (which\n    happens automatically at the end of request processing), no further\n    modifications can be made to the response.\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def __init__(self, send_callable):\n    self._send = send_callable\n\n    self._status = 200\n    self._headers = []  # List of (name_bytes, value_bytes)\n    self._body_components = []\n    self._headers_sent = False\n    self._default_encoding = \"utf-8\"\n    self._has_content_type = False\n</code></pre>"},{"location":"reference/serv/http/responses/#serv.http.responses.ResponseBuilder.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clears the response body and headers. This is useful for error handlers. It cannot change anything that has already been sent, it only affects future sends and is intended to be used before send_response() has been called.</p> Source code in <code>serv/http/responses.py</code> <pre><code>def clear(self):\n    \"\"\"Clears the response body and headers. This is useful for error handlers. It cannot change\n    anything that has already been sent, it only affects future sends and is intended to be used\n    before send_response() has been called.\"\"\"\n    self._body_components = []\n    self._headers = []\n    self._status = 200\n    return self\n</code></pre>"},{"location":"reference/serv/http/responses/#serv.http.responses.ResponseBuilder.content_type","title":"content_type","text":"<pre><code>content_type(ctype: str, charset: str | None = None)\n</code></pre> <p>Set the Content-Type header for the response.</p> <p>Parameters:</p> Name Type Description Default <code>ctype</code> <code>str</code> <p>MIME type (e.g., \"text/html\", \"application/json\").</p> required <code>charset</code> <code>str | None</code> <p>Character encoding. Defaults to \"utf-8\" if not specified.</p> <code>None</code> <p>Returns:</p> Type Description <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If headers have already been sent.</p> <p>Examples:</p> <pre><code>response.content_type(\"text/html\")\nresponse.content_type(\"application/json\")\nresponse.content_type(\"text/plain\", charset=\"iso-8859-1\")\nresponse.content_type(\"image/png\")  # No charset for binary content\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def content_type(self, ctype: str, charset: str | None = None):\n    \"\"\"Set the Content-Type header for the response.\n\n    Args:\n        ctype: MIME type (e.g., \"text/html\", \"application/json\").\n        charset: Character encoding. Defaults to \"utf-8\" if not specified.\n\n    Returns:\n        Self for method chaining.\n\n    Raises:\n        RuntimeError: If headers have already been sent.\n\n    Examples:\n        ```python\n        response.content_type(\"text/html\")\n        response.content_type(\"application/json\")\n        response.content_type(\"text/plain\", charset=\"iso-8859-1\")\n        response.content_type(\"image/png\")  # No charset for binary content\n        ```\n    \"\"\"\n    if self._headers_sent:\n        raise RuntimeError(\"Cannot set content_type after headers have been sent.\")\n    if charset is None:\n        charset = self._default_encoding\n    # Remove existing Content-Type headers before adding the new one to avoid duplicates\n    self._headers = [h for h in self._headers if h[0] != b\"content-type\"]\n    self.add_header(\"Content-Type\", f\"{ctype}; charset={charset}\")\n    self._has_content_type = True  # Explicitly set true by this method\n    return self\n</code></pre>"},{"location":"reference/serv/http/responses/#serv.http.responses.ResponseBuilder.delete_cookie","title":"delete_cookie","text":"<pre><code>delete_cookie(\n    key: str,\n    path: str = \"/\",\n    domain: str | None = None,\n    secure: bool = False,\n    httponly: bool = False,\n    samesite: str = \"lax\",\n)\n</code></pre> <p>Instructs the client to delete a cookie by setting its Max-Age to 0 and an expiry date in the past.</p> Source code in <code>serv/http/responses.py</code> <pre><code>def delete_cookie(\n    self,\n    key: str,\n    path: str = \"/\",\n    domain: str | None = None,\n    secure: bool = False,\n    httponly: bool = False,\n    samesite: str = \"lax\",\n):\n    \"\"\"Instructs the client to delete a cookie by setting its Max-Age to 0 and an expiry date in the past.\"\"\"\n    # Setting Max-Age=0 is the primary method. Expires is a fallback.\n    # Use a known past date string for Expires for robustness.\n    past_expiry_date = \"Thu, 01 Jan 1970 00:00:00 GMT\"\n    self.set_cookie(\n        key,\n        value=\"\",\n        max_age=0,\n        path=path,\n        domain=domain,\n        expires=past_expiry_date,\n        secure=secure,\n        httponly=httponly,\n        samesite=samesite,\n    )\n    return self\n</code></pre>"},{"location":"reference/serv/http/responses/#serv.http.responses.ResponseBuilder.set_status","title":"set_status","text":"<pre><code>set_status(status_code: int)\n</code></pre> <p>Set the HTTP status code for the response.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int</code> <p>HTTP status code (e.g., 200, 404, 500).</p> required <p>Returns:</p> Type Description <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If headers have already been sent.</p> <p>Examples:</p> <pre><code>response.set_status(200)  # OK\nresponse.set_status(404)  # Not Found\nresponse.set_status(500)  # Internal Server Error\n</code></pre> Source code in <code>serv/http/responses.py</code> <pre><code>def set_status(self, status_code: int):\n    \"\"\"Set the HTTP status code for the response.\n\n    Args:\n        status_code: HTTP status code (e.g., 200, 404, 500).\n\n    Returns:\n        Self for method chaining.\n\n    Raises:\n        RuntimeError: If headers have already been sent.\n\n    Examples:\n        ```python\n        response.set_status(200)  # OK\n        response.set_status(404)  # Not Found\n        response.set_status(500)  # Internal Server Error\n        ```\n    \"\"\"\n    if self._headers_sent:\n        raise RuntimeError(\"Cannot set status after headers have been sent.\")\n    self._status = status_code\n    return self\n</code></pre>"},{"location":"reference/serv/routing/","title":"routing","text":""},{"location":"reference/serv/routing/#serv.routing","title":"serv.routing","text":"<p>Routing layer for Serv - URL patterns, route resolution, handlers.</p>"},{"location":"reference/serv/routing/#serv.routing.Route","title":"Route","text":"<p>Base class for creating HTTP route handlers in Serv applications.</p> <p>Route classes provide a structured way to handle HTTP requests by defining methods that correspond to HTTP methods (GET, POST, etc.) and form handlers. They support automatic request parsing, response type annotations, error handling, and dependency injection.</p> <p>The Route class automatically discovers handler methods based on their naming patterns and signatures: - Methods named <code>handle_&lt;method&gt;</code> become HTTP method handlers (e.g., <code>handle_get</code>, <code>handle_post</code>) - Methods with Form subclass parameters become form handlers - Methods with Exception parameters become error handlers - Return type annotations determine response wrapper classes - Handler selection is based on signature matching with request data</p> <p>Examples:</p> <p>Basic route with HTTP method handlers:</p> <pre><code>from serv.routes import Route\nfrom serv.responses import JsonResponse, TextResponse\nfrom serv.injectors import Query, Header\nfrom typing import Annotated\n\nclass UserRoute(Route):\n    async def handle_get(self, user_id: Annotated[str, Query(\"id\")]) -&gt; Annotated[dict, JsonResponse]:\n        return {\"id\": user_id, \"name\": \"John Doe\"}\n\n    async def handle_post(self, data: dict) -&gt; Annotated[str, TextResponse]:\n        # Create user logic here\n        return \"User created successfully\"\n</code></pre> <p>Route with multiple GET handlers based on parameters:</p> <pre><code>class ProductRoute(Route):\n    # Handler for requests with 'id' query parameter\n    async def handle_get(self, product_id: Annotated[str, Query(\"id\")]) -&gt; Annotated[dict, JsonResponse]:\n        return {\"id\": product_id, \"name\": \"Product Name\"}\n\n    # Handler for requests with 'category' query parameter\n    async def handle_get_by_category(self, category: Annotated[str, Query(\"category\")]) -&gt; Annotated[list, JsonResponse]:\n        return [{\"id\": 1, \"name\": \"Product 1\"}, {\"id\": 2, \"name\": \"Product 2\"}]\n\n    # Handler for requests with no specific parameters (fallback)\n    async def handle_get_all(self) -&gt; Annotated[list, JsonResponse]:\n        return [{\"id\": 1, \"name\": \"All Products\"}]\n</code></pre> <p>Route with form handling:</p> <pre><code>from serv.routes import Route, Form\nfrom serv.responses import HtmlResponse\nfrom typing import Annotated\n\nclass ContactForm(Form):\n    name: str\n    email: str\n    message: str\n\nclass ContactRoute(Route):\n    async def handle_get(self) -&gt; Annotated[str, HtmlResponse]:\n        return '''\n        &lt;form method=\"post\"&gt;\n            &lt;input name=\"name\" placeholder=\"Name\" required&gt;\n            &lt;input name=\"email\" type=\"email\" placeholder=\"Email\" required&gt;\n            &lt;textarea name=\"message\" placeholder=\"Message\" required&gt;&lt;/textarea&gt;\n            &lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n        &lt;/form&gt;\n        '''\n\n    async def handle_contact_form(self, form: ContactForm) -&gt; Annotated[str, HtmlResponse]:\n        # Process the form submission\n        await self.send_email(form.email, form.name, form.message)\n        return \"&lt;h1&gt;Thank you! Your message has been sent.&lt;/h1&gt;\"\n</code></pre> <p>Route with header and cookie injection:</p> <pre><code>from serv.injectors import Header, Cookie\n\nclass AuthRoute(Route):\n    async def handle_get(\n        self,\n        auth_token: Annotated[str, Header(\"Authorization\")],\n        session_id: Annotated[str, Cookie(\"session_id\")]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        # Validate token and session\n        return {\"authenticated\": True, \"user\": \"john_doe\"}\n</code></pre> Note <p>Route classes are automatically instantiated by the router when a matching request is received. Handler methods are selected based on the best match between the request data and the method's parameter signature. Methods with more specific parameter requirements will be preferred over generic handlers.</p>"},{"location":"reference/serv/routing/#serv.routing.Router","title":"Router","text":"<pre><code>Router(settings: dict[str, Any] = None)\n</code></pre> <p>               Bases: <code>RouterProtocol</code></p> <p>HTTP request router for mapping URLs to handlers.</p> <p>The Router class is responsible for matching incoming HTTP requests to the appropriate handler functions or Route classes. It supports path parameters, HTTP method filtering, route mounting, and URL generation.</p> <p>Features: - Path parameter extraction (e.g., <code>/users/{id}</code>) - HTTP method-specific routing - Route mounting and sub-routers - URL generation with <code>url_for()</code> - Route settings and metadata - Flexible handler types (functions, Route classes) - WebSocket route support</p> <p>Examples:</p> <p>Basic router setup:</p> <pre><code>from serv.routing.router import Router\n\nrouter = Router()\n\n# Add function-based routes\nasync def get_users():\n    return {\"users\": []}\n\nrouter.add_route(\"/users\", get_users, [\"GET\"])\n\n# Add Route class\nclass UserRoute:\n    async def handle_get(self, request):\n        return {\"user\": \"data\"}\n\nrouter.add_route(\"/users/{id}\", UserRoute)\n\n# Add WebSocket handler\nasync def websocket_handler(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\nrouter.add_websocket(\"/ws\", websocket_handler)\n</code></pre> <p>Router with settings:</p> <pre><code>router = Router(settings={\n    \"auth_required\": True,\n    \"rate_limit\": 100\n})\n</code></pre> <p>Mounting sub-routers:</p> <pre><code>api_router = Router()\napi_router.add_route(\"/users\", users_handler)\napi_router.add_route(\"/posts\", posts_handler)\n\nmain_router = Router()\nmain_router.mount(\"/api/v1\", api_router)\n# Now /api/v1/users and /api/v1/posts are available\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of router-level settings that will be available to all routes handled by this router.</p> <code>None</code> Source code in <code>serv/routing/router.py</code> <pre><code>def __init__(self, settings: dict[str, Any] = None):\n    # Stores tuples of (path_pattern, methods, handler_callable, settings)\n    self._routes: list[\n        tuple[str, frozenset[str] | None, Callable, dict[str, Any]]\n    ] = []\n    # Stores WebSocket routes as tuples of (path_pattern, handler_callable, settings)\n    self._websocket_routes: list[tuple[str, Callable, dict[str, Any]]] = []\n    # Stores mapping of (route_class -&gt; path_pattern) for url_for lookups\n    self._route_class_paths: dict[type[routes.Route], list[str]] = {}\n    # Stores mapping of route path patterns to settings\n    self._route_settings: dict[str, dict[str, Any]] = {}\n    # Stores tuples of (mount_path, router_instance)\n    self._mounted_routers: list[tuple[str, Router]] = []\n    self._sub_routers: list[Router] = []\n    # Router-level settings\n    self._settings: dict[str, Any] = settings or {}\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.add_route","title":"add_route","text":"<pre><code>add_route(\n    path: str,\n    handler: type[Route],\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre><pre><code>add_route(\n    path: str,\n    handler: Callable[..., Awaitable[Any]],\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre> <pre><code>add_route(\n    path: str,\n    handler: Callable[..., Awaitable[Any]] | type[Route],\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n    container: Container = None,\n)\n</code></pre> <p>Adds a route to this router.</p> <p>This method can handle both direct route handlers and Route objects. For Route objects, it will automatically register all method and form handlers defined in the route.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern for the route.</p> required <code>handler</code> <code>Callable[..., Awaitable[Any]] | type[Route]</code> <p>Either a Route object or an async handler function.</p> required <code>methods</code> <code>Sequence[str] | None</code> <p>A list of HTTP methods (e.g., ['GET', 'POST']). Only used when handler is a function.     If None, allows all methods.</p> <code>None</code> <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of settings to be added to the container when handling this route.</p> <code>None</code> <code>container</code> <code>Container</code> <p>Optional container instance to use for dependency injection. If not provided, uses the global container.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; router.add_route(\"/users\", user_handler, [\"GET\", \"POST\"])\n&gt;&gt;&gt; router.add_route(\"/items\", ItemRoute, settings={\"db_table\": \"items\"})\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def add_route(\n    self,\n    path: str,\n    handler: \"Callable[..., Awaitable[Any]] | type[routes.Route]\",\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n    container: Container = None,\n):\n    \"\"\"Adds a route to this router.\n\n    This method can handle both direct route handlers and Route objects. For Route objects,\n    it will automatically register all method and form handlers defined in the route.\n\n    Args:\n        path: The path pattern for the route.\n        handler: Either a Route object or an async handler function.\n        methods: A list of HTTP methods (e.g., ['GET', 'POST']). Only used when handler is a function.\n                If None, allows all methods.\n        settings: Optional dictionary of settings to be added to the container when handling this route.\n        container: Optional container instance to use for dependency injection. If not provided, uses the global container.\n\n    Examples:\n        &gt;&gt;&gt; router.add_route(\"/users\", user_handler, [\"GET\", \"POST\"])\n        &gt;&gt;&gt; router.add_route(\"/items\", ItemRoute, settings={\"db_table\": \"items\"})\n    \"\"\"\n    match handler:\n        case type() as route if hasattr(route, \"__method_handlers__\") and hasattr(\n            route, \"__form_handlers__\"\n        ):\n            # Keep track of which paths are mapped to which Route classes\n            if route not in self._route_class_paths:\n                self._route_class_paths[route] = []\n            self._route_class_paths[route].append(path)\n\n            # Initialize the Route class directly to avoid container.call issues\n            # We'll still use a container branch to handle RouteSettings\n            if container is None:\n                # Create a new container from scratch if none was provided\n                from bevy import get_registry\n\n                container = get_registry().create_container()\n\n            with container.branch() as branch_container:\n                branch_container.add(RouteSettings, RouteSettings(**settings or {}))\n                # Create route instance directly instead of using container.call\n                try:\n                    route_instance = route()\n                except Exception as e:\n                    import logging\n\n                    logging.getLogger(__name__).error(\n                        f\"Error initializing route {route}: {e}\"\n                    )\n                    raise\n\n            methods = (\n                route.__method_handlers__.keys() | route.__form_handlers__.keys()\n            )\n            # Store these settings for the actual path\n            self._route_settings[path] = settings or {}\n            self.add_route(\n                path, route_instance.__call__, list(methods), settings=settings\n            )\n\n        case _:\n            normalized_methods = (\n                frozenset(m.upper() for m in methods) if methods else None\n            )\n            self._routes.append((path, normalized_methods, handler, settings or {}))\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.add_router","title":"add_router","text":"<pre><code>add_router(router: Router)\n</code></pre> <p>Adds a sub-router. Sub-routers are checked before the current router's own routes. Later added sub-routers are checked first (LIFO order for matching).</p> Source code in <code>serv/routing/router.py</code> <pre><code>def add_router(self, router: \"Router\"):\n    \"\"\"Adds a sub-router. Sub-routers are checked before the current router's own routes.\n    Later added sub-routers are checked first (LIFO order for matching).\"\"\"\n    self._sub_routers.append(router)\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.add_websocket","title":"add_websocket","text":"<pre><code>add_websocket(\n    path: str,\n    handler: Callable[..., Awaitable[Any]],\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre> <p>Adds a WebSocket route to this router.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern for the WebSocket route.</p> required <code>handler</code> <code>Callable[..., Awaitable[Any]]</code> <p>An async WebSocket handler function that accepts a WebSocket parameter.</p> required <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of settings to be added to the container when handling this route.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def echo_handler(websocket):\n...     async for message in websocket:\n...         await websocket.send(message)\n&gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler)\n</code></pre> <pre><code>&gt;&gt;&gt; # With settings\n&gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler, settings={\"auth_required\": True})\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def add_websocket(\n    self,\n    path: str,\n    handler: \"Callable[..., Awaitable[Any]]\",\n    *,\n    settings: dict[str, Any] = None,\n):\n    \"\"\"Adds a WebSocket route to this router.\n\n    Args:\n        path: The path pattern for the WebSocket route.\n        handler: An async WebSocket handler function that accepts a WebSocket parameter.\n        settings: Optional dictionary of settings to be added to the container when handling this route.\n\n    Examples:\n        &gt;&gt;&gt; async def echo_handler(websocket):\n        ...     async for message in websocket:\n        ...         await websocket.send(message)\n        &gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler)\n\n        &gt;&gt;&gt; # With settings\n        &gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler, settings={\"auth_required\": True})\n    \"\"\"\n    self._websocket_routes.append((path, handler, settings or {}))\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.mount","title":"mount","text":"<pre><code>mount(path: str, router: Router)\n</code></pre> <p>Mounts a router at a specific path.</p> <p>Unlike add_router which adds a router with full request path access, mount prefixes all routes in the mounted router with the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path prefix where the router should be mounted.  Should start with a '/' and not end with one.</p> required <code>router</code> <code>Router</code> <p>The router instance to mount at the specified path.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; api_router = Router()\n&gt;&gt;&gt; api_router.add_route(\"/users\", users_handler)\n&gt;&gt;&gt; main_router.mount(\"/api\", api_router)\n# Now \"/api/users\" will be handled by users_handler\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def mount(self, path: str, router: \"Router\"):\n    \"\"\"Mounts a router at a specific path.\n\n    Unlike add_router which adds a router with full request path access,\n    mount prefixes all routes in the mounted router with the given path.\n\n    Args:\n        path: The path prefix where the router should be mounted.\n             Should start with a '/' and not end with one.\n        router: The router instance to mount at the specified path.\n\n    Examples:\n        &gt;&gt;&gt; api_router = Router()\n        &gt;&gt;&gt; api_router.add_route(\"/users\", users_handler)\n        &gt;&gt;&gt; main_router.mount(\"/api\", api_router)\n        # Now \"/api/users\" will be handled by users_handler\n    \"\"\"\n    if not path.startswith(\"/\"):\n        path = \"/\" + path\n    if path.endswith(\"/\"):\n        path = path[:-1]\n\n    self._mounted_routers.append((path, router))\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.resolve_route","title":"resolve_route","text":"<pre><code>resolve_route(\n    request_path: str, request_method: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Recursively finds a handler for the given path and method.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The path of the incoming request.</p> required <code>request_method</code> <code>str</code> <p>The HTTP method of the incoming request.</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>None if no route matches the path (results in a 404).</p> <p>Raises:</p> Type Description <code>HTTPMethodNotAllowedException</code> <p>If one or more routes match the path but not the method,                            and no route matches both path and method.</p> Source code in <code>serv/routing/router.py</code> <pre><code>def resolve_route(\n    self, request_path: str, request_method: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Recursively finds a handler for the given path and method.\n\n    Args:\n        request_path: The path of the incoming request.\n        request_method: The HTTP method of the incoming request.\n\n    Returns:\n        A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.\n        None if no route matches the path (results in a 404).\n\n    Raises:\n        HTTPMethodNotAllowedException: If one or more routes match the path but not the method,\n                                       and no route matches both path and method.\n    \"\"\"\n    from serv.routing.resolvers import resolve_http_route\n\n    return resolve_http_route(\n        request_path,\n        request_method,\n        self._mounted_routers,\n        self._sub_routers,\n        self._routes,\n        self._settings,\n        self._match_path\n    )\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.resolve_websocket","title":"resolve_websocket","text":"<pre><code>resolve_websocket(\n    request_path: str,\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Resolve a WebSocket route for the given path.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The WebSocket request path to match against registered routes.</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_params, route_settings) if a matching</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>WebSocket route is found, None otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler, params, settings = router.resolve_websocket(\"/ws/user/123\")\n&gt;&gt;&gt; if handler:\n...     # Handle WebSocket connection\n...     await handler(websocket, **params)\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def resolve_websocket(\n    self, request_path: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Resolve a WebSocket route for the given path.\n\n    Args:\n        request_path: The WebSocket request path to match against registered routes.\n\n    Returns:\n        A tuple of (handler_callable, path_params, route_settings) if a matching\n        WebSocket route is found, None otherwise.\n\n    Examples:\n        &gt;&gt;&gt; handler, params, settings = router.resolve_websocket(\"/ws/user/123\")\n        &gt;&gt;&gt; if handler:\n        ...     # Handle WebSocket connection\n        ...     await handler(websocket, **params)\n    \"\"\"\n    from serv.routing.resolvers import resolve_websocket_route\n\n    return resolve_websocket_route(\n        request_path,\n        self._mounted_routers,\n        self._sub_routers,\n        self._websocket_routes,\n        self._settings,\n        self._match_path\n    )\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.Router.url_for","title":"url_for","text":"<pre><code>url_for(handler: Callable | type[Route], **kwargs) -&gt; str\n</code></pre> <p>Builds a URL for a registered route handler with the given path parameters.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable | type[Route]</code> <p>The route handler function or Route class for which to build a URL.</p> required <code>**kwargs</code> <p>Path parameters to substitute in the URL pattern.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A URL string with path parameters filled in.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the handler is not found in any router, or if required path        parameters are missing from kwargs.</p> Source code in <code>serv/routing/router.py</code> <pre><code>def url_for(self, handler: Callable | type[\"routes.Route\"], **kwargs) -&gt; str:\n    \"\"\"Builds a URL for a registered route handler with the given path parameters.\n\n    Args:\n        handler: The route handler function or Route class for which to build a URL.\n        **kwargs: Path parameters to substitute in the URL pattern.\n\n    Returns:\n        A URL string with path parameters filled in.\n\n    Raises:\n        ValueError: If the handler is not found in any router, or if required path\n                   parameters are missing from kwargs.\n    \"\"\"\n    # Import generation functions to avoid circular dependency\n    from serv.routing.generation import url_for_route_class, url_for_function_handler\n\n    # Import routes at runtime to avoid circular dependency\n    import serv.routes as routes\n\n    # First check if handler is a Route class\n    if isinstance(handler, type) and issubclass(handler, routes.Route):\n        return url_for_route_class(\n            self._route_class_paths,\n            self._mounted_routers,\n            self._sub_routers,\n            handler,\n            **kwargs\n        )\n\n    # Handle methods on Route instances (less common case)\n    elif hasattr(handler, \"__self__\"):\n        if isinstance(handler.__self__, routes.Route):\n            route_instance = handler.__self__\n            handler = route_instance.__call__\n            path = self._find_handler_path(handler)\n            if not path:\n                raise ValueError(\n                    f\"Route instance method {handler.__name__} not found in any router\"\n                )\n\n            from serv.routing.generation import build_url_from_path\n            return build_url_from_path(path, kwargs)\n\n    # For function handlers\n    else:\n        return url_for_function_handler(\n            self._routes,\n            self._mounted_routers,\n            self._sub_routers,\n            handler,\n            **kwargs\n        )\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.build_url_from_path","title":"build_url_from_path","text":"<pre><code>build_url_from_path(\n    path: str, kwargs: dict[str, Any]\n) -&gt; str\n</code></pre> <p>Build a URL by substituting path parameters from kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern with parameter placeholders (e.g., \"/users/{user_id}\")</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Dictionary containing parameter values</p> required <p>Returns:</p> Type Description <code>str</code> <p>A URL string with path parameters filled in</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required path parameters are missing from kwargs</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; build_url_from_path(\"/users/{user_id}\", {\"user_id\": 123})\n\"/users/123\"\n</code></pre> <pre><code>&gt;&gt;&gt; build_url_from_path(\"/api/v{version}/users/{user_id}\", {\"version\": 1, \"user_id\": 123})\n\"/api/v1/users/123\"\n</code></pre> <pre><code>&gt;&gt;&gt; build_url_from_path(\"/files/{path:path}\", {\"path\": \"docs/readme.txt\"})\n\"/files/docs/readme.txt\"\n</code></pre> Source code in <code>serv/routing/generation.py</code> <pre><code>def build_url_from_path(path: str, kwargs: dict[str, Any]) -&gt; str:\n    \"\"\"Build a URL by substituting path parameters from kwargs.\n\n    Args:\n        path: The path pattern with parameter placeholders (e.g., \"/users/{user_id}\")\n        kwargs: Dictionary containing parameter values\n\n    Returns:\n        A URL string with path parameters filled in\n\n    Raises:\n        ValueError: If required path parameters are missing from kwargs\n\n    Examples:\n        &gt;&gt;&gt; build_url_from_path(\"/users/{user_id}\", {\"user_id\": 123})\n        \"/users/123\"\n\n        &gt;&gt;&gt; build_url_from_path(\"/api/v{version}/users/{user_id}\", {\"version\": 1, \"user_id\": 123})\n        \"/api/v1/users/123\"\n\n        &gt;&gt;&gt; build_url_from_path(\"/files/{path:path}\", {\"path\": \"docs/readme.txt\"})\n        \"/files/docs/readme.txt\"\n    \"\"\"\n    parts = path.split(\"/\")\n    result_parts = []\n\n    for part in parts:\n        if part.startswith(\"{\") and part.endswith(\"}\"):\n            param_name = part[1:-1]\n            # Handle typed parameters like {user_id:int}\n            if \":\" in param_name:\n                param_name = param_name.split(\":\")[0]\n            if param_name not in kwargs:\n                raise ValueError(f\"Missing required path parameter: {param_name}\")\n            result_parts.append(str(kwargs[param_name]))\n        else:\n            result_parts.append(part)\n\n    return \"/\" + \"/\".join(p for p in result_parts if p)\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.match_path","title":"match_path","text":"<pre><code>match_path(\n    request_path: str, path_pattern: str\n) -&gt; dict[str, Any] | None\n</code></pre> <p>Performs path matching against a pattern.</p> <p>Supports exact matches and path parameters with optional type hints. Supported types: {param}, {param:int}, {param:path}</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The incoming request path to match</p> required <code>path_pattern</code> <code>str</code> <p>The route pattern to match against</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dict of path parameters if matched, else None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; match_path(\"/users/123\", \"/users/{user_id:int}\")\n{\"user_id\": 123}\n</code></pre> <pre><code>&gt;&gt;&gt; match_path(\"/files/docs/readme.txt\", \"/files/{path:path}\")\n{\"path\": \"docs/readme.txt\"}\n</code></pre> <pre><code>&gt;&gt;&gt; match_path(\"/api/v1/users\", \"/api/v{version:int}/users\")\n{\"version\": 1}\n</code></pre> Source code in <code>serv/routing/patterns.py</code> <pre><code>def match_path(request_path: str, path_pattern: str) -&gt; dict[str, Any] | None:\n    \"\"\"Performs path matching against a pattern.\n\n    Supports exact matches and path parameters with optional type hints.\n    Supported types: {param}, {param:int}, {param:path}\n\n    Args:\n        request_path: The incoming request path to match\n        path_pattern: The route pattern to match against\n\n    Returns:\n        A dict of path parameters if matched, else None.\n\n    Examples:\n        &gt;&gt;&gt; match_path(\"/users/123\", \"/users/{user_id:int}\")\n        {\"user_id\": 123}\n\n        &gt;&gt;&gt; match_path(\"/files/docs/readme.txt\", \"/files/{path:path}\")\n        {\"path\": \"docs/readme.txt\"}\n\n        &gt;&gt;&gt; match_path(\"/api/v1/users\", \"/api/v{version:int}/users\")\n        {\"version\": 1}\n    \"\"\"\n    pattern_parts = path_pattern.strip(\"/\").split(\"/\")\n    request_parts = request_path.strip(\"/\").split(\"/\")\n\n    # Handle special case for path type parameters that can consume multiple segments\n    if any(\"{\" in part and \":path}\" in part for part in pattern_parts):\n        return match_path_with_path_type(request_path, path_pattern)\n\n    if len(pattern_parts) != len(request_parts):\n        return None\n\n    params = {}\n    for p_part, r_part in zip(pattern_parts, request_parts, strict=False):\n        if \"{\" in p_part and \"}\" in p_part:\n            # Handle parameters that might be embedded in text (like \"v{version:int}\")\n            result = match_segment_with_params(p_part, r_part)\n            if result is None:\n                return None\n            params.update(result)\n        elif p_part != r_part:\n            return None\n\n    return params\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.resolve_http_route","title":"resolve_http_route","text":"<pre><code>resolve_http_route(\n    request_path: str,\n    request_method: str,\n    mounted_routers: list[tuple[str, Router]],\n    sub_routers: list[Router],\n    routes: list[\n        tuple[\n            str, list[str] | None, Callable, dict[str, Any]\n        ]\n    ],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[\n        [str, str], dict[str, Any] | None\n    ],\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Resolve an HTTP route for the given path and method.</p> <p>This function implements the complete route resolution algorithm, checking mounted routers, sub-routers, and direct routes in the correct order.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The path of the incoming request</p> required <code>request_method</code> <code>str</code> <p>The HTTP method of the incoming request</p> required <code>mounted_routers</code> <code>list[tuple[str, Router]]</code> <p>List of (mount_path, router) tuples</p> required <code>sub_routers</code> <code>list[Router]</code> <p>List of sub-routers to check</p> required <code>routes</code> <code>list[tuple[str, list[str] | None, Callable, dict[str, Any]]]</code> <p>List of route tuples (path, methods, handler, settings)</p> required <code>router_settings</code> <code>dict[str, Any]</code> <p>Router-level settings to merge</p> required <code>match_path_func</code> <code>Callable[[str, str], dict[str, Any] | None]</code> <p>Function to perform path pattern matching</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>None if no route matches the path (results in a 404).</p> <p>Raises:</p> Type Description <code>HTTPMethodNotAllowedException</code> <p>If one or more routes match the path but not the method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler, params, settings = resolve_http_route(\n...     \"/users/123\", \"GET\", [], [], \n...     [(\"/users/{id}\", [\"GET\"], my_handler, {})],\n...     {}, match_path\n... )\n&gt;&gt;&gt; if handler:\n...     # Route found, call handler with params\n...     await handler(**params)\n</code></pre> Source code in <code>serv/routing/resolvers.py</code> <pre><code>def resolve_http_route(\n    request_path: str,\n    request_method: str,\n    mounted_routers: list[tuple[str, \"Router\"]],\n    sub_routers: list[\"Router\"], \n    routes: list[tuple[str, list[str] | None, Callable, dict[str, Any]]],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[[str, str], dict[str, Any] | None]\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Resolve an HTTP route for the given path and method.\n\n    This function implements the complete route resolution algorithm, checking\n    mounted routers, sub-routers, and direct routes in the correct order.\n\n    Args:\n        request_path: The path of the incoming request\n        request_method: The HTTP method of the incoming request\n        mounted_routers: List of (mount_path, router) tuples\n        sub_routers: List of sub-routers to check\n        routes: List of route tuples (path, methods, handler, settings)\n        router_settings: Router-level settings to merge\n        match_path_func: Function to perform path pattern matching\n\n    Returns:\n        A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.\n        None if no route matches the path (results in a 404).\n\n    Raises:\n        HTTPMethodNotAllowedException: If one or more routes match the path but not the method.\n\n    Examples:\n        &gt;&gt;&gt; handler, params, settings = resolve_http_route(\n        ...     \"/users/123\", \"GET\", [], [], \n        ...     [(\"/users/{id}\", [\"GET\"], my_handler, {})],\n        ...     {}, match_path\n        ... )\n        &gt;&gt;&gt; if handler:\n        ...     # Route found, call handler with params\n        ...     await handler(**params)\n    \"\"\"\n    collected_allowed_methods: set[str] = set()\n    found_path_match_but_not_method = False\n\n    # 1. Check mounted routers first\n    for mount_path, mounted_router in mounted_routers:\n        if request_path.startswith(mount_path):\n            # Strip the mount path prefix for the mounted router\n            sub_path = request_path[len(mount_path) :]\n            if not sub_path:\n                sub_path = \"/\"\n            elif not sub_path.startswith(\"/\"):\n                sub_path = \"/\" + sub_path\n\n            try:\n                resolved_in_mounted = mounted_router.resolve_route(\n                    sub_path, request_method\n                )\n                if resolved_in_mounted:\n                    handler, params, settings = resolved_in_mounted\n                    # Merge router settings with any more specific settings\n                    merged_settings = {\n                        **router_settings,\n                        **mounted_router._settings,\n                        **settings,\n                    }\n                    return handler, params, merged_settings\n            except HTTPMethodNotAllowedException as e:\n                # Mounted router matched the path but not the method\n                collected_allowed_methods.update(e.allowed_methods)\n                found_path_match_but_not_method = True\n            except HTTPNotFoundException:\n                # Mounted router did not find the path. Continue search.\n                pass\n\n    # 2. Check sub-routers in reverse order of addition (LIFO for matching)\n    for sub_router in reversed(sub_routers):\n        try:\n            resolved_in_sub = sub_router.resolve_route(request_path, request_method)\n            if resolved_in_sub:\n                handler, params, settings = resolved_in_sub\n                # Merge router settings with any more specific settings\n                merged_settings = {\n                    **router_settings,\n                    **sub_router._settings,\n                    **settings,\n                }\n                return handler, params, merged_settings\n        except HTTPMethodNotAllowedException as e:\n            # Sub-router matched the path but not the method.\n            # Collect its allowed methods and mark that a path match occurred.\n            collected_allowed_methods.update(e.allowed_methods)\n            found_path_match_but_not_method = True\n            # Continue searching other sub-routers or parent's direct routes.\n        except HTTPNotFoundException:\n            # Sub-router did not find the path at all. Continue search.\n            pass\n\n    # 3. Check own routes\n    for (\n        path_pattern,\n        route_specific_methods,\n        handler_callable,\n        route_settings,\n    ) in routes:\n        match_info = match_path_func(request_path, path_pattern)\n        if match_info is not None:  # Path matches\n            found_path_match_but_not_method = (\n                True  # Mark that we at least matched the path\n            )\n            if (\n                route_specific_methods is None\n                or request_method.upper() in route_specific_methods\n            ):\n                # Path and method match\n                # Merge router settings with route settings\n                merged_settings = {**router_settings, **route_settings}\n                return handler_callable, match_info, merged_settings\n            else:\n                # Path matches, but method is not allowed for this specific route.\n                # Collect allowed methods.\n                if route_specific_methods:\n                    collected_allowed_methods.update(route_specific_methods)\n\n    # 4. After checking all mounted routers, sub-routers and own routes:\n    if found_path_match_but_not_method and collected_allowed_methods:\n        # We found one or more path matches, but no method matches for that path.\n        # And we have a list of methods that *would* have been allowed.\n        raise HTTPMethodNotAllowedException(\n            f\"Method {request_method} not allowed for {request_path}\",\n            allowed_methods=list(collected_allowed_methods),\n        )\n\n    # If no path match was found at all, or if path matched but no methods were ever defined for it\n    # (e.g. route_specific_methods was None and it wasn't a match, which is unlikely with current logic\n    # but covering bases if collected_allowed_methods is empty despite found_path_match_but_not_method)\n    if found_path_match_but_not_method and not collected_allowed_methods:\n        # This case implies a path was matched by a route that allows ALL methods (None),\n        # but the request_method somehow didn't trigger the \"return handler_callable, match_info\"\n        # This shouldn't happen if request_method.upper() is in route_specific_methods when it's None.\n        # For safety, if we matched a path but have no specific allowed methods to suggest,\n        # it's still a method not allowed situation, but without specific 'Allow' header.\n        # However, current logic means if route_specific_methods is None, it's an immediate match.\n        # This path should ideally not be hit frequently.\n        # To be safe, we will treat it as a 404 if no specific methods were collected.\n        pass\n\n    # No route matched the path at all, or a path was matched but it didn't lead to a 405 (e.g. ill-defined route).\n    return None\n</code></pre>"},{"location":"reference/serv/routing/#serv.routing.resolve_websocket_route","title":"resolve_websocket_route","text":"<pre><code>resolve_websocket_route(\n    request_path: str,\n    mounted_routers: list[tuple[str, Router]],\n    sub_routers: list[Router],\n    websocket_routes: list[\n        tuple[str, Callable, dict[str, Any]]\n    ],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[\n        [str, str], dict[str, Any] | None\n    ],\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Resolve a WebSocket route for the given path.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The WebSocket request path to match against registered routes</p> required <code>mounted_routers</code> <code>list[tuple[str, Router]]</code> <p>List of (mount_path, router) tuples</p> required <code>sub_routers</code> <code>list[Router]</code> <p>List of sub-routers to check</p> required <code>websocket_routes</code> <code>list[tuple[str, Callable, dict[str, Any]]]</code> <p>List of WebSocket route tuples (path, handler, settings)</p> required <code>router_settings</code> <code>dict[str, Any]</code> <p>Router-level settings to merge</p> required <code>match_path_func</code> <code>Callable[[str, str], dict[str, Any] | None]</code> <p>Function to perform path pattern matching</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_params, route_settings) if a matching</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>WebSocket route is found, None otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler, params, settings = resolve_websocket_route(\n...     \"/ws/user/123\", [], [],\n...     [(\"/ws/user/{id}\", ws_handler, {})],\n...     {}, match_path\n... )\n&gt;&gt;&gt; if handler:\n...     # Handle WebSocket connection\n...     await handler(websocket, **params)\n</code></pre> Source code in <code>serv/routing/resolvers.py</code> <pre><code>def resolve_websocket_route(\n    request_path: str,\n    mounted_routers: list[tuple[str, \"Router\"]],\n    sub_routers: list[\"Router\"],\n    websocket_routes: list[tuple[str, Callable, dict[str, Any]]],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[[str, str], dict[str, Any] | None]\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Resolve a WebSocket route for the given path.\n\n    Args:\n        request_path: The WebSocket request path to match against registered routes\n        mounted_routers: List of (mount_path, router) tuples\n        sub_routers: List of sub-routers to check\n        websocket_routes: List of WebSocket route tuples (path, handler, settings)\n        router_settings: Router-level settings to merge\n        match_path_func: Function to perform path pattern matching\n\n    Returns:\n        A tuple of (handler_callable, path_params, route_settings) if a matching\n        WebSocket route is found, None otherwise.\n\n    Examples:\n        &gt;&gt;&gt; handler, params, settings = resolve_websocket_route(\n        ...     \"/ws/user/123\", [], [],\n        ...     [(\"/ws/user/{id}\", ws_handler, {})],\n        ...     {}, match_path\n        ... )\n        &gt;&gt;&gt; if handler:\n        ...     # Handle WebSocket connection\n        ...     await handler(websocket, **params)\n    \"\"\"\n    # First check sub-routers (they take precedence)\n    for sub_router in reversed(sub_routers):\n        result = sub_router.resolve_websocket(request_path)\n        if result:\n            return result\n\n    # Check mounted routers\n    for mount_path, mounted_router in mounted_routers:\n        if request_path.startswith(mount_path):\n            # Remove the mount path prefix before checking the mounted router\n            relative_path = request_path[len(mount_path) :] or \"/\"\n            result = mounted_router.resolve_websocket(relative_path)\n            if result:\n                return result\n\n    # Check our own WebSocket routes\n    for path_pattern, handler, settings in websocket_routes:\n        path_params = match_path_func(request_path, path_pattern)\n        if path_params is not None:\n            # Merge router-level settings with route-specific settings\n            merged_settings = {**router_settings, **settings}\n            return handler, path_params, merged_settings\n\n    return None\n</code></pre>"},{"location":"reference/serv/routing/decorators/","title":"decorators","text":""},{"location":"reference/serv/routing/decorators/#serv.routing.decorators","title":"serv.routing.decorators","text":"<p>Handler method decorators for Serv routing.</p> <p>This module provides the decorator system for marking route handler methods with HTTP methods, enabling the Route class to automatically discover and register appropriate handlers for incoming requests.</p>"},{"location":"reference/serv/routing/generation/","title":"generation","text":""},{"location":"reference/serv/routing/generation/#serv.routing.generation","title":"serv.routing.generation","text":"<p>URL generation utilities for Serv routing.</p> <p>This module provides functions for building URLs from route handlers and path patterns, enabling reverse URL generation for registered routes.</p>"},{"location":"reference/serv/routing/generation/#serv.routing.generation.build_url_from_path","title":"build_url_from_path","text":"<pre><code>build_url_from_path(\n    path: str, kwargs: dict[str, Any]\n) -&gt; str\n</code></pre> <p>Build a URL by substituting path parameters from kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern with parameter placeholders (e.g., \"/users/{user_id}\")</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Dictionary containing parameter values</p> required <p>Returns:</p> Type Description <code>str</code> <p>A URL string with path parameters filled in</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required path parameters are missing from kwargs</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; build_url_from_path(\"/users/{user_id}\", {\"user_id\": 123})\n\"/users/123\"\n</code></pre> <pre><code>&gt;&gt;&gt; build_url_from_path(\"/api/v{version}/users/{user_id}\", {\"version\": 1, \"user_id\": 123})\n\"/api/v1/users/123\"\n</code></pre> <pre><code>&gt;&gt;&gt; build_url_from_path(\"/files/{path:path}\", {\"path\": \"docs/readme.txt\"})\n\"/files/docs/readme.txt\"\n</code></pre> Source code in <code>serv/routing/generation.py</code> <pre><code>def build_url_from_path(path: str, kwargs: dict[str, Any]) -&gt; str:\n    \"\"\"Build a URL by substituting path parameters from kwargs.\n\n    Args:\n        path: The path pattern with parameter placeholders (e.g., \"/users/{user_id}\")\n        kwargs: Dictionary containing parameter values\n\n    Returns:\n        A URL string with path parameters filled in\n\n    Raises:\n        ValueError: If required path parameters are missing from kwargs\n\n    Examples:\n        &gt;&gt;&gt; build_url_from_path(\"/users/{user_id}\", {\"user_id\": 123})\n        \"/users/123\"\n\n        &gt;&gt;&gt; build_url_from_path(\"/api/v{version}/users/{user_id}\", {\"version\": 1, \"user_id\": 123})\n        \"/api/v1/users/123\"\n\n        &gt;&gt;&gt; build_url_from_path(\"/files/{path:path}\", {\"path\": \"docs/readme.txt\"})\n        \"/files/docs/readme.txt\"\n    \"\"\"\n    parts = path.split(\"/\")\n    result_parts = []\n\n    for part in parts:\n        if part.startswith(\"{\") and part.endswith(\"}\"):\n            param_name = part[1:-1]\n            # Handle typed parameters like {user_id:int}\n            if \":\" in param_name:\n                param_name = param_name.split(\":\")[0]\n            if param_name not in kwargs:\n                raise ValueError(f\"Missing required path parameter: {param_name}\")\n            result_parts.append(str(kwargs[param_name]))\n        else:\n            result_parts.append(part)\n\n    return \"/\" + \"/\".join(p for p in result_parts if p)\n</code></pre>"},{"location":"reference/serv/routing/generation/#serv.routing.generation.find_all_handler_paths","title":"find_all_handler_paths","text":"<pre><code>find_all_handler_paths(\n    routes_list: list[tuple], handler: Callable\n) -&gt; list[str]\n</code></pre> <p>Find all path patterns for a given handler in a routes list.</p> <p>Parameters:</p> Name Type Description Default <code>routes_list</code> <code>list[tuple]</code> <p>List of route tuples (path, methods, handler, settings)</p> required <code>handler</code> <code>Callable</code> <p>The handler function to find paths for</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of path patterns that map to the given handler</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; routes = [(\"/users\", [\"GET\"], my_handler, {}), (\"/people\", [\"GET\"], my_handler, {})]\n&gt;&gt;&gt; find_all_handler_paths(routes, my_handler)\n[\"/users\", \"/people\"]\n</code></pre> Source code in <code>serv/routing/generation.py</code> <pre><code>def find_all_handler_paths(routes_list: list[tuple], handler: Callable) -&gt; list[str]:\n    \"\"\"Find all path patterns for a given handler in a routes list.\n\n    Args:\n        routes_list: List of route tuples (path, methods, handler, settings)\n        handler: The handler function to find paths for\n\n    Returns:\n        List of path patterns that map to the given handler\n\n    Examples:\n        &gt;&gt;&gt; routes = [(\"/users\", [\"GET\"], my_handler, {}), (\"/people\", [\"GET\"], my_handler, {})]\n        &gt;&gt;&gt; find_all_handler_paths(routes, my_handler)\n        [\"/users\", \"/people\"]\n    \"\"\"\n    return [\n        path\n        for path, _, route_handler, _ in routes_list\n        if route_handler == handler\n    ]\n</code></pre>"},{"location":"reference/serv/routing/generation/#serv.routing.generation.find_best_matching_path","title":"find_best_matching_path","text":"<pre><code>find_best_matching_path(\n    paths: list[str], kwargs: dict[str, Any]\n) -&gt; str | None\n</code></pre> <p>Find the best matching path based on the provided kwargs.</p> <p>This method tries to find a path where all required parameters are provided in kwargs. It prioritizes: 1. Paths where all parameters are provided and the most parameters are used 2. The most recently added path (last in the list)</p> <p>If no path can be fully satisfied, it returns None.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list[str]</code> <p>List of path patterns to choose from</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Dictionary of available parameters</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Best matching path pattern or None if no match</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; paths = [\"/users/{id}\", \"/users/{id}/profile/{type}\"]\n&gt;&gt;&gt; find_best_matching_path(paths, {\"id\": 123, \"type\": \"public\"})\n\"/users/{id}/profile/{type}\"  # Uses more parameters\n</code></pre> <pre><code>&gt;&gt;&gt; find_best_matching_path(paths, {\"id\": 123})\n\"/users/{id}\"  # Only one with all required parameters\n</code></pre> Source code in <code>serv/routing/generation.py</code> <pre><code>def find_best_matching_path(paths: list[str], kwargs: dict[str, Any]) -&gt; str | None:\n    \"\"\"Find the best matching path based on the provided kwargs.\n\n    This method tries to find a path where all required parameters are provided in kwargs.\n    It prioritizes:\n    1. Paths where all parameters are provided and the most parameters are used\n    2. The most recently added path (last in the list)\n\n    If no path can be fully satisfied, it returns None.\n\n    Args:\n        paths: List of path patterns to choose from\n        kwargs: Dictionary of available parameters\n\n    Returns:\n        Best matching path pattern or None if no match\n\n    Examples:\n        &gt;&gt;&gt; paths = [\"/users/{id}\", \"/users/{id}/profile/{type}\"]\n        &gt;&gt;&gt; find_best_matching_path(paths, {\"id\": 123, \"type\": \"public\"})\n        \"/users/{id}/profile/{type}\"  # Uses more parameters\n\n        &gt;&gt;&gt; find_best_matching_path(paths, {\"id\": 123})\n        \"/users/{id}\"  # Only one with all required parameters\n    \"\"\"\n    valid_paths = []\n\n    for path in paths:\n        param_names = []\n        for part in path.split(\"/\"):\n            if part.startswith(\"{\") and part.endswith(\"}\"):\n                param_spec = part[1:-1]\n                # Handle typed parameters like {user_id:int}\n                if \":\" in param_spec:\n                    param_name = param_spec.split(\":\")[0]\n                else:\n                    param_name = param_spec\n                param_names.append(param_name)\n\n        # Check if all parameters for this path are provided\n        if all(param in kwargs for param in param_names):\n            # Score is based on how many parameters are used by this path\n            valid_paths.append((path, len(param_names)))\n\n    if not valid_paths:\n        return None\n\n    # Return the path with the most parameters (to use as many kwargs as possible)\n    valid_paths.sort(key=lambda x: x[1], reverse=True)\n    return valid_paths[0][0]\n</code></pre>"},{"location":"reference/serv/routing/generation/#serv.routing.generation.find_handler_path","title":"find_handler_path","text":"<pre><code>find_handler_path(\n    routes_list: list[tuple], handler: Callable\n) -&gt; str | None\n</code></pre> <p>Find the first path pattern for a given handler in a routes list.</p> <p>Parameters:</p> Name Type Description Default <code>routes_list</code> <code>list[tuple]</code> <p>List of route tuples (path, methods, handler, settings)</p> required <code>handler</code> <code>Callable</code> <p>The handler function to find a path for</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>First path pattern that maps to the given handler, or None if not found</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; routes = [(\"/users\", [\"GET\"], my_handler, {}), (\"/people\", [\"GET\"], other_handler, {})]\n&gt;&gt;&gt; find_handler_path(routes, my_handler)\n\"/users\"\n</code></pre> Source code in <code>serv/routing/generation.py</code> <pre><code>def find_handler_path(routes_list: list[tuple], handler: Callable) -&gt; str | None:\n    \"\"\"Find the first path pattern for a given handler in a routes list.\n\n    Args:\n        routes_list: List of route tuples (path, methods, handler, settings)\n        handler: The handler function to find a path for\n\n    Returns:\n        First path pattern that maps to the given handler, or None if not found\n\n    Examples:\n        &gt;&gt;&gt; routes = [(\"/users\", [\"GET\"], my_handler, {}), (\"/people\", [\"GET\"], other_handler, {})]\n        &gt;&gt;&gt; find_handler_path(routes, my_handler)\n        \"/users\"\n    \"\"\"\n    for path, _, route_handler, _ in routes_list:\n        if route_handler == handler:\n            return path\n    return None\n</code></pre>"},{"location":"reference/serv/routing/generation/#serv.routing.generation.url_for_function_handler","title":"url_for_function_handler","text":"<pre><code>url_for_function_handler(\n    routes_list: list[tuple],\n    mounted_routers: list[tuple],\n    sub_routers: list,\n    handler: Callable,\n    **kwargs,\n) -&gt; str\n</code></pre> <p>Build URL for a function handler.</p> <p>Parameters:</p> Name Type Description Default <code>routes_list</code> <code>list[tuple]</code> <p>List of route tuples (path, methods, handler, settings)</p> required <code>mounted_routers</code> <code>list[tuple]</code> <p>List of (mount_path, router) tuples for mounted routers</p> required <code>sub_routers</code> <code>list</code> <p>List of sub-routers to search</p> required <code>handler</code> <code>Callable</code> <p>Function handler to build URL for</p> required <code>**kwargs</code> <p>Path parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>URL string for the function handler</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If handler not found or required parameters missing</p> Source code in <code>serv/routing/generation.py</code> <pre><code>def url_for_function_handler(\n    routes_list: list[tuple],\n    mounted_routers: list[tuple],\n    sub_routers: list,\n    handler: Callable,\n    **kwargs\n) -&gt; str:\n    \"\"\"Build URL for a function handler.\n\n    Args:\n        routes_list: List of route tuples (path, methods, handler, settings)\n        mounted_routers: List of (mount_path, router) tuples for mounted routers\n        sub_routers: List of sub-routers to search\n        handler: Function handler to build URL for\n        **kwargs: Path parameters\n\n    Returns:\n        URL string for the function handler\n\n    Raises:\n        ValueError: If handler not found or required parameters missing\n    \"\"\"\n    # Try to find all paths for this handler\n    paths = find_all_handler_paths(routes_list, handler)\n    if not paths:\n        # If not found directly, check mounted routers\n        for mount_path, mounted_router in mounted_routers:\n            try:\n                sub_path = mounted_router.url_for(handler, **kwargs)\n                return f\"{mount_path}{sub_path}\"\n            except ValueError:\n                continue\n\n        # If not found in mounted routers, check sub-routers\n        for sub_router in sub_routers:\n            try:\n                return sub_router.url_for(handler, **kwargs)\n            except ValueError:\n                continue\n\n        raise ValueError(f\"Handler {handler.__name__} not found in any router\")\n\n    # Try to find the best path based on the provided kwargs\n    path = find_best_matching_path(paths, kwargs)\n    if not path:\n        # If no path can be fully satisfied, use the last registered path\n        path = paths[-1]\n\n    # Try to build the URL with the selected path\n    try:\n        return build_url_from_path(path, kwargs)\n    except ValueError as e:\n        # For function handlers, try other paths if available\n        if len(paths) &gt; 1:\n            for alt_path in reversed(paths):\n                if alt_path != path:\n                    try:\n                        return build_url_from_path(alt_path, kwargs)\n                    except ValueError:\n                        continue\n\n        # If we get here, no path could be satisfied with the provided kwargs\n        raise e\n</code></pre>"},{"location":"reference/serv/routing/generation/#serv.routing.generation.url_for_route_class","title":"url_for_route_class","text":"<pre><code>url_for_route_class(\n    route_class_paths: dict[type, list[str]],\n    mounted_routers: list[tuple],\n    sub_routers: list,\n    handler: type[Route],\n    **kwargs,\n) -&gt; str\n</code></pre> <p>Build URL for a Route class.</p> <p>Parameters:</p> Name Type Description Default <code>route_class_paths</code> <code>dict[type, list[str]]</code> <p>Dictionary mapping Route classes to their path patterns</p> required <code>mounted_routers</code> <code>list[tuple]</code> <p>List of (mount_path, router) tuples for mounted routers</p> required <code>sub_routers</code> <code>list</code> <p>List of sub-routers to search</p> required <code>handler</code> <code>type[Route]</code> <p>Route class to build URL for</p> required <code>**kwargs</code> <p>Path parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>URL string for the Route class</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If route class not found or required parameters missing</p> Source code in <code>serv/routing/generation.py</code> <pre><code>def url_for_route_class(\n    route_class_paths: dict[type, list[str]],\n    mounted_routers: list[tuple],\n    sub_routers: list,\n    handler: type[\"routes.Route\"],\n    **kwargs\n) -&gt; str:\n    \"\"\"Build URL for a Route class.\n\n    Args:\n        route_class_paths: Dictionary mapping Route classes to their path patterns\n        mounted_routers: List of (mount_path, router) tuples for mounted routers\n        sub_routers: List of sub-routers to search\n        handler: Route class to build URL for\n        **kwargs: Path parameters\n\n    Returns:\n        URL string for the Route class\n\n    Raises:\n        ValueError: If route class not found or required parameters missing\n    \"\"\"\n    # Import routes at runtime to avoid circular dependency\n    import serv.routes as routes\n\n    if not (isinstance(handler, type) and issubclass(handler, routes.Route)):\n        raise ValueError(\"Handler must be a Route class\")\n\n    # Look for route class in the _route_class_paths dictionary\n    if handler in route_class_paths:\n        path_list = route_class_paths[handler]\n\n        # Find the best matching path based on provided kwargs\n        path = find_best_matching_path(path_list, kwargs)\n        if not path:\n            # If no path can be fully satisfied with the provided kwargs,\n            # use the most recently added path (last in the list)\n            path = path_list[-1]\n\n        # Try to build the URL with the selected path\n        # If the required parameters aren't in kwargs, we'll need to try other paths\n        try:\n            return build_url_from_path(path, kwargs)\n        except ValueError:\n            # For Route classes, try other paths if available\n            for alt_path in reversed(path_list):\n                if alt_path != path:\n                    try:\n                        return build_url_from_path(alt_path, kwargs)\n                    except ValueError:\n                        continue\n            # Re-raise the original error if no path worked\n            raise\n    else:\n        # If not found directly, check mounted routers\n        for mount_path, mounted_router in mounted_routers:\n            try:\n                sub_path = mounted_router.url_for(handler, **kwargs)\n                return f\"{mount_path}{sub_path}\"\n            except ValueError:\n                continue\n\n        # Check sub-routers\n        for sub_router in sub_routers:\n            try:\n                return sub_router.url_for(handler, **kwargs)\n            except ValueError:\n                continue\n\n        raise ValueError(f\"Route class {handler.__name__} not found in any router\")\n</code></pre>"},{"location":"reference/serv/routing/handlers/","title":"handlers","text":""},{"location":"reference/serv/routing/handlers/#serv.routing.handlers","title":"serv.routing.handlers","text":"<p>Route handler base class and handler management for Serv routing.</p> <p>This module provides the Route base class and related utilities for creating HTTP route handlers with automatic method discovery, parameter injection, response type inference, and error handling.</p>"},{"location":"reference/serv/routing/handlers/#serv.routing.handlers.Route","title":"Route","text":"<p>Base class for creating HTTP route handlers in Serv applications.</p> <p>Route classes provide a structured way to handle HTTP requests by defining methods that correspond to HTTP methods (GET, POST, etc.) and form handlers. They support automatic request parsing, response type annotations, error handling, and dependency injection.</p> <p>The Route class automatically discovers handler methods based on their naming patterns and signatures: - Methods named <code>handle_&lt;method&gt;</code> become HTTP method handlers (e.g., <code>handle_get</code>, <code>handle_post</code>) - Methods with Form subclass parameters become form handlers - Methods with Exception parameters become error handlers - Return type annotations determine response wrapper classes - Handler selection is based on signature matching with request data</p> <p>Examples:</p> <p>Basic route with HTTP method handlers:</p> <pre><code>from serv.routes import Route\nfrom serv.responses import JsonResponse, TextResponse\nfrom serv.injectors import Query, Header\nfrom typing import Annotated\n\nclass UserRoute(Route):\n    async def handle_get(self, user_id: Annotated[str, Query(\"id\")]) -&gt; Annotated[dict, JsonResponse]:\n        return {\"id\": user_id, \"name\": \"John Doe\"}\n\n    async def handle_post(self, data: dict) -&gt; Annotated[str, TextResponse]:\n        # Create user logic here\n        return \"User created successfully\"\n</code></pre> <p>Route with multiple GET handlers based on parameters:</p> <pre><code>class ProductRoute(Route):\n    # Handler for requests with 'id' query parameter\n    async def handle_get(self, product_id: Annotated[str, Query(\"id\")]) -&gt; Annotated[dict, JsonResponse]:\n        return {\"id\": product_id, \"name\": \"Product Name\"}\n\n    # Handler for requests with 'category' query parameter\n    async def handle_get_by_category(self, category: Annotated[str, Query(\"category\")]) -&gt; Annotated[list, JsonResponse]:\n        return [{\"id\": 1, \"name\": \"Product 1\"}, {\"id\": 2, \"name\": \"Product 2\"}]\n\n    # Handler for requests with no specific parameters (fallback)\n    async def handle_get_all(self) -&gt; Annotated[list, JsonResponse]:\n        return [{\"id\": 1, \"name\": \"All Products\"}]\n</code></pre> <p>Route with form handling:</p> <pre><code>from serv.routes import Route, Form\nfrom serv.responses import HtmlResponse\nfrom typing import Annotated\n\nclass ContactForm(Form):\n    name: str\n    email: str\n    message: str\n\nclass ContactRoute(Route):\n    async def handle_get(self) -&gt; Annotated[str, HtmlResponse]:\n        return '''\n        &lt;form method=\"post\"&gt;\n            &lt;input name=\"name\" placeholder=\"Name\" required&gt;\n            &lt;input name=\"email\" type=\"email\" placeholder=\"Email\" required&gt;\n            &lt;textarea name=\"message\" placeholder=\"Message\" required&gt;&lt;/textarea&gt;\n            &lt;button type=\"submit\"&gt;Send&lt;/button&gt;\n        &lt;/form&gt;\n        '''\n\n    async def handle_contact_form(self, form: ContactForm) -&gt; Annotated[str, HtmlResponse]:\n        # Process the form submission\n        await self.send_email(form.email, form.name, form.message)\n        return \"&lt;h1&gt;Thank you! Your message has been sent.&lt;/h1&gt;\"\n</code></pre> <p>Route with header and cookie injection:</p> <pre><code>from serv.injectors import Header, Cookie\n\nclass AuthRoute(Route):\n    async def handle_get(\n        self,\n        auth_token: Annotated[str, Header(\"Authorization\")],\n        session_id: Annotated[str, Cookie(\"session_id\")]\n    ) -&gt; Annotated[dict, JsonResponse]:\n        # Validate token and session\n        return {\"authenticated\": True, \"user\": \"john_doe\"}\n</code></pre> Note <p>Route classes are automatically instantiated by the router when a matching request is received. Handler methods are selected based on the best match between the request data and the method's parameter signature. Methods with more specific parameter requirements will be preferred over generic handlers.</p>"},{"location":"reference/serv/routing/patterns/","title":"patterns","text":""},{"location":"reference/serv/routing/patterns/#serv.routing.patterns","title":"serv.routing.patterns","text":"<p>URL pattern matching and parameter extraction for Serv routing.</p> <p>This module provides the core URL pattern matching functionality, supporting: - Exact path matching - Path parameters with type hints ({param}, {param:int}, {param:path}) - Embedded parameters in path segments (e.g., \"v{version:int}\") - Multi-segment path parameters that consume remaining URL parts</p>"},{"location":"reference/serv/routing/patterns/#serv.routing.patterns.match_path","title":"match_path","text":"<pre><code>match_path(\n    request_path: str, path_pattern: str\n) -&gt; dict[str, Any] | None\n</code></pre> <p>Performs path matching against a pattern.</p> <p>Supports exact matches and path parameters with optional type hints. Supported types: {param}, {param:int}, {param:path}</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The incoming request path to match</p> required <code>path_pattern</code> <code>str</code> <p>The route pattern to match against</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>A dict of path parameters if matched, else None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; match_path(\"/users/123\", \"/users/{user_id:int}\")\n{\"user_id\": 123}\n</code></pre> <pre><code>&gt;&gt;&gt; match_path(\"/files/docs/readme.txt\", \"/files/{path:path}\")\n{\"path\": \"docs/readme.txt\"}\n</code></pre> <pre><code>&gt;&gt;&gt; match_path(\"/api/v1/users\", \"/api/v{version:int}/users\")\n{\"version\": 1}\n</code></pre> Source code in <code>serv/routing/patterns.py</code> <pre><code>def match_path(request_path: str, path_pattern: str) -&gt; dict[str, Any] | None:\n    \"\"\"Performs path matching against a pattern.\n\n    Supports exact matches and path parameters with optional type hints.\n    Supported types: {param}, {param:int}, {param:path}\n\n    Args:\n        request_path: The incoming request path to match\n        path_pattern: The route pattern to match against\n\n    Returns:\n        A dict of path parameters if matched, else None.\n\n    Examples:\n        &gt;&gt;&gt; match_path(\"/users/123\", \"/users/{user_id:int}\")\n        {\"user_id\": 123}\n\n        &gt;&gt;&gt; match_path(\"/files/docs/readme.txt\", \"/files/{path:path}\")\n        {\"path\": \"docs/readme.txt\"}\n\n        &gt;&gt;&gt; match_path(\"/api/v1/users\", \"/api/v{version:int}/users\")\n        {\"version\": 1}\n    \"\"\"\n    pattern_parts = path_pattern.strip(\"/\").split(\"/\")\n    request_parts = request_path.strip(\"/\").split(\"/\")\n\n    # Handle special case for path type parameters that can consume multiple segments\n    if any(\"{\" in part and \":path}\" in part for part in pattern_parts):\n        return match_path_with_path_type(request_path, path_pattern)\n\n    if len(pattern_parts) != len(request_parts):\n        return None\n\n    params = {}\n    for p_part, r_part in zip(pattern_parts, request_parts, strict=False):\n        if \"{\" in p_part and \"}\" in p_part:\n            # Handle parameters that might be embedded in text (like \"v{version:int}\")\n            result = match_segment_with_params(p_part, r_part)\n            if result is None:\n                return None\n            params.update(result)\n        elif p_part != r_part:\n            return None\n\n    return params\n</code></pre>"},{"location":"reference/serv/routing/patterns/#serv.routing.patterns.match_path_with_path_type","title":"match_path_with_path_type","text":"<pre><code>match_path_with_path_type(\n    request_path: str, path_pattern: str\n) -&gt; dict[str, Any] | None\n</code></pre> <p>Handle path patterns with path type parameters that can consume multiple segments.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The incoming request path</p> required <code>path_pattern</code> <code>str</code> <p>Pattern containing {param:path} parameters</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dict of extracted parameters or None if no match</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; match_path_with_path_type(\"/files/docs/readme.txt\", \"/files/{path:path}\")\n{\"path\": \"docs/readme.txt\"}\n</code></pre> <pre><code>&gt;&gt;&gt; match_path_with_path_type(\"/api/v1/files/docs/readme.txt\", \"/api/v{version:int}/files/{path:path}\")\n{\"version\": 1, \"path\": \"docs/readme.txt\"}\n</code></pre> Source code in <code>serv/routing/patterns.py</code> <pre><code>def match_path_with_path_type(\n    request_path: str, path_pattern: str\n) -&gt; dict[str, Any] | None:\n    \"\"\"Handle path patterns with path type parameters that can consume multiple segments.\n\n    Args:\n        request_path: The incoming request path\n        path_pattern: Pattern containing {param:path} parameters\n\n    Returns:\n        Dict of extracted parameters or None if no match\n\n    Examples:\n        &gt;&gt;&gt; match_path_with_path_type(\"/files/docs/readme.txt\", \"/files/{path:path}\")\n        {\"path\": \"docs/readme.txt\"}\n\n        &gt;&gt;&gt; match_path_with_path_type(\"/api/v1/files/docs/readme.txt\", \"/api/v{version:int}/files/{path:path}\")\n        {\"version\": 1, \"path\": \"docs/readme.txt\"}\n    \"\"\"\n    pattern_parts = path_pattern.strip(\"/\").split(\"/\")\n    request_parts = request_path.strip(\"/\").split(\"/\")\n\n    params = {}\n    pattern_idx = 0\n    request_idx = 0\n\n    while pattern_idx &lt; len(pattern_parts) and request_idx &lt; len(request_parts):\n        p_part = pattern_parts[pattern_idx]\n\n        if p_part.startswith(\"{\") and p_part.endswith(\"}\"):\n            param_spec = p_part[1:-1]\n            if \":\" in param_spec:\n                param_name, param_type = param_spec.split(\":\", 1)\n                if param_type == \"path\":\n                    # Path type consumes remaining segments\n                    remaining_pattern = len(pattern_parts) - pattern_idx - 1\n                    if remaining_pattern == 0:\n                        # This is the last part, consume all remaining request parts\n                        path_value = \"/\".join(request_parts[request_idx:])\n                        params[param_name] = path_value\n                        return params\n                    else:\n                        # Calculate how many segments to consume\n                        remaining_request = len(request_parts) - request_idx\n                        segments_to_consume = remaining_request - remaining_pattern\n                        if segments_to_consume &lt; 1:\n                            return None\n                        path_value = \"/\".join(\n                            request_parts[\n                                request_idx : request_idx + segments_to_consume\n                            ]\n                        )\n                        params[param_name] = path_value\n                        request_idx += segments_to_consume\n                elif param_type == \"int\":\n                    try:\n                        params[param_name] = int(request_parts[request_idx])\n                    except ValueError:\n                        return None\n                    request_idx += 1\n                else:\n                    params[param_name] = request_parts[request_idx]\n                    request_idx += 1\n            else:\n                params[param_spec] = request_parts[request_idx]\n                request_idx += 1\n        else:\n            # Exact match required\n            if p_part != request_parts[request_idx]:\n                return None\n            request_idx += 1\n\n        pattern_idx += 1\n\n    # Check if we consumed all parts\n    if pattern_idx == len(pattern_parts) and request_idx == len(request_parts):\n        return params\n\n    return None\n</code></pre>"},{"location":"reference/serv/routing/patterns/#serv.routing.patterns.match_segment_with_params","title":"match_segment_with_params","text":"<pre><code>match_segment_with_params(\n    pattern_segment: str, request_segment: str\n) -&gt; dict[str, Any] | None\n</code></pre> <p>Match a single path segment that may contain embedded parameters.</p> <p>Parameters:</p> Name Type Description Default <code>pattern_segment</code> <code>str</code> <p>Pattern segment like \"v{version:int}\" or \"{user_id}\"</p> required <code>request_segment</code> <code>str</code> <p>Actual request segment like \"v1\" or \"123\"</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dict of extracted parameters or None if no match</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; match_segment_with_params(\"v{version:int}\", \"v2\")\n{\"version\": 2}\n</code></pre> <pre><code>&gt;&gt;&gt; match_segment_with_params(\"{user_id:int}\", \"123\")\n{\"user_id\": 123}\n</code></pre> Source code in <code>serv/routing/patterns.py</code> <pre><code>def match_segment_with_params(\n    pattern_segment: str, request_segment: str\n) -&gt; dict[str, Any] | None:\n    \"\"\"Match a single path segment that may contain embedded parameters.\n\n    Args:\n        pattern_segment: Pattern segment like \"v{version:int}\" or \"{user_id}\"\n        request_segment: Actual request segment like \"v1\" or \"123\"\n\n    Returns:\n        Dict of extracted parameters or None if no match\n\n    Examples:\n        &gt;&gt;&gt; match_segment_with_params(\"v{version:int}\", \"v2\")\n        {\"version\": 2}\n\n        &gt;&gt;&gt; match_segment_with_params(\"{user_id:int}\", \"123\")\n        {\"user_id\": 123}\n    \"\"\"\n    # Find all parameters in the pattern segment\n    param_pattern = r\"\\{([^}]+)\\}\"\n    params = {}\n\n    # Build a regex pattern by replacing parameter placeholders\n    regex_pattern = pattern_segment\n    param_matches = re.finditer(param_pattern, pattern_segment)\n\n    for match in reversed(list(param_matches)):  # Reverse to maintain indices\n        param_spec = match.group(1)\n        if \":\" in param_spec:\n            param_name, param_type = param_spec.split(\":\", 1)\n            if param_type == \"int\":\n                # Replace with regex for integers\n                regex_pattern = (\n                    regex_pattern[: match.start()]\n                    + r\"(\\d+)\"\n                    + regex_pattern[match.end() :]\n                )\n            elif param_type == \"path\":\n                # For path type in a segment, match everything\n                regex_pattern = (\n                    regex_pattern[: match.start()]\n                    + r\"(.+)\"\n                    + regex_pattern[match.end() :]\n                )\n            else:\n                # Default to matching non-slash characters\n                regex_pattern = (\n                    regex_pattern[: match.start()]\n                    + r\"([^/]+)\"\n                    + regex_pattern[match.end() :]\n                )\n        else:\n            # Simple parameter, match non-slash characters\n            regex_pattern = (\n                regex_pattern[: match.start()]\n                + r\"([^/]+)\"\n                + regex_pattern[match.end() :]\n            )\n\n    # Escape any remaining regex special characters in the pattern\n    regex_pattern = regex_pattern.replace(\".\", r\"\\.\")\n    regex_pattern = \"^\" + regex_pattern + \"$\"\n\n    # Try to match the request segment\n    match = re.match(regex_pattern, request_segment)\n    if not match:\n        return None\n\n    # Extract parameter values\n    param_matches = list(re.finditer(param_pattern, pattern_segment))\n    for i, param_match in enumerate(param_matches):\n        param_spec = param_match.group(1)\n        value = match.group(i + 1)\n\n        if \":\" in param_spec:\n            param_name, param_type = param_spec.split(\":\", 1)\n            try:\n                if param_type == \"int\":\n                    params[param_name] = int(value)\n                elif param_type == \"path\":\n                    params[param_name] = value\n                else:\n                    params[param_name] = value\n            except ValueError:\n                return None\n        else:\n            params[param_spec] = value\n\n    return params\n</code></pre>"},{"location":"reference/serv/routing/resolvers/","title":"resolvers","text":""},{"location":"reference/serv/routing/resolvers/#serv.routing.resolvers","title":"serv.routing.resolvers","text":"<p>Route resolution logic for Serv routing.</p> <p>This module provides functions for resolving HTTP and WebSocket routes, handling path matching, method validation, and error scenarios (404/405).</p>"},{"location":"reference/serv/routing/resolvers/#serv.routing.resolvers.check_method_allowed","title":"check_method_allowed","text":"<pre><code>check_method_allowed(\n    path_pattern: str,\n    route_methods: list[str] | None,\n    request_method: str,\n) -&gt; bool\n</code></pre> <p>Check if a request method is allowed for a route.</p> <p>Parameters:</p> Name Type Description Default <code>path_pattern</code> <code>str</code> <p>The route path pattern</p> required <code>route_methods</code> <code>list[str] | None</code> <p>List of allowed methods for the route, or None for all methods</p> required <code>request_method</code> <code>str</code> <p>The request method to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the method is allowed, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; check_method_allowed(\"/users\", [\"GET\", \"POST\"], \"GET\")\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; check_method_allowed(\"/users\", [\"GET\", \"POST\"], \"DELETE\")\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; check_method_allowed(\"/users\", None, \"ANY_METHOD\")\nTrue  # None means all methods allowed\n</code></pre> Source code in <code>serv/routing/resolvers.py</code> <pre><code>def check_method_allowed(\n    path_pattern: str,\n    route_methods: list[str] | None,\n    request_method: str\n) -&gt; bool:\n    \"\"\"Check if a request method is allowed for a route.\n\n    Args:\n        path_pattern: The route path pattern\n        route_methods: List of allowed methods for the route, or None for all methods\n        request_method: The request method to check\n\n    Returns:\n        True if the method is allowed, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; check_method_allowed(\"/users\", [\"GET\", \"POST\"], \"GET\")\n        True\n\n        &gt;&gt;&gt; check_method_allowed(\"/users\", [\"GET\", \"POST\"], \"DELETE\")\n        False\n\n        &gt;&gt;&gt; check_method_allowed(\"/users\", None, \"ANY_METHOD\")\n        True  # None means all methods allowed\n    \"\"\"\n    if route_methods is None:\n        return True  # All methods allowed\n    return request_method.upper() in route_methods\n</code></pre>"},{"location":"reference/serv/routing/resolvers/#serv.routing.resolvers.collect_allowed_methods","title":"collect_allowed_methods","text":"<pre><code>collect_allowed_methods(\n    routes: list[\n        tuple[\n            str, list[str] | None, Callable, dict[str, Any]\n        ]\n    ],\n    request_path: str,\n    match_path_func: Callable[\n        [str, str], dict[str, Any] | None\n    ],\n) -&gt; set[str]\n</code></pre> <p>Collect all allowed methods for routes that match the given path.</p> <p>Parameters:</p> Name Type Description Default <code>routes</code> <code>list[tuple[str, list[str] | None, Callable, dict[str, Any]]]</code> <p>List of route tuples (path, methods, handler, settings)</p> required <code>request_path</code> <code>str</code> <p>The request path to check</p> required <code>match_path_func</code> <code>Callable[[str, str], dict[str, Any] | None]</code> <p>Function to perform path pattern matching</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Set of allowed HTTP methods for the path</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; routes = [\n...     (\"/users\", [\"GET\", \"POST\"], handler1, {}),\n...     (\"/users\", [\"PUT\"], handler2, {})\n... ]\n&gt;&gt;&gt; collect_allowed_methods(routes, \"/users\", match_path)\n{\"GET\", \"POST\", \"PUT\"}\n</code></pre> Source code in <code>serv/routing/resolvers.py</code> <pre><code>def collect_allowed_methods(\n    routes: list[tuple[str, list[str] | None, Callable, dict[str, Any]]],\n    request_path: str,\n    match_path_func: Callable[[str, str], dict[str, Any] | None]\n) -&gt; set[str]:\n    \"\"\"Collect all allowed methods for routes that match the given path.\n\n    Args:\n        routes: List of route tuples (path, methods, handler, settings)\n        request_path: The request path to check\n        match_path_func: Function to perform path pattern matching\n\n    Returns:\n        Set of allowed HTTP methods for the path\n\n    Examples:\n        &gt;&gt;&gt; routes = [\n        ...     (\"/users\", [\"GET\", \"POST\"], handler1, {}),\n        ...     (\"/users\", [\"PUT\"], handler2, {})\n        ... ]\n        &gt;&gt;&gt; collect_allowed_methods(routes, \"/users\", match_path)\n        {\"GET\", \"POST\", \"PUT\"}\n    \"\"\"\n    allowed_methods = set()\n\n    for path_pattern, route_methods, _, _ in routes:\n        if match_path_func(request_path, path_pattern) is not None:\n            if route_methods is not None:\n                allowed_methods.update(route_methods)\n\n    return allowed_methods\n</code></pre>"},{"location":"reference/serv/routing/resolvers/#serv.routing.resolvers.resolve_http_route","title":"resolve_http_route","text":"<pre><code>resolve_http_route(\n    request_path: str,\n    request_method: str,\n    mounted_routers: list[tuple[str, Router]],\n    sub_routers: list[Router],\n    routes: list[\n        tuple[\n            str, list[str] | None, Callable, dict[str, Any]\n        ]\n    ],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[\n        [str, str], dict[str, Any] | None\n    ],\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Resolve an HTTP route for the given path and method.</p> <p>This function implements the complete route resolution algorithm, checking mounted routers, sub-routers, and direct routes in the correct order.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The path of the incoming request</p> required <code>request_method</code> <code>str</code> <p>The HTTP method of the incoming request</p> required <code>mounted_routers</code> <code>list[tuple[str, Router]]</code> <p>List of (mount_path, router) tuples</p> required <code>sub_routers</code> <code>list[Router]</code> <p>List of sub-routers to check</p> required <code>routes</code> <code>list[tuple[str, list[str] | None, Callable, dict[str, Any]]]</code> <p>List of route tuples (path, methods, handler, settings)</p> required <code>router_settings</code> <code>dict[str, Any]</code> <p>Router-level settings to merge</p> required <code>match_path_func</code> <code>Callable[[str, str], dict[str, Any] | None]</code> <p>Function to perform path pattern matching</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>None if no route matches the path (results in a 404).</p> <p>Raises:</p> Type Description <code>HTTPMethodNotAllowedException</code> <p>If one or more routes match the path but not the method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler, params, settings = resolve_http_route(\n...     \"/users/123\", \"GET\", [], [], \n...     [(\"/users/{id}\", [\"GET\"], my_handler, {})],\n...     {}, match_path\n... )\n&gt;&gt;&gt; if handler:\n...     # Route found, call handler with params\n...     await handler(**params)\n</code></pre> Source code in <code>serv/routing/resolvers.py</code> <pre><code>def resolve_http_route(\n    request_path: str,\n    request_method: str,\n    mounted_routers: list[tuple[str, \"Router\"]],\n    sub_routers: list[\"Router\"], \n    routes: list[tuple[str, list[str] | None, Callable, dict[str, Any]]],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[[str, str], dict[str, Any] | None]\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Resolve an HTTP route for the given path and method.\n\n    This function implements the complete route resolution algorithm, checking\n    mounted routers, sub-routers, and direct routes in the correct order.\n\n    Args:\n        request_path: The path of the incoming request\n        request_method: The HTTP method of the incoming request\n        mounted_routers: List of (mount_path, router) tuples\n        sub_routers: List of sub-routers to check\n        routes: List of route tuples (path, methods, handler, settings)\n        router_settings: Router-level settings to merge\n        match_path_func: Function to perform path pattern matching\n\n    Returns:\n        A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.\n        None if no route matches the path (results in a 404).\n\n    Raises:\n        HTTPMethodNotAllowedException: If one or more routes match the path but not the method.\n\n    Examples:\n        &gt;&gt;&gt; handler, params, settings = resolve_http_route(\n        ...     \"/users/123\", \"GET\", [], [], \n        ...     [(\"/users/{id}\", [\"GET\"], my_handler, {})],\n        ...     {}, match_path\n        ... )\n        &gt;&gt;&gt; if handler:\n        ...     # Route found, call handler with params\n        ...     await handler(**params)\n    \"\"\"\n    collected_allowed_methods: set[str] = set()\n    found_path_match_but_not_method = False\n\n    # 1. Check mounted routers first\n    for mount_path, mounted_router in mounted_routers:\n        if request_path.startswith(mount_path):\n            # Strip the mount path prefix for the mounted router\n            sub_path = request_path[len(mount_path) :]\n            if not sub_path:\n                sub_path = \"/\"\n            elif not sub_path.startswith(\"/\"):\n                sub_path = \"/\" + sub_path\n\n            try:\n                resolved_in_mounted = mounted_router.resolve_route(\n                    sub_path, request_method\n                )\n                if resolved_in_mounted:\n                    handler, params, settings = resolved_in_mounted\n                    # Merge router settings with any more specific settings\n                    merged_settings = {\n                        **router_settings,\n                        **mounted_router._settings,\n                        **settings,\n                    }\n                    return handler, params, merged_settings\n            except HTTPMethodNotAllowedException as e:\n                # Mounted router matched the path but not the method\n                collected_allowed_methods.update(e.allowed_methods)\n                found_path_match_but_not_method = True\n            except HTTPNotFoundException:\n                # Mounted router did not find the path. Continue search.\n                pass\n\n    # 2. Check sub-routers in reverse order of addition (LIFO for matching)\n    for sub_router in reversed(sub_routers):\n        try:\n            resolved_in_sub = sub_router.resolve_route(request_path, request_method)\n            if resolved_in_sub:\n                handler, params, settings = resolved_in_sub\n                # Merge router settings with any more specific settings\n                merged_settings = {\n                    **router_settings,\n                    **sub_router._settings,\n                    **settings,\n                }\n                return handler, params, merged_settings\n        except HTTPMethodNotAllowedException as e:\n            # Sub-router matched the path but not the method.\n            # Collect its allowed methods and mark that a path match occurred.\n            collected_allowed_methods.update(e.allowed_methods)\n            found_path_match_but_not_method = True\n            # Continue searching other sub-routers or parent's direct routes.\n        except HTTPNotFoundException:\n            # Sub-router did not find the path at all. Continue search.\n            pass\n\n    # 3. Check own routes\n    for (\n        path_pattern,\n        route_specific_methods,\n        handler_callable,\n        route_settings,\n    ) in routes:\n        match_info = match_path_func(request_path, path_pattern)\n        if match_info is not None:  # Path matches\n            found_path_match_but_not_method = (\n                True  # Mark that we at least matched the path\n            )\n            if (\n                route_specific_methods is None\n                or request_method.upper() in route_specific_methods\n            ):\n                # Path and method match\n                # Merge router settings with route settings\n                merged_settings = {**router_settings, **route_settings}\n                return handler_callable, match_info, merged_settings\n            else:\n                # Path matches, but method is not allowed for this specific route.\n                # Collect allowed methods.\n                if route_specific_methods:\n                    collected_allowed_methods.update(route_specific_methods)\n\n    # 4. After checking all mounted routers, sub-routers and own routes:\n    if found_path_match_but_not_method and collected_allowed_methods:\n        # We found one or more path matches, but no method matches for that path.\n        # And we have a list of methods that *would* have been allowed.\n        raise HTTPMethodNotAllowedException(\n            f\"Method {request_method} not allowed for {request_path}\",\n            allowed_methods=list(collected_allowed_methods),\n        )\n\n    # If no path match was found at all, or if path matched but no methods were ever defined for it\n    # (e.g. route_specific_methods was None and it wasn't a match, which is unlikely with current logic\n    # but covering bases if collected_allowed_methods is empty despite found_path_match_but_not_method)\n    if found_path_match_but_not_method and not collected_allowed_methods:\n        # This case implies a path was matched by a route that allows ALL methods (None),\n        # but the request_method somehow didn't trigger the \"return handler_callable, match_info\"\n        # This shouldn't happen if request_method.upper() is in route_specific_methods when it's None.\n        # For safety, if we matched a path but have no specific allowed methods to suggest,\n        # it's still a method not allowed situation, but without specific 'Allow' header.\n        # However, current logic means if route_specific_methods is None, it's an immediate match.\n        # This path should ideally not be hit frequently.\n        # To be safe, we will treat it as a 404 if no specific methods were collected.\n        pass\n\n    # No route matched the path at all, or a path was matched but it didn't lead to a 405 (e.g. ill-defined route).\n    return None\n</code></pre>"},{"location":"reference/serv/routing/resolvers/#serv.routing.resolvers.resolve_websocket_route","title":"resolve_websocket_route","text":"<pre><code>resolve_websocket_route(\n    request_path: str,\n    mounted_routers: list[tuple[str, Router]],\n    sub_routers: list[Router],\n    websocket_routes: list[\n        tuple[str, Callable, dict[str, Any]]\n    ],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[\n        [str, str], dict[str, Any] | None\n    ],\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Resolve a WebSocket route for the given path.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The WebSocket request path to match against registered routes</p> required <code>mounted_routers</code> <code>list[tuple[str, Router]]</code> <p>List of (mount_path, router) tuples</p> required <code>sub_routers</code> <code>list[Router]</code> <p>List of sub-routers to check</p> required <code>websocket_routes</code> <code>list[tuple[str, Callable, dict[str, Any]]]</code> <p>List of WebSocket route tuples (path, handler, settings)</p> required <code>router_settings</code> <code>dict[str, Any]</code> <p>Router-level settings to merge</p> required <code>match_path_func</code> <code>Callable[[str, str], dict[str, Any] | None]</code> <p>Function to perform path pattern matching</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_params, route_settings) if a matching</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>WebSocket route is found, None otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler, params, settings = resolve_websocket_route(\n...     \"/ws/user/123\", [], [],\n...     [(\"/ws/user/{id}\", ws_handler, {})],\n...     {}, match_path\n... )\n&gt;&gt;&gt; if handler:\n...     # Handle WebSocket connection\n...     await handler(websocket, **params)\n</code></pre> Source code in <code>serv/routing/resolvers.py</code> <pre><code>def resolve_websocket_route(\n    request_path: str,\n    mounted_routers: list[tuple[str, \"Router\"]],\n    sub_routers: list[\"Router\"],\n    websocket_routes: list[tuple[str, Callable, dict[str, Any]]],\n    router_settings: dict[str, Any],\n    match_path_func: Callable[[str, str], dict[str, Any] | None]\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Resolve a WebSocket route for the given path.\n\n    Args:\n        request_path: The WebSocket request path to match against registered routes\n        mounted_routers: List of (mount_path, router) tuples\n        sub_routers: List of sub-routers to check\n        websocket_routes: List of WebSocket route tuples (path, handler, settings)\n        router_settings: Router-level settings to merge\n        match_path_func: Function to perform path pattern matching\n\n    Returns:\n        A tuple of (handler_callable, path_params, route_settings) if a matching\n        WebSocket route is found, None otherwise.\n\n    Examples:\n        &gt;&gt;&gt; handler, params, settings = resolve_websocket_route(\n        ...     \"/ws/user/123\", [], [],\n        ...     [(\"/ws/user/{id}\", ws_handler, {})],\n        ...     {}, match_path\n        ... )\n        &gt;&gt;&gt; if handler:\n        ...     # Handle WebSocket connection\n        ...     await handler(websocket, **params)\n    \"\"\"\n    # First check sub-routers (they take precedence)\n    for sub_router in reversed(sub_routers):\n        result = sub_router.resolve_websocket(request_path)\n        if result:\n            return result\n\n    # Check mounted routers\n    for mount_path, mounted_router in mounted_routers:\n        if request_path.startswith(mount_path):\n            # Remove the mount path prefix before checking the mounted router\n            relative_path = request_path[len(mount_path) :] or \"/\"\n            result = mounted_router.resolve_websocket(relative_path)\n            if result:\n                return result\n\n    # Check our own WebSocket routes\n    for path_pattern, handler, settings in websocket_routes:\n        path_params = match_path_func(request_path, path_pattern)\n        if path_params is not None:\n            # Merge router-level settings with route-specific settings\n            merged_settings = {**router_settings, **settings}\n            return handler, path_params, merged_settings\n\n    return None\n</code></pre>"},{"location":"reference/serv/routing/router/","title":"router","text":""},{"location":"reference/serv/routing/router/#serv.routing.router","title":"serv.routing.router","text":""},{"location":"reference/serv/routing/router/#serv.routing.router.Router","title":"Router","text":"<pre><code>Router(settings: dict[str, Any] = None)\n</code></pre> <p>               Bases: <code>RouterProtocol</code></p> <p>HTTP request router for mapping URLs to handlers.</p> <p>The Router class is responsible for matching incoming HTTP requests to the appropriate handler functions or Route classes. It supports path parameters, HTTP method filtering, route mounting, and URL generation.</p> <p>Features: - Path parameter extraction (e.g., <code>/users/{id}</code>) - HTTP method-specific routing - Route mounting and sub-routers - URL generation with <code>url_for()</code> - Route settings and metadata - Flexible handler types (functions, Route classes) - WebSocket route support</p> <p>Examples:</p> <p>Basic router setup:</p> <pre><code>from serv.routing.router import Router\n\nrouter = Router()\n\n# Add function-based routes\nasync def get_users():\n    return {\"users\": []}\n\nrouter.add_route(\"/users\", get_users, [\"GET\"])\n\n# Add Route class\nclass UserRoute:\n    async def handle_get(self, request):\n        return {\"user\": \"data\"}\n\nrouter.add_route(\"/users/{id}\", UserRoute)\n\n# Add WebSocket handler\nasync def websocket_handler(websocket):\n    async for message in websocket:\n        await websocket.send(message)\n\nrouter.add_websocket(\"/ws\", websocket_handler)\n</code></pre> <p>Router with settings:</p> <pre><code>router = Router(settings={\n    \"auth_required\": True,\n    \"rate_limit\": 100\n})\n</code></pre> <p>Mounting sub-routers:</p> <pre><code>api_router = Router()\napi_router.add_route(\"/users\", users_handler)\napi_router.add_route(\"/posts\", posts_handler)\n\nmain_router = Router()\nmain_router.mount(\"/api/v1\", api_router)\n# Now /api/v1/users and /api/v1/posts are available\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of router-level settings that will be available to all routes handled by this router.</p> <code>None</code> Source code in <code>serv/routing/router.py</code> <pre><code>def __init__(self, settings: dict[str, Any] = None):\n    # Stores tuples of (path_pattern, methods, handler_callable, settings)\n    self._routes: list[\n        tuple[str, frozenset[str] | None, Callable, dict[str, Any]]\n    ] = []\n    # Stores WebSocket routes as tuples of (path_pattern, handler_callable, settings)\n    self._websocket_routes: list[tuple[str, Callable, dict[str, Any]]] = []\n    # Stores mapping of (route_class -&gt; path_pattern) for url_for lookups\n    self._route_class_paths: dict[type[routes.Route], list[str]] = {}\n    # Stores mapping of route path patterns to settings\n    self._route_settings: dict[str, dict[str, Any]] = {}\n    # Stores tuples of (mount_path, router_instance)\n    self._mounted_routers: list[tuple[str, Router]] = []\n    self._sub_routers: list[Router] = []\n    # Router-level settings\n    self._settings: dict[str, Any] = settings or {}\n</code></pre>"},{"location":"reference/serv/routing/router/#serv.routing.router.Router.add_route","title":"add_route","text":"<pre><code>add_route(\n    path: str,\n    handler: type[Route],\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre><pre><code>add_route(\n    path: str,\n    handler: Callable[..., Awaitable[Any]],\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre> <pre><code>add_route(\n    path: str,\n    handler: Callable[..., Awaitable[Any]] | type[Route],\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n    container: Container = None,\n)\n</code></pre> <p>Adds a route to this router.</p> <p>This method can handle both direct route handlers and Route objects. For Route objects, it will automatically register all method and form handlers defined in the route.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern for the route.</p> required <code>handler</code> <code>Callable[..., Awaitable[Any]] | type[Route]</code> <p>Either a Route object or an async handler function.</p> required <code>methods</code> <code>Sequence[str] | None</code> <p>A list of HTTP methods (e.g., ['GET', 'POST']). Only used when handler is a function.     If None, allows all methods.</p> <code>None</code> <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of settings to be added to the container when handling this route.</p> <code>None</code> <code>container</code> <code>Container</code> <p>Optional container instance to use for dependency injection. If not provided, uses the global container.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; router.add_route(\"/users\", user_handler, [\"GET\", \"POST\"])\n&gt;&gt;&gt; router.add_route(\"/items\", ItemRoute, settings={\"db_table\": \"items\"})\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def add_route(\n    self,\n    path: str,\n    handler: \"Callable[..., Awaitable[Any]] | type[routes.Route]\",\n    methods: Sequence[str] | None = None,\n    *,\n    settings: dict[str, Any] = None,\n    container: Container = None,\n):\n    \"\"\"Adds a route to this router.\n\n    This method can handle both direct route handlers and Route objects. For Route objects,\n    it will automatically register all method and form handlers defined in the route.\n\n    Args:\n        path: The path pattern for the route.\n        handler: Either a Route object or an async handler function.\n        methods: A list of HTTP methods (e.g., ['GET', 'POST']). Only used when handler is a function.\n                If None, allows all methods.\n        settings: Optional dictionary of settings to be added to the container when handling this route.\n        container: Optional container instance to use for dependency injection. If not provided, uses the global container.\n\n    Examples:\n        &gt;&gt;&gt; router.add_route(\"/users\", user_handler, [\"GET\", \"POST\"])\n        &gt;&gt;&gt; router.add_route(\"/items\", ItemRoute, settings={\"db_table\": \"items\"})\n    \"\"\"\n    match handler:\n        case type() as route if hasattr(route, \"__method_handlers__\") and hasattr(\n            route, \"__form_handlers__\"\n        ):\n            # Keep track of which paths are mapped to which Route classes\n            if route not in self._route_class_paths:\n                self._route_class_paths[route] = []\n            self._route_class_paths[route].append(path)\n\n            # Initialize the Route class directly to avoid container.call issues\n            # We'll still use a container branch to handle RouteSettings\n            if container is None:\n                # Create a new container from scratch if none was provided\n                from bevy import get_registry\n\n                container = get_registry().create_container()\n\n            with container.branch() as branch_container:\n                branch_container.add(RouteSettings, RouteSettings(**settings or {}))\n                # Create route instance directly instead of using container.call\n                try:\n                    route_instance = route()\n                except Exception as e:\n                    import logging\n\n                    logging.getLogger(__name__).error(\n                        f\"Error initializing route {route}: {e}\"\n                    )\n                    raise\n\n            methods = (\n                route.__method_handlers__.keys() | route.__form_handlers__.keys()\n            )\n            # Store these settings for the actual path\n            self._route_settings[path] = settings or {}\n            self.add_route(\n                path, route_instance.__call__, list(methods), settings=settings\n            )\n\n        case _:\n            normalized_methods = (\n                frozenset(m.upper() for m in methods) if methods else None\n            )\n            self._routes.append((path, normalized_methods, handler, settings or {}))\n</code></pre>"},{"location":"reference/serv/routing/router/#serv.routing.router.Router.add_router","title":"add_router","text":"<pre><code>add_router(router: Router)\n</code></pre> <p>Adds a sub-router. Sub-routers are checked before the current router's own routes. Later added sub-routers are checked first (LIFO order for matching).</p> Source code in <code>serv/routing/router.py</code> <pre><code>def add_router(self, router: \"Router\"):\n    \"\"\"Adds a sub-router. Sub-routers are checked before the current router's own routes.\n    Later added sub-routers are checked first (LIFO order for matching).\"\"\"\n    self._sub_routers.append(router)\n</code></pre>"},{"location":"reference/serv/routing/router/#serv.routing.router.Router.add_websocket","title":"add_websocket","text":"<pre><code>add_websocket(\n    path: str,\n    handler: Callable[..., Awaitable[Any]],\n    *,\n    settings: dict[str, Any] = None,\n)\n</code></pre> <p>Adds a WebSocket route to this router.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path pattern for the WebSocket route.</p> required <code>handler</code> <code>Callable[..., Awaitable[Any]]</code> <p>An async WebSocket handler function that accepts a WebSocket parameter.</p> required <code>settings</code> <code>dict[str, Any]</code> <p>Optional dictionary of settings to be added to the container when handling this route.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def echo_handler(websocket):\n...     async for message in websocket:\n...         await websocket.send(message)\n&gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler)\n</code></pre> <pre><code>&gt;&gt;&gt; # With settings\n&gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler, settings={\"auth_required\": True})\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def add_websocket(\n    self,\n    path: str,\n    handler: \"Callable[..., Awaitable[Any]]\",\n    *,\n    settings: dict[str, Any] = None,\n):\n    \"\"\"Adds a WebSocket route to this router.\n\n    Args:\n        path: The path pattern for the WebSocket route.\n        handler: An async WebSocket handler function that accepts a WebSocket parameter.\n        settings: Optional dictionary of settings to be added to the container when handling this route.\n\n    Examples:\n        &gt;&gt;&gt; async def echo_handler(websocket):\n        ...     async for message in websocket:\n        ...         await websocket.send(message)\n        &gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler)\n\n        &gt;&gt;&gt; # With settings\n        &gt;&gt;&gt; router.add_websocket(\"/ws\", echo_handler, settings={\"auth_required\": True})\n    \"\"\"\n    self._websocket_routes.append((path, handler, settings or {}))\n</code></pre>"},{"location":"reference/serv/routing/router/#serv.routing.router.Router.mount","title":"mount","text":"<pre><code>mount(path: str, router: Router)\n</code></pre> <p>Mounts a router at a specific path.</p> <p>Unlike add_router which adds a router with full request path access, mount prefixes all routes in the mounted router with the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path prefix where the router should be mounted.  Should start with a '/' and not end with one.</p> required <code>router</code> <code>Router</code> <p>The router instance to mount at the specified path.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; api_router = Router()\n&gt;&gt;&gt; api_router.add_route(\"/users\", users_handler)\n&gt;&gt;&gt; main_router.mount(\"/api\", api_router)\n# Now \"/api/users\" will be handled by users_handler\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def mount(self, path: str, router: \"Router\"):\n    \"\"\"Mounts a router at a specific path.\n\n    Unlike add_router which adds a router with full request path access,\n    mount prefixes all routes in the mounted router with the given path.\n\n    Args:\n        path: The path prefix where the router should be mounted.\n             Should start with a '/' and not end with one.\n        router: The router instance to mount at the specified path.\n\n    Examples:\n        &gt;&gt;&gt; api_router = Router()\n        &gt;&gt;&gt; api_router.add_route(\"/users\", users_handler)\n        &gt;&gt;&gt; main_router.mount(\"/api\", api_router)\n        # Now \"/api/users\" will be handled by users_handler\n    \"\"\"\n    if not path.startswith(\"/\"):\n        path = \"/\" + path\n    if path.endswith(\"/\"):\n        path = path[:-1]\n\n    self._mounted_routers.append((path, router))\n</code></pre>"},{"location":"reference/serv/routing/router/#serv.routing.router.Router.resolve_route","title":"resolve_route","text":"<pre><code>resolve_route(\n    request_path: str, request_method: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Recursively finds a handler for the given path and method.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The path of the incoming request.</p> required <code>request_method</code> <code>str</code> <p>The HTTP method of the incoming request.</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>None if no route matches the path (results in a 404).</p> <p>Raises:</p> Type Description <code>HTTPMethodNotAllowedException</code> <p>If one or more routes match the path but not the method,                            and no route matches both path and method.</p> Source code in <code>serv/routing/router.py</code> <pre><code>def resolve_route(\n    self, request_path: str, request_method: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Recursively finds a handler for the given path and method.\n\n    Args:\n        request_path: The path of the incoming request.\n        request_method: The HTTP method of the incoming request.\n\n    Returns:\n        A tuple of (handler_callable, path_parameters_dict, settings_dict) if a match is found.\n        None if no route matches the path (results in a 404).\n\n    Raises:\n        HTTPMethodNotAllowedException: If one or more routes match the path but not the method,\n                                       and no route matches both path and method.\n    \"\"\"\n    from serv.routing.resolvers import resolve_http_route\n\n    return resolve_http_route(\n        request_path,\n        request_method,\n        self._mounted_routers,\n        self._sub_routers,\n        self._routes,\n        self._settings,\n        self._match_path\n    )\n</code></pre>"},{"location":"reference/serv/routing/router/#serv.routing.router.Router.resolve_websocket","title":"resolve_websocket","text":"<pre><code>resolve_websocket(\n    request_path: str,\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None\n</code></pre> <p>Resolve a WebSocket route for the given path.</p> <p>Parameters:</p> Name Type Description Default <code>request_path</code> <code>str</code> <p>The WebSocket request path to match against registered routes.</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>A tuple of (handler_callable, path_params, route_settings) if a matching</p> <code>tuple[Callable, dict[str, Any], dict[str, Any]] | None</code> <p>WebSocket route is found, None otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler, params, settings = router.resolve_websocket(\"/ws/user/123\")\n&gt;&gt;&gt; if handler:\n...     # Handle WebSocket connection\n...     await handler(websocket, **params)\n</code></pre> Source code in <code>serv/routing/router.py</code> <pre><code>def resolve_websocket(\n    self, request_path: str\n) -&gt; tuple[Callable, dict[str, Any], dict[str, Any]] | None:\n    \"\"\"Resolve a WebSocket route for the given path.\n\n    Args:\n        request_path: The WebSocket request path to match against registered routes.\n\n    Returns:\n        A tuple of (handler_callable, path_params, route_settings) if a matching\n        WebSocket route is found, None otherwise.\n\n    Examples:\n        &gt;&gt;&gt; handler, params, settings = router.resolve_websocket(\"/ws/user/123\")\n        &gt;&gt;&gt; if handler:\n        ...     # Handle WebSocket connection\n        ...     await handler(websocket, **params)\n    \"\"\"\n    from serv.routing.resolvers import resolve_websocket_route\n\n    return resolve_websocket_route(\n        request_path,\n        self._mounted_routers,\n        self._sub_routers,\n        self._websocket_routes,\n        self._settings,\n        self._match_path\n    )\n</code></pre>"},{"location":"reference/serv/routing/router/#serv.routing.router.Router.url_for","title":"url_for","text":"<pre><code>url_for(handler: Callable | type[Route], **kwargs) -&gt; str\n</code></pre> <p>Builds a URL for a registered route handler with the given path parameters.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable | type[Route]</code> <p>The route handler function or Route class for which to build a URL.</p> required <code>**kwargs</code> <p>Path parameters to substitute in the URL pattern.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A URL string with path parameters filled in.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the handler is not found in any router, or if required path        parameters are missing from kwargs.</p> Source code in <code>serv/routing/router.py</code> <pre><code>def url_for(self, handler: Callable | type[\"routes.Route\"], **kwargs) -&gt; str:\n    \"\"\"Builds a URL for a registered route handler with the given path parameters.\n\n    Args:\n        handler: The route handler function or Route class for which to build a URL.\n        **kwargs: Path parameters to substitute in the URL pattern.\n\n    Returns:\n        A URL string with path parameters filled in.\n\n    Raises:\n        ValueError: If the handler is not found in any router, or if required path\n                   parameters are missing from kwargs.\n    \"\"\"\n    # Import generation functions to avoid circular dependency\n    from serv.routing.generation import url_for_route_class, url_for_function_handler\n\n    # Import routes at runtime to avoid circular dependency\n    import serv.routes as routes\n\n    # First check if handler is a Route class\n    if isinstance(handler, type) and issubclass(handler, routes.Route):\n        return url_for_route_class(\n            self._route_class_paths,\n            self._mounted_routers,\n            self._sub_routers,\n            handler,\n            **kwargs\n        )\n\n    # Handle methods on Route instances (less common case)\n    elif hasattr(handler, \"__self__\"):\n        if isinstance(handler.__self__, routes.Route):\n            route_instance = handler.__self__\n            handler = route_instance.__call__\n            path = self._find_handler_path(handler)\n            if not path:\n                raise ValueError(\n                    f\"Route instance method {handler.__name__} not found in any router\"\n                )\n\n            from serv.routing.generation import build_url_from_path\n            return build_url_from_path(path, kwargs)\n\n    # For function handlers\n    else:\n        return url_for_function_handler(\n            self._routes,\n            self._mounted_routers,\n            self._sub_routers,\n            handler,\n            **kwargs\n        )\n</code></pre>"},{"location":"reference/serv/routing/router/#serv.routing.router.get_current_router","title":"get_current_router","text":"<pre><code>get_current_router(container: Inject[Container]) -&gt; Router\n</code></pre> <p>Retrieves the current request's root Router instance from the Bevy container.</p> Source code in <code>serv/routing/router.py</code> <pre><code>@injectable\ndef get_current_router(container: Inject[Container]) -&gt; Router:\n    \"\"\"Retrieves the current request's root Router instance from the Bevy container.\"\"\"\n    try:\n        return container.get(Router)\n    except Exception as e:  # Bevy might raise a specific exception if not found\n        raise RuntimeError(\n            \"Router not found in the current request container. Ensure it's added during request setup.\"\n        ) from e\n</code></pre>"}]}