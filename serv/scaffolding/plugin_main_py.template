from serv.plugins import Plugin
from serv.app import App
# from serv.routes import Route
# from serv.responses import TextResponse, JSONResponse, Template
# from typing import Annotated
# import logging

# logger = logging.getLogger(__name__) # Optional: get a logger specific to your plugin

# Example Route (Uncomment and modify if your plugin provides routes)
# class {class_name}Route(Route):
#     async def handle_get(self, request):
#         # Access plugin's own config: self.plugin_config (if Plugin class is enhanced)
#         # Or from app: app_plugin_config = request.app.plugins_config.get('{module_base_name}', {{}})
#         # message = app_plugin_config.get("greeting", "Hello from {class_name}!")
#         message = "Hello from {class_name}!"
#         return TextResponse(message)

class {class_name}(Plugin):
    def on_load(self) -> None:
        '''Called when the plugin is loaded.
        
        This is a good place to initialize resources or perform setup
        that the plugin needs. You can access plugin-specific configuration
        via `self.config` (which is a dictionary).
        '''
        # Use the main 'serv' logger or get your own as shown above
        logger.info(f"'{{self.name}}' plugin (v{{self.version}}) loaded.")
        # Example: Accessing a configuration value from plugin.yaml's config section
        # example_setting = self.config.get("example_setting", "default_value")
        # logger.info(f"'{{self.name}}' example_setting: {{example_setting}}")

    def on_app_startup(self, app: App) -> None:
        '''Called when the application is starting up.
        
        This method is called once the application instance is created and
        basic setup (like config loading) is done, but before the server
        starts accepting requests. Useful for setting up shared resources
        or adding routes to the application.
        
        Args:
            app: The Serv application instance.
        '''
        # The router configuration in plugin.yaml will be automatically processed
        # but you can also add routes programmatically:
        # 
        # from serv.routing import Router
        # router = app._container.get(Router)
        # router.add_route("/example", {class_name}Route)
        pass

    def on_app_shutdown(self, app: App) -> None:
        '''Called when the application is shutting down.
        
        Useful for cleaning up resources that the plugin might have created
        or maintained during its lifecycle.
        
        Args:
            app: The Serv application instance.
        '''
        logger.info(f"'{{self.name}}' plugin shutting down.")
        pass

    # Example handler methods for routes defined in plugin.yaml
    # These can be referenced by handler_method in the routes configuration
    #
    # async def handle_home(self):
    #     """Handle the home route."""
    #     return Template("home.html", {"title": "Welcome to {class_name}"})
    #
    # async def handle_api(self):
    #     """Handle the API route."""
    #     return JSONResponse({"plugin": "{class_name}", "status": "active"})

    # Other potential lifecycle methods to uncomment and use:
    #
    # def on_app_route_added(self, app: App, path: str, route_handler) -> None:
    #     '''Called after a route has been added to the application's router.'''
    #     pass
    #
    # def on_app_request_begin(self, app: App) -> None:
    #    '''Called at the beginning of every request, before routing.'''
    #    pass
    #
    # def on_app_request_end(self, app: App, response, exc: Exception | None) -> None:
    #    '''Called at the end of every request, after a response is generated or an exception occurs.'''
    #    pass

    # You can define other methods specific to your plugin's functionality. 